////////////////////////////////////////////////////////////////////////////////
// МОДУЛЬ СОДЕРЖИТ РЕАЛИЗАЦИЮ МЕХАНИКИ РАБОТЫ С ФАЙЛАМИ
// 

////////////////////////////////////////////////////////////////////////////////
//  Служебные функции

// Освобождает файл
// Параметры:
// ДанныеФайла - структура, содержащая сведения о Файле
// 	см. функцию ПолучитьДанныеФайла()

// Параметры
//  ДанныеФайла  - структура с данными файла
//  УникальныйИдентификатор - уникальный идентификатор формы
Процедура ОсвободитьФайл(ДанныеФайла, УникальныйИдентификатор = Неопределено) Экспорт
	
	ФайлОбъект = ДанныеФайла.Ссылка.ПолучитьОбъект();
	
	ЗаблокироватьДанныеДляРедактирования(ФайлОбъект.Ссылка, , УникальныйИдентификатор);
	ФайлОбъект.Редактирует = Справочники.Пользователи.ПустаяСсылка();
	ФайлОбъект.ДатаЗаема = Дата("00010101000000");
	ФайлОбъект.Записать();
	РазблокироватьДанныеДляРедактирования(ФайлОбъект.Ссылка, УникальныйИдентификатор);
	
	ДанныеФайла.Вставить("ЕстьЗашифрованныеИлиЗанятыеФайлы", ЕстьЗашифрованныеИлиЗанятыеФайлы(ДанныеФайла.Владелец));
	
	БизнесСобытияВызовСервера.ЗарегистрироватьСобытие(ДанныеФайла.Ссылка, Справочники.ВидыБизнесСобытий.ОсвобождениеФайла);
	
КонецПроцедуры    

// Занимает файл на редактирование (checkout)
// Параметры
//  ДанныеФайла  - структура с данными файла
//  СтрокаОшибки - строка, в которой возвращается причина ошибки в случае неуспеха (скажем "Файл занят другим пользователем")
//  УникальныйИдентификатор - уникальный идентификатор формы
//
// Возвращаемое значение:
//   Булево  - успешно ли выполнена операция
Функция ЗанятьФайл(ДанныеФайла, СтрокаОшибки, ДатаЗаема, УникальныйИдентификатор = Неопределено) Экспорт

	Если Не РаботаСФайламиПереопределяемый.ВозможноЗанятьФайл(ДанныеФайла, СтрокаОшибки) Тогда 
		Возврат Ложь;
	КонецЕсли;
	
	ФайлОбъект = ДанныеФайла.Ссылка.ПолучитьОбъект();
	
	ЗаблокироватьДанныеДляРедактирования(ФайлОбъект.Ссылка, , УникальныйИдентификатор);
	ФайлОбъект.Редактирует = Пользователи.ТекущийПользователь();
	ФайлОбъект.ДатаЗаема = ДатаЗаема;
	
	Попытка
		ФайлОбъект.Записать();
	Исключение
		РазблокироватьДанныеДляРедактирования(ФайлОбъект.Ссылка, УникальныйИдентификатор);
		ВызватьИсключение;
	КонецПопытки;    
	
	РазблокироватьДанныеДляРедактирования(ФайлОбъект.Ссылка, УникальныйИдентификатор);

	НавигационнаяСсылкаТекущейВерсии = ДанныеФайла.НавигационнаяСсылкаТекущейВерсии;
	РабочийКаталогВладельца = ДанныеФайла.РабочийКаталогВладельца;
	
	ДанныеФайла = ПолучитьДанныеФайла(
		ДанныеФайла.Ссылка, ДанныеФайла.Версия);
		
	ДанныеФайла.НавигационнаяСсылкаТекущейВерсии = НавигационнаяСсылкаТекущейВерсии;
	ДанныеФайла.РабочийКаталогВладельца = РабочийКаталогВладельца;
	ДанныеФайла.Вставить("ЕстьЗашифрованныеИлиЗанятыеФайлы", ЕстьЗашифрованныеИлиЗанятыеФайлы(ДанныеФайла.Владелец));
	
	БизнесСобытияВызовСервера.ЗарегистрироватьСобытие(ДанныеФайла.Ссылка, Справочники.ВидыБизнесСобытий.ЗахватФайлаДляРедактирования);	
	
	Возврат Истина;
	
КонецФункции // ЗанятьФайл()

// Переносит Файл в другую папку
// Параметры
//  ДанныеФайла  - структура с данными файла
//  Папка - СправочникСсылка.ПапкиФайлов - ссылка на папку, куда нужно переместить файл
Процедура ПеренестиФайл(ДанныеФайла, Папка) Экспорт 
	
	ПрежнийВладелец = ДанныеФайла.Ссылка.ВладелецФайла;
	
	ФайлОбъект = ДанныеФайла.Ссылка.ПолучитьОбъект();
	ФайлОбъект.Заблокировать();
	ФайлОбъект.ВладелецФайла = Папка;
	ФайлОбъект.Записать();
	
	ПротоколированиеРаботыПользователей.ЗаписатьПеремещениеФайла(ДанныеФайла.Ссылка, ПрежнийВладелец, Папка);
	
КонецПроцедуры

// Переносит Файлы в другую папку
// Параметры
//  ОбъектыСсылка - Массив - массив ссылок на файлы
//  Папка - СправочникСсылка.ПапкиФайлов - ссылка на папку, куда нужно переместить файлы
Функция ПеренестиФайлы(ОбъектыСсылка, Папка) Экспорт 
	
	ДанныеФайлов = Новый Массив;
	
	Для Каждого ФайлСсылка Из ОбъектыСсылка Цикл
		ПеренестиФайл(ФайлСсылка, Папка);         		
		ДанныеФайла = ПолучитьДанныеФайла(ФайлСсылка);
		ДанныеФайлов.Добавить(ДанныеФайла);
	КонецЦикла;    
	
	Возврат ДанныеФайлов;
		
КонецФункции

// Создает карточку Файла в БД
// Параметры
// Владелец - владелец файла - будет установлен в реквизит ВладелецФайла у созданного файла
// Комментарий  - Строка - комментарий к файлу
// ИмяБезРасширения  - Строка - имя файла без расширения
// ХранитьВерсии  - Булево - хранить версии
// АдресВременногоХранилищаТекста - Строка - содержит адрес во временном хранилище, где находятся двоичные данные с файлом текста или ХранилищеЗначения - непосредственно содержит  двоичные данные с файлом текста
// Пользователь - СправочникСсылка.Пользователи - ссылка на пользователя - автора файла
// 
// Возвращаемое значение:
//   СправочникСсылка.Файлы - ссылка на созданный файл
Функция СоздатьФайл(Знач Владелец, Знач Комментарий, Знач ИмяБезРасширения, 
	Знач ХранитьВерсии, Знач АдресВременногоХранилищаТекста,
	Пользователь = Неопределено, ИдентификаторФайла = Неопределено) Экспорт
	
	Файл = Справочники.Файлы.СоздатьЭлемент();
	Если ИдентификаторФайла <> Неопределено Тогда
		Файл.УстановитьСсылкуНового(Справочники.Файлы.ПолучитьСсылку(ИдентификаторФайла));
	КонецЕсли;
	Файл.ВладелецФайла = Владелец;
	Файл.Наименование = ИмяБезРасширения;
	Файл.ПолноеНаименование = ИмяБезРасширения;
	
	Если Пользователь = Неопределено Тогда
		Файл.Автор = Пользователи.ТекущийПользователь();
	Иначе	
		Файл.Автор = Пользователь;
	КонецЕсли;	
	
	Файл.ДатаСоздания = ТекущаяДатаСеанса();
	Файл.Описание = Комментарий;
	Файл.ИндексКартинки = ФайловыеФункцииКлиентСервер.ПолучитьИндексПиктограммыФайла(Неопределено);
	Файл.ХранитьВерсии = ХранитьВерсии;
	Файл.СтратегияРаспознавания = Перечисления.СтратегииРаспознаванияТекста.НеРаспознавать;
	
	Если ТипЗнч(АдресВременногоХранилищаТекста) = Тип("ХранилищеЗначения") Тогда
		// При создании Файла из шаблона хранилище значения копируется напрямую
		Файл.ТекстХранилище = АдресВременногоХранилищаТекста;
	ИначеЕсли Не ПустаяСтрока(АдресВременногоХранилищаТекста) Тогда
		Текст = ФайловыеФункции.ПолучитьСтрокуИзВременногоХранилища(АдресВременногоХранилищаТекста);
		Файл.ТекстХранилище = Новый ХранилищеЗначения(Текст);
	КонецЕсли;
	
	// заполнение проекта из реквизита владельца
	Если ПолучитьФункциональнуюОпцию("ВестиУчетПоПроектам")
	   И ЗначениеЗаполнено(Файл.ВладелецФайла)
	   И Файл.ВладелецФайла.Метаданные().Реквизиты.Найти("Проект") <> Неопределено Тогда 
		Файл.Проект = ОбщегоНазначения.ПолучитьЗначениеРеквизита(Файл.ВладелецФайла, "Проект");
	КонецЕсли;
	
	Файл.Записать();
	Возврат Файл.Ссылка;
	
КонецФункции // СоздатьФайл()

// Создает версию сохраняемого файла для сохранения в карточке Файла
// и подставляет ссылку на версию в карточку Файла
// Параметры
// ВремяИзменения  - Дата - дата и время изменения файла
// ВремяИзмененияУниверсальное  - Дата - UTC дата и время изменения файла
// ДокСсылка - СправочникСсылка.Файлы - Файл, в котором создается версия
// ИмяБезРасширения  - Строка - имя файла без расширения
// Размер - размер файла в байтах
// Расширение - Строка - расширение файла
// АдресВременногоХранилищаФайла  - Строка - содержит адрес во временном хранилище, где находятся двоичные данные с файлом или ХранилищеЗначения - непосредственно содержит  двоичные данные с файлом
// АдресВременногоХранилищаТекста - Строка - содержит адрес во временном хранилище, где находятся двоичные данные с файлом текста или ХранилищеЗначения - непосредственно содержит  двоичные данные с файлом текста
// ЭтоВебКлиент - Булево - Истина, если вызов идет из веб клиента
// ХранитьВерсии  - Булево - хранить версии
// Пользователь - СправочникСсылка.Пользователи - ссылка на пользователя - автора файла
Процедура СоздатьВерсиюИОбновитьВерсиюВФайле(
	ВремяИзменения,
	ВремяИзмененияУниверсальное,
	ДокСсылка, 
	ИмяБезРасширения, 
	Размер, 
	Расширение, 
	АдресВременногоХранилищаФайла, 
	АдресВременногоХранилищаТекста,
	ЭтоВебКлиент = Ложь,
	Пользователь = Неопределено,
	НоваяВерсияКомментарий = Неопределено) Экспорт
	
	ВерсияСсылка = СоздатьВерсию(
		ВремяИзменения, 
		ВремяИзмененияУниверсальное,
		ДокСсылка, 
		ИмяБезРасширения, 
		Размер, 
		Расширение, 
		АдресВременногоХранилищаФайла, 
		АдресВременногоХранилищаТекста,
		ЭтоВебКлиент,
		Неопределено, // СсылкаНаВерсиюИсточник = 
		Неопределено, // НоваяВерсияДатаСоздания =  
		Пользователь,
		НоваяВерсияКомментарий, // НоваяВерсияКомментарий
		Неопределено // НоваяВерсияНомерВерсии
		);
	
	ОбновитьВерсиюВФайле(ДокСсылка, ВерсияСсылка, АдресВременногоХранилищаТекста);
	
КонецПроцедуры // СоздатьВерсиюИОбновитьВерсиюВФайле()

// Находит максимальный номер версии для данного объекта Файл. Если нет версий - то 0
// Параметры
//  ФайлСсылка  - СправочникСсылка.Файлы - ссылка на файл
//
// Возвращаемое значение:
//   Число  - максимальный номер версии
Функция НайтиМаксимальныйНомерВерсии(ФайлСсылка)
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
				   |	ЕСТЬNULL(МАКСИМУМ(Версии.НомерВерсии), 0) КАК МаксимальныйНомер
				   |ИЗ
				   |	Справочник.ВерсииФайлов КАК Версии
				   |ГДЕ
				   |	Версии.Владелец = &Файл";
	
	Запрос.Параметры.Вставить("Файл", ФайлСсылка);
		
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		
		Если Выборка.МаксимальныйНомер = Null Тогда
			Возврат 0;
		КонецЕсли;
		
		Возврат Число(Выборка.МаксимальныйНомер);
	КонецЕсли;
	
	Возврат 0;
КонецФункции // НайтиМаксимальныйНомерВерсии

// Возвращает ИспользоватьРаспознавание
Функция ПолучитьИспользоватьРаспознавание() Экспорт
	УстановитьПривилегированныйРежим(Истина);
	ИспользоватьРаспознавание = Константы.ИспользоватьРаспознавание.Получить();
	УстановитьПривилегированныйРежим(Ложь);
	Возврат ИспользоватьРаспознавание;
КонецФункции

// Возвращает Истина, если есть хоть одно условие в справочнике ПравилаРазмещенияФайловВТомах
Функция ИспользоватьРазмещениеВТомахПоУсловиям() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ПравилаРазмещенияФайловВТомах.Ссылка
		|ИЗ
		|	Справочник.ПравилаРазмещенияФайловВТомах КАК ПравилаРазмещенияФайловВТомах
		|ГДЕ
		|	ПравилаРазмещенияФайловВТомах.ПометкаУдаления = ЛОЖЬ";
	
	Возврат (Не Запрос.Выполнить().Пустой());
	
КонецФункции // ИспользоватьРазмещениеВТомахПоУсловиям

// Делает запись бизнес-события изменения файла в папке
// Папка - папка файлов
// Файл - файл
// РазмерФайла - размер файла версии
Процедура ЗарегистрироватьИзменениеФайла(Файл) Экспорт
	
	ВидСобытия = Справочники.ВидыБизнесСобытий.ИзменениеФайла;
	БизнесСобытияВызовСервера.ЗарегистрироватьСобытие(Файл, ВидСобытия);
	
	ВладелецФайла = ОбщегоНазначения.ПолучитьЗначениеРеквизита(Файл, "ВладелецФайла");
	
	Если ТипЗнч(ВладелецФайла) = Тип("СправочникСсылка.ВнутренниеДокументы") Тогда
		
		БизнесСобытияВызовСервера.ЗарегистрироватьСобытие(ВладелецФайла, 
			Справочники.ВидыБизнесСобытий.ИзменениеВнутреннегоДокумента);
			
	ИначеЕсли ТипЗнч(ВладелецФайла) = Тип("СправочникСсылка.ВходящиеДокументы") Тогда
			
		БизнесСобытияВызовСервера.ЗарегистрироватьСобытие(ВладелецФайла, 
			Справочники.ВидыБизнесСобытий.ИзменениеВходящегоДокумента);
			
	ИначеЕсли ТипЗнч(ВладелецФайла) = Тип("СправочникСсылка.ИсходящиеДокументы") Тогда
			
		БизнесСобытияВызовСервера.ЗарегистрироватьСобытие(ВладелецФайла, 
			Справочники.ВидыБизнесСобытий.ИзменениеИсходящегоДокумента);
			
	ИначеЕсли ТипЗнч(ВладелецФайла) = Тип("СправочникСсылка.Мероприятия") Тогда
			
		БизнесСобытияВызовСервера.ЗарегистрироватьСобытие(ВладелецФайла, 
			Справочники.ВидыБизнесСобытий.ИзменениеМероприятия);
			
	КонецЕсли;	
	
КонецПроцедуры	

// Создает версию сохраняемого файла для сохранения в карточке Файла
// Параметры
// ВремяИзменения  - Дата - дата и время изменения файла
// ВремяИзмененияУниверсальное  - Дата - UTC дата и время изменения файла
// ДокСсылка - СправочникСсылка.Файлы - Файл, в котором создается версия
// ИмяБезРасширения  - Строка - имя файла без расширения
// Размер - размер файла в байтах
// Расширение - Строка - расширение файла
// АдресВременногоХранилищаФайла  - Строка - содержит адрес во временном хранилище, где находятся двоичные данные с файлом или ХранилищеЗначения - непосредственно содержит  двоичные данные с файлом
// АдресВременногоХранилищаТекста - Строка - содержит адрес во временном хранилище, где находятся двоичные данные с файлом текста или ХранилищеЗначения - непосредственно содержит  двоичные данные с файлом текста
// ЭтоВебКлиент - Булево - Истина, если вызов идет из веб клиента
// СсылкаНаВерсиюИсточник  - СправочникСсылка.ВерсииФайлов - копируемая версия
// НоваяВерсияДатаСоздания - Дата - дата создания версии
// НоваяВерсияАвтор - СправочникСсылка.Пользователи - ссылка на пользователя - автора версии
// НоваяВерсияКомментарий  - Строка - Комментарий к версии
// НоваяВерсияНомерВерсии - Число - номер версии
// 
// Возвращаемое значение:
//   СправочникСсылка.ВерсииФайлов - созданная версия
Функция СоздатьВерсию(
	ВремяИзменения,
	ВремяИзмененияУниверсальное,
	ДокСсылка, 
	ИмяБезРасширения, 
	Размер, 
	Расширение, 
	АдресВременногоХранилищаФайла, 
	АдресВременногоХранилищаТекста,
	ЭтоВебКлиент = Ложь,
	СсылкаНаВерсиюИсточник = Неопределено,
	НоваяВерсияДатаСоздания = Неопределено,
	НоваяВерсияАвтор = Неопределено,
	НоваяВерсияКомментарий = Неопределено,
	НоваяВерсияНомерВерсии = Неопределено) Экспорт
	
	Перем СсылкаНаТом;
	ХранилищеФайла = Неопределено;
	
	УстановитьПривилегированныйРежим(Истина);

	ЗапретЗагрузкиФайловПоРасширению = ФайловыеФункции.ПолучитьЗапретЗагрузкиФайловПоРасширению();
	СписокЗапрещенныхРасширений = ФайловыеФункции.ПолучитьСписокЗапрещенныхРасширений();
	РасширениеФайла = Расширение;
	Если Не ФайловыеФункцииКлиентСервер.РасширениеФайлаРазрешеноДляЗагрузки(ЗапретЗагрузкиФайловПоРасширению, СписокЗапрещенныхРасширений, РасширениеФайла) Тогда
		ВызватьИсключение
			   СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				 НСтр("ru = 'Загрузка файлов с расширением ""%1"" запрещена. Обратитесь к администратору системы.'"),
				 РасширениеФайла);
	КонецЕсли;    
	
	Версия = Справочники.ВерсииФайлов.СоздатьЭлемент();
	
	Если НоваяВерсияНомерВерсии = Неопределено Тогда
		Версия.НомерВерсии = НайтиМаксимальныйНомерВерсии(ДокСсылка) + 1;
	Иначе
		Версия.НомерВерсии = НоваяВерсияНомерВерсии;
	КонецЕсли;
	
	Версия.Владелец = ДокСсылка;
	Версия.ДатаМодификацииУниверсальная = ВремяИзмененияУниверсальное;
	Версия.ДатаМодификацииФайла = ВремяИзменения;
	
	Версия.Комментарий = НоваяВерсияКомментарий;
	
	Если НоваяВерсияАвтор = Неопределено Тогда
		Версия.Автор = Пользователи.ТекущийПользователь();
	Иначе
		Версия.Автор = НоваяВерсияАвтор;
	КонецЕсли;	
	
	Если НоваяВерсияДатаСоздания = Неопределено Тогда
		Версия.ДатаСоздания = ТекущаяДатаСеанса();
	Иначе
		Версия.ДатаСоздания = НоваяВерсияДатаСоздания;
	КонецЕсли;	
	
	Версия.ПолноеНаименование = ИмяБезРасширения;
	Версия.Размер = Размер;
	Версия.Расширение = ФайловыеФункцииКлиентСервер.РасширениеБезТочки(Расширение);
	
	
	Если Версия.Размер <> 0 Тогда
		МаксРазмерФайла = ФайловыеФункции.ПолучитьМаксимальныйРазмерФайла();
		РазмерВМб = Версия.Размер / (1024 * 1024);
		РазмерВМбМакс = МаксРазмерФайла / (1024 * 1024);
		
		Если Версия.Размер > МаксРазмерФайла Тогда
			ВызватьИсключение
				   СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					 НСтр("ru = 'Размер файла ""%1"" (%2 Мб) превышает максимально допустимый размер файла (%3 Мб).'"),
					 ИмяБезРасширения, 
					 ФайловыеФункцииКлиентСервер.ПолучитьСтрокуСРазмеромФайла(РазмерВМб), 
					 ФайловыеФункцииКлиентСервер.ПолучитьСтрокуСРазмеромФайла(РазмерВМбМакс));
		КонецЕсли;
	КонецЕсли;
	
	ТипХраненияФайлов = ФайловыеФункции.ПолучитьТипХраненияФайлов();
	Версия.ТипХраненияФайла = ТипХраненияФайлов;

	Если ТипХраненияФайлов = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске И ИспользоватьРазмещениеВТомахПоУсловиям() Тогда
		Версия.Записать(); // чтобы при размещении в томе по условию на руках была ссылка на версию
	КонецЕсли;
	
	Если СсылкаНаВерсиюИсточник <> Неопределено Тогда // создание Файла из шаблона
		
		ТипХраненияФайловШаблона = СсылкаНаВерсиюИсточник.ТипХраненияФайла;
		
		Если ТипХраненияФайловШаблона = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе И ТипХраненияФайлов = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
			//  и шаблон, и новый Файл - в базе
			
			// При создании Файла из шаблона хранилище значения копируется напрямую
			ХранилищеФайла = АдресВременногоХранилищаФайла;
			
		ИначеЕсли ТипХраненияФайловШаблона = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске И ТипХраненияФайлов = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
			//  и шаблон, и новый Файл - на диске - просто копируем файл
			
			Если НЕ СсылкаНаВерсиюИсточник.Том.Пустая() Тогда
				ПолныйПутьФайлаШаблона = ФайловыеФункции.ПолныйПутьТома(СсылкаНаВерсиюИсточник.Том) + СсылкаНаВерсиюИсточник.ПутьКФайлу; 
				
				ПутьКФайлу = "";
				
				// добавить в один из томов (где есть свободное место)
				ФайловыеФункции.ДобавитьНаДиск(ПолныйПутьФайлаШаблона, ПутьКФайлу, СсылкаНаТом, ВремяИзмененияУниверсальное, 
					Версия.НомерВерсии, ИмяБезРасширения, Расширение, Версия.Размер, Ложь, Неопределено, Версия.Ссылка);
				Версия.ПутьКФайлу = ПутьКФайлу;
				Версия.Том = СсылкаНаТом.Ссылка;
			КонецЕсли;
			
		ИначеЕсли ТипХраненияФайловШаблона = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе И ТипХраненияФайлов = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
			// шаблон в базе, новый Файл - на диске
			
			ДвоичныеДанные = АдресВременногоХранилищаФайла.Получить(); // в этом случае в АдресВременногоХранилищаФайла находится ХранилищеЗначения с файлом
			
			ПутьКФайлу = "";
			
			// добавить в один из томов (где есть свободное место)
			ФайловыеФункции.ДобавитьНаДиск(ДвоичныеДанные, ПутьКФайлу, СсылкаНаТом, ВремяИзмененияУниверсальное, 
				Версия.НомерВерсии, ИмяБезРасширения, Расширение, Версия.Размер, Ложь, Неопределено, Версия.Ссылка);
			Версия.ПутьКФайлу = ПутьКФайлу;
			Версия.Том = СсылкаНаТом.Ссылка;
			
		ИначеЕсли ТипХраненияФайловШаблона = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске И ТипХраненияФайлов = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
			// шаблон на диске, новый Файл - в базе
			
			Если НЕ СсылкаНаВерсиюИсточник.Том.Пустая() Тогда
				ПолныйПутьФайлаШаблона = ФайловыеФункции.ПолныйПутьТома(СсылкаНаВерсиюИсточник.Том) + СсылкаНаВерсиюИсточник.ПутьКФайлу; 
				ДвоичныеДанные = Новый ДвоичныеДанные(ПолныйПутьФайлаШаблона);
				ХранилищеФайла = Новый ХранилищеЗначения(ДвоичныеДанные);
			КонецЕсли;
			
		КонецЕсли;
	Иначе // создание объекта Файл на основе выбранного файла с диска
		
		Если ТипХраненияФайлов = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
			
			ДвоичныеДанные = Неопределено;
			Если ЭтоАдресВременногоХранилища(АдресВременногоХранилищаФайла) Тогда
				ДвоичныеДанные = ПолучитьИзВременногоХранилища(АдресВременногоХранилищаФайла);
			Иначе
				// в этом случае в АдресВременногоХранилищаФайла - путь к файлу на диске
				ДвоичныеДанные = Новый ДвоичныеДанные(АдресВременногоХранилищаФайла);
			КонецЕсли;	
			
			ХранилищеФайла = Новый ХранилищеЗначения(ДвоичныеДанные);
				
			Если (ЭтоВебКлиент = Истина) И (Версия.Размер = 0) Тогда
				ДвоичныеДанныеФайла = ХранилищеФайла.Получить();
				Версия.Размер = ДвоичныеДанныеФайла.Размер();
				
				МаксРазмерФайла = ФайловыеФункции.ПолучитьМаксимальныйРазмерФайла();
				РазмерВМб = Версия.Размер / (1024 * 1024);
				РазмерВМбМакс = МаксРазмерФайла / (1024 * 1024);
				
				Если Версия.Размер > МаксРазмерФайла Тогда
					ВызватьИсключение
						   СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
							 НСтр("ru = 'Размер файла ""%1"" (%2 Мб) превышает максимально допустимый размер файла (%3 Мб).'"),
							 ИмяБезРасширения, 
							 ФайловыеФункцииКлиентСервер.ПолучитьСтрокуСРазмеромФайла(РазмерВМб), 
							 ФайловыеФункцииКлиентСервер.ПолучитьСтрокуСРазмеромФайла(РазмерВМбМакс));
				КонецЕсли;
				
			КонецЕсли;
				
		Иначе // хранение на диске
			
			ДвоичныеДанные = Неопределено;
			Если ЭтоАдресВременногоХранилища(АдресВременногоХранилищаФайла) Тогда
				ДвоичныеДанные = ПолучитьИзВременногоХранилища(АдресВременногоХранилищаФайла);
			Иначе
				// в этом случае в АдресВременногоХранилищаФайла - путь к файлу на диске
				ДвоичныеДанные = Новый ДвоичныеДанные(АдресВременногоХранилищаФайла);
			КонецЕсли;	
			
			Если (ЭтоВебКлиент = Истина) И (Версия.Размер = 0) Тогда
				Версия.Размер = ДвоичныеДанные.Размер();
				
				МаксРазмерФайла = ФайловыеФункции.ПолучитьМаксимальныйРазмерФайла();
				РазмерВМб = Версия.Размер / (1024 * 1024);
				РазмерВМбМакс = МаксРазмерФайла / (1024 * 1024);
				
				Если Версия.Размер > МаксРазмерФайла Тогда
					ВызватьИсключение
						   СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
							 НСтр("ru = 'Размер файла ""%1"" (%2 Мб) превышает максимально допустимый размер файла (%3 Мб).'"),
							 ИмяБезРасширения, 
							 ФайловыеФункцииКлиентСервер.ПолучитьСтрокуСРазмеромФайла(РазмерВМб), 
							 ФайловыеФункцииКлиентСервер.ПолучитьСтрокуСРазмеромФайла(РазмерВМбМакс));
				КонецЕсли;
			КонецЕсли;
			
			ПутьКФайлу = "";
			
			// добавить в один из томов (где есть свободное место)
			ФайловыеФункции.ДобавитьНаДиск(ДвоичныеДанные, ПутьКФайлу, СсылкаНаТом, ВремяИзмененияУниверсальное, 
				Версия.НомерВерсии, ИмяБезРасширения, Расширение, Версия.Размер, Ложь, Неопределено, Версия.Ссылка);
			Версия.ПутьКФайлу = ПутьКФайлу;
			Версия.Том = СсылкаНаТом.Ссылка;
			
		КонецЕсли; // хранение на диске			
			
	КонецЕсли;	
	
	Версия.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.НеИзвлечен;

	Если ТипЗнч(АдресВременногоХранилищаТекста) = Тип("ХранилищеЗначения") Тогда
		
		// При создании Файла из шаблона хранилище значения копируется напрямую
		Версия.ТекстХранилище = АдресВременногоХранилищаТекста;
		Версия.ИзвлеченныйТекст = Версия.ТекстХранилище; // здесь заполняем только ИзвлеченныйТекст
		Версия.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.Извлечен;
		
	ИначеЕсли Не ПустаяСтрока(АдресВременногоХранилищаТекста) Тогда
		
		Текст = ФайловыеФункции.ПолучитьСтрокуИзВременногоХранилища(АдресВременногоХранилищаТекста);
		Версия.ТекстХранилище = Новый ХранилищеЗначения(Текст);
		Версия.ИзвлеченныйТекст = Версия.ТекстХранилище; // здесь заполняем только ИзвлеченныйТекст
		Версия.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.Извлечен;
		
	КонецЕсли;
		
	Если (ЭтоВебКлиент = Истина) И (Версия.Размер = 0) Тогда
		Если ТипХраненияФайлов = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
			ДвоичныеДанныеФайла = ХранилищеФайла.Получить();
			Версия.Размер = ДвоичныеДанныеФайла.Размер();
		КонецЕсли;
	КонецЕсли;
	
	Версия.СтатусРаспознаванияТекста = Перечисления.СтатусыРаспознаванияТекста.НеНужноРаспознавать;

	Версия.Записать();
	
	Если ТипХраненияФайлов = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
		ЗаписатьФайлВИнформационнуюБазу(Версия.Ссылка, ХранилищеФайла);	
	КонецЕсли;	
	
	ЗаписатьОбращениеКВерсииФайла(Версия.Ссылка);
	
	Возврат Версия.Ссылка;
	
КонецФункции // СоздатьВерсию()

// Подставляет ссылку на версию в карточку Файла
// Параметры
// ФайлСсылка - СправочникСсылка.Файлы - Файл, в котором создается версия
// Версия  - СправочникСсылка.ВерсииФайлов - версия файла
// АдресВременногоХранилищаТекста - Строка - содержит адрес во временном хранилище, где находятся двоичные данные с файлом текста или ХранилищеЗначения - непосредственно содержит  двоичные данные с файлом текста
//  УникальныйИдентификатор - уникальный идентификатор формы
Процедура ОбновитьВерсиюВФайле(ФайлСсылка, Версия, Знач АдресВременногоХранилищаТекста,
	УникальныйИдентификатор = Неопределено) Экспорт
	
	ФайлОбъект = ФайлСсылка.ПолучитьОбъект();
	ЗаблокироватьДанныеДляРедактирования(ФайлОбъект.Ссылка, , УникальныйИдентификатор);
	
	ФайлОбъект.ТекущаяВерсия = Версия.Ссылка;
	
	Если ТипЗнч(АдресВременногоХранилищаТекста) = Тип("ХранилищеЗначения") Тогда
		// При создании Файла из шаблона хранилище значения копируется напрямую
		ФайлОбъект.ТекстХранилище = АдресВременногоХранилищаТекста;
	Иначе
		Текст = ФайловыеФункции.ПолучитьСтрокуИзВременногоХранилища(АдресВременногоХранилищаТекста);
		ФайлОбъект.ТекстХранилище = Новый ХранилищеЗначения(Текст);
	КонецЕсли;
	ФайлОбъект.ДополнительныеСвойства.Вставить("УникальныйИдентификатор", УникальныйИдентификатор);
	ФайлОбъект.Записать();
	РазблокироватьДанныеДляРедактирования(ФайлОбъект.Ссылка, УникальныйИдентификатор);
	
КонецПроцедуры // ОбновитьВерсиюВФайле()

// Обновляет текстовую порцию из файла в карточке файла
// Параметры
// ФайлСсылка - СправочникСсылка.Файлы - Файл, в котором создается версия
// АдресВременногоХранилищаТекста - Строка - содержит адрес во временном хранилище, где находятся двоичные данные с файлом текста или ХранилищеЗначения - непосредственно содержит  двоичные данные с файлом текста
//  УникальныйИдентификатор - уникальный идентификатор формы
Процедура ОбновитьТекстВФайле(ФайлСсылка, Знач АдресВременногоХранилищаТекста, УникальныйИдентификатор = Неопределено)
	
	ФайлОбъект = ФайлСсылка.ПолучитьОбъект();
	ЗаблокироватьДанныеДляРедактирования(ФайлОбъект.Ссылка, , УникальныйИдентификатор);
	
	Текст = ФайловыеФункции.ПолучитьСтрокуИзВременногоХранилища(АдресВременногоХранилищаТекста);
	ФайлОбъект.ТекстХранилище = Новый ХранилищеЗначения(Текст);
	
	Если ФайлОбъект.ТекущаяВерсия.СтатусРаспознаванияТекста = Перечисления.СтатусыРаспознаванияТекста.НужноРаспознать Тогда
		ФайлОбъект.СтратегияРаспознавания = Перечисления.СтратегииРаспознаванияТекста.ПоместитьТолькоВТекстовыйОбраз;
	КонецЕсли;    
	
	ФайлОбъект.Записать();
	РазблокироватьДанныеДляРедактирования(ФайлОбъект.Ссылка, УникальныйИдентификатор);
	
КонецПроцедуры // ОбновитьТекстВФайле()

// Устанавливает стратегию распознавания
Процедура УстановитьСтратегиюРаспознавания(ФайлСсылка, СтратегияРаспознавания, УникальныйИдентификатор = Неопределено)
	
	ФайлОбъект = ФайлСсылка.ПолучитьОбъект();
	ЗаблокироватьДанныеДляРедактирования(ФайлОбъект.Ссылка, , УникальныйИдентификатор);
	
	ФайлОбъект.СтратегияРаспознавания = СтратегияРаспознавания;
	
	ФайлОбъект.Записать();
	РазблокироватьДанныеДляРедактирования(ФайлОбъект.Ссылка, УникальныйИдентификатор);
	
КонецПроцедуры // ОбновитьТекстВФайле()

// Обновление или создание версии Файла и возврат ссылки на обновленную версию  (или Ложь, если файл бинарно не изменен)
// Параметры
// Файл - СправочникСсылка.Файлы - Файл, в котором обновляется версия
// СоздаватьВерсию  - Булево - создавать новую версию, если Истина (если Ложь - изменяет существующую)
// АдресВременногоХранилищаФайла  - Строка - содержит адрес во временном хранилище, где находятся двоичные данные с файлом или ХранилищеЗначения - непосредственно содержит  двоичные данные с файлом
// Комментарий  - Строка - комментарий к версии
// ВремяИзменения  - Дата - дата и время изменения файла
// ВремяИзмененияУниверсальное  - Дата - UTC дата и время изменения файла
// Размер - размер файла в байтах
// ИмяБезРасширения  - Строка - имя файла без расширения
// Расширение - Строка - расширение файла
// ПолныйПутьКФайлу - полный путь к файлу на клиенте в рабочем каталоге
// АдресВременногоХранилищаТекста - Строка - содержит адрес во временном хранилище, где находятся двоичные данные с файлом текста или ХранилищеЗначения - непосредственно содержит  двоичные данные с файлом текста
// ЭтоВебКлиент - Булево - Истина, если вызов идет из веб клиента
// ТекстНеИзвлеченНаКлиенте - Булево - текст не извлечен на клиенте - т.е. его надо извлекать на сервере
//  УникальныйИдентификатор - уникальный идентификатор формы
// Зашифрован  - Булево - файл зашифрован
// ВерсияСсылка - явно указанная версия, которую надо изменить
// СтатусИзвлеченияТекста - Перечисления.СтатусыИзвлеченияТекстаФайлов - статус извлечения текста
//
// Возвращаемое значение:
//   СправочникСсылка.ВерсииФайлов - созданная/измененная версия
Функция ОбновитьВерсию(
	Файл, 
	СоздаватьВерсию, 
	АдресВременногоХранилищаФайла,
	Комментарий, 
	ВремяИзменения, 
	ВремяИзмененияУниверсальное,
	Размер, 
	ИмяБезРасширения, 
	Расширение, 
	ПолныйПутьКФайлу,
	АдресВременногоХранилищаТекста,
	ЭтоВебКлиент,
	ТекстНеИзвлеченНаКлиенте,
	УникальныйИдентификатор = Неопределено,
	НужноЗановоРаспознатьВерсию = Неопределено,
	Зашифрован = Неопределено,
	ВерсияСсылка = Неопределено,
	СтатусИзвлеченияТекста = Неопределено,
	ДанныеДляВосстановленияФайловВТоме = Неопределено) Экспорт 
	
	Перем СсылкаНаТом;
	ХранилищеФайла = Неопределено;
	
	УстановитьПривилегированныйРежим(Истина);
	
	ЗапретЗагрузкиФайловПоРасширению = ФайловыеФункции.ПолучитьЗапретЗагрузкиФайловПоРасширению();
	СписокЗапрещенныхРасширений = ФайловыеФункции.ПолучитьСписокЗапрещенныхРасширений();
	РасширениеФайла = Расширение;
	Если Не ФайловыеФункцииКлиентСервер.РасширениеФайлаРазрешеноДляЗагрузки(ЗапретЗагрузкиФайловПоРасширению, СписокЗапрещенныхРасширений, РасширениеФайла) Тогда
		ВызватьИсключение
			   СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				 НСтр("ru = 'Загрузка файлов с расширением ""%1"" запрещена. Обратитесь к администратору системы.'"),
				 РасширениеФайла);
	КонецЕсли;	
	
	ЗарегистрироватьИзменениеФайла(Файл);
	
	ТекущаяВерсияРазмер = 0;
	ДвоичныеДанные = Неопределено;
	ТекущаяВерсияТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе;
	ТекущаяВерсияТом = Неопределено;
	ТекущаяВерсияПутьКФайлу = Неопределено;
	
	ВерсияСсылкаДляСравненияРазмера = ВерсияСсылка;
	
	Если ВерсияСсылка <> Неопределено Тогда
		ВерсияСсылкаДляСравненияРазмера = ВерсияСсылка;
	Иначе
		ВерсияСсылкаДляСравненияРазмера = Файл.ТекущаяВерсия;
	КонецЕсли;
	
	КодировкаПредВерсии = ПолучитьКодировкуВерсииФайла(ВерсияСсылкаДляСравненияРазмера);
	
	СтруктураРеквизитов = ОбщегоНазначения.ПолучитьЗначенияРеквизитов(ВерсияСсылкаДляСравненияРазмера, 
		"Размер, ТипХраненияФайла, Том, ПутьКФайлу");
	ТекущаяВерсияРазмер = СтруктураРеквизитов.Размер;
	ТекущаяВерсияТипХраненияФайла = СтруктураРеквизитов.ТипХраненияФайла;
	ТекущаяВерсияТом = СтруктураРеквизитов.Том;
	ТекущаяВерсияПутьКФайлу = СтруктураРеквизитов.ПутьКФайлу;
	
	Если Размер = ТекущаяВерсияРазмер Тогда
		ДвоичныеДанныеПредыдущейВерсии = Неопределено;
		
		Если ТекущаяВерсияТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
			Если НЕ ТекущаяВерсияТом.Пустая() Тогда
				ПолныйПуть = ФайловыеФункцииСлужебный.ПолныйПутьТома(ТекущаяВерсияТом) + ТекущаяВерсияПутьКФайлу; 
				ДвоичныеДанныеПредыдущейВерсии = Новый ДвоичныеДанные(ПолныйПуть);
			КонецЕсли;
		Иначе
			ХранилищеФайла = ПолучитьХранилищеФайлаИзИнформационнойБазы(ВерсияСсылкаДляСравненияРазмера);
			ДвоичныеДанныеПредыдущейВерсии = ХранилищеФайла.Получить();
		КонецЕсли;
		
		ДвоичныеДанные = ПолучитьИзВременногоХранилища(АдресВременногоХранилищаФайла);
		
		Если ДвоичныеДанныеПредыдущейВерсии = ДвоичныеДанные Тогда
			Возврат Ложь; // файл бинарно не изменен - вернем Ложь
		КонецЕсли;
	КонецЕсли;
	
	СтарыйТипХранения = Неопределено;
	ВерсияЗаблокирована = Ложь;
	Версия = Неопределено;

	Если СоздаватьВерсию Тогда
		Версия = Справочники.ВерсииФайлов.СоздатьЭлемент();
		Версия.РодительскаяВерсия = Файл.ТекущаяВерсия;
		Версия.НомерВерсии = НайтиМаксимальныйНомерВерсии(Файл) + 1;
		
		Если Не ЗначениеЗаполнено(Файл.СтратегияРаспознавания) 
			Или Файл.СтратегияРаспознавания = Перечисления.СтратегииРаспознаванияТекста.НеРаспознавать Тогда
			
			Версия.СтатусРаспознаванияТекста = Перечисления.СтатусыРаспознаванияТекста.НеНужноРаспознавать;
			
		Иначе
			
			Версия.СтатусРаспознаванияТекста = Перечисления.СтатусыРаспознаванияТекста.НужноРаспознать;
			
		КонецЕсли;    
			
	Иначе	
		
		Если ВерсияСсылка = Неопределено Тогда
			Версия = Файл.ТекущаяВерсия.ПолучитьОбъект();
		Иначе
			Версия = ВерсияСсылка.ПолучитьОбъект();
		КонецЕсли;
		
		ЗаблокироватьДанныеДляРедактирования(Версия.Ссылка, , УникальныйИдентификатор);
		ВерсияЗаблокирована = Истина;
		
		Если Версия.СтатусРаспознаванияТекста = Перечисления.СтатусыРаспознаванияТекста.Распознано Тогда
			Версия.СтатусРаспознаванияТекста = Перечисления.СтатусыРаспознаванияТекста.НужноРаспознать;
			НужноЗановоРаспознатьВерсию = Истина;
		КонецЕсли;	
		
		// удалим файл с диска - мы заместим его новым
		Если Версия.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
			Если НЕ Версия.Том.Пустая() Тогда
				ПолныйПуть = ФайловыеФункции.ПолныйПутьТома(Версия.Том) + Версия.ПутьКФайлу; 
				Попытка
					ФайлНаДиске = Новый Файл(ПолныйПуть);
					ФайлНаДиске.УстановитьТолькоЧтение(Ложь);
					
					Если ДанныеДляВосстановленияФайловВТоме <> Неопределено Тогда
						
						ВременныйПуть = ПолучитьИмяВременногоФайла(ФайлНаДиске.Расширение);
						
						ПереместитьФайл(ПолныйПуть, ВременныйПуть);
						
						ДанныеВосстановления = Новый Структура("СтарыйПуть, ВременныйПуть", 
							ПолныйПуть, ВременныйПуть);
						ДанныеДляВосстановленияФайловВТоме.Добавить(ДанныеВосстановления);
						
					Иначе	
						
						УдалитьФайлы(ПолныйПуть);
						
						ПутьСПодкаталогом = ФайлНаДиске.Путь;
						МассивФайловВКаталоге = НайтиФайлы(ПутьСПодкаталогом, "*.*");
						Если МассивФайловВКаталоге.Количество() = 0 Тогда
							УдалитьФайлы(ПутьСПодкаталогом);
						КонецЕсли;
						
					КонецЕсли;	
					
				Исключение
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Версия.Владелец = Файл.Ссылка;
	Версия.Автор = Пользователи.ТекущийПользователь();
	Версия.ДатаМодификацииУниверсальная = ВремяИзмененияУниверсальное;
	Версия.ДатаМодификацииФайла = ВремяИзменения;
	Версия.ДатаСоздания = ТекущаяДатаСеанса();
	Версия.Размер = Размер;
	Версия.ПолноеНаименование = ИмяБезРасширения;
	Версия.Комментарий = Комментарий;
	
	Версия.Расширение = ФайловыеФункцииКлиентСервер.РасширениеБезТочки(Расширение);
	
	ТипХраненияФайлов = ФайловыеФункции.ПолучитьТипХраненияФайлов();
	Версия.ТипХраненияФайла = ТипХраненияФайлов;
	
	Если ТипХраненияФайлов = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске И ИспользоватьРазмещениеВТомахПоУсловиям() Тогда
		Версия.Записать(); // чтобы при размещении в томе по условию на руках была ссылка на версию
	КонецЕсли;
	
	Если ДвоичныеДанные = Неопределено Тогда
		ДвоичныеДанные = ПолучитьИзВременногоХранилища(АдресВременногоХранилищаФайла);
	КонецЕсли;	
	
	Если ТипХраненияФайлов = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
		
		ХранилищеФайла = Новый ХранилищеЗначения(
			ПолучитьИзВременногоХранилища(АдресВременногоХранилищаФайла));
		
		Если (ЭтоВебКлиент = Истина) И (Версия.Размер = 0) Тогда
			ДвоичныеДанныеФайла = ХранилищеФайла.Получить();
			Версия.Размер = ДвоичныеДанныеФайла.Размер();
			
			МаксРазмерФайла = ФайловыеФункции.ПолучитьМаксимальныйРазмерФайла();
			РазмерВМб = Версия.Размер / (1024 * 1024);
			РазмерВМбМакс = МаксРазмерФайла / (1024 * 1024);
			
			Если Версия.Размер > МаксРазмерФайла Тогда
				ВызватьИсключение
					   СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						 НСтр("ru = 'Размер файла ""%1"" (%2 Мб) превышает максимально допустимый размер файла (%3 Мб).'"),
						 ИмяБезРасширения, 
						 ФайловыеФункцииКлиентСервер.ПолучитьСтрокуСРазмеромФайла(РазмерВМб), 
						 ФайловыеФункцииКлиентСервер.ПолучитьСтрокуСРазмеромФайла(РазмерВМбМакс));
			КонецЕсли;
			
		КонецЕсли;
			
		// очистим поля
		Версия.ПутьКФайлу = "";
		Версия.Том = Справочники.ТомаХраненияФайлов.ПустаяСсылка();
	Иначе // хранение на диске
		
		ДвоичныеДанные = ПолучитьИзВременногоХранилища(АдресВременногоХранилищаФайла);
		
		Если (ЭтоВебКлиент = Истина) И (Версия.Размер = 0) Тогда
			Версия.Размер = ДвоичныеДанные.Размер();
			
			МаксРазмерФайла = ФайловыеФункции.ПолучитьМаксимальныйРазмерФайла();
			РазмерВМб = Версия.Размер / (1024 * 1024);
			РазмерВМбМакс = МаксРазмерФайла / (1024 * 1024);
			
			Если Версия.Размер > МаксРазмерФайла Тогда
				ВызватьИсключение
					   СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						 НСтр("ru = 'Размер файла ""%1"" (%2 Мб) превышает максимально допустимый размер файла (%3 Мб).'"),
						 ИмяБезРасширения, 
						 ФайловыеФункцииКлиентСервер.ПолучитьСтрокуСРазмеромФайла(РазмерВМб), 
						 ФайловыеФункцииКлиентСервер.ПолучитьСтрокуСРазмеромФайла(РазмерВМбМакс));
			КонецЕсли;
			
		КонецЕсли;
		
		ПутьКФайлу = "";
		
		ФайлЗашифрован = Ложь;
		Если Зашифрован <> Неопределено Тогда
			ФайлЗашифрован = Зашифрован;
		КонецЕсли;	
		
		// добавить в один из томов (где есть свободное место)
		ФайловыеФункции.ДобавитьНаДиск(ДвоичныеДанные, ПутьКФайлу, СсылкаНаТом, ВремяИзмененияУниверсальное, Версия.НомерВерсии, 
			ИмяБезРасширения, Версия.Расширение, Версия.Размер, ФайлЗашифрован, Неопределено, Версия.Ссылка);
		Версия.ПутьКФайлу = ПутьКФайлу;
		Версия.Том = СсылкаНаТом.Ссылка;
		ХранилищеФайла = Новый ХранилищеЗначения(""); // очистим ХранилищеЗначения
	КонецЕсли; // хранение на диске			
	
	Если НЕ ТекстНеИзвлеченНаКлиенте Тогда		
		ИзвлекатьТекстыФайловНаСервере = ФайловыеФункции.ИзвлекатьТекстыФайловНаСервере();
		Если ИзвлекатьТекстыФайловНаСервере = Ложь Тогда
			
			Текст = ФайловыеФункции.ПолучитьСтрокуИзВременногоХранилища(АдресВременногоХранилищаТекста);
			Версия.ИзвлеченныйТекст = Новый ХранилищеЗначения(Текст);
			ФайловыеФункции.СформироватьРеквизитТекстХранилище(Версия);
			
		Иначе
			Версия.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.НеИзвлечен;
		КонецЕсли;
	Иначе		
		Версия.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.НеИзвлечен;
	КонецЕсли;

	Если СтатусИзвлеченияТекста <> Неопределено Тогда
		Версия.СтатусИзвлеченияТекста = СтатусИзвлеченияТекста;
	КонецЕсли;	

	Если (ЭтоВебКлиент = Истина) И (Версия.Размер = 0) Тогда
		ДвоичныеДанныеФайла = ХранилищеФайла.Получить();
		Версия.Размер = ДвоичныеДанныеФайла.Размер();
	КонецЕсли;
	
	Если Зашифрован <> Неопределено Тогда
		Версия.Зашифрован = Зашифрован;
	КонецЕсли;	
	
	Версия.Записать();
	
	Если ТипХраненияФайлов = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
		ЗаписатьФайлВИнформационнуюБазу(Версия.Ссылка, ХранилищеФайла);	
	КонецЕсли;	
	
	Если ВерсияЗаблокирована Тогда
		РазблокироватьДанныеДляРедактирования(Версия.Ссылка, УникальныйИдентификатор);		
	КонецЕсли;
	
	ЗаписатьКодировкуВерсииФайла(Версия.Ссылка, КодировкаПредВерсии);
	
	НавигационнаяСсылкаФайла = ПолучитьНавигационнуюСсылку(Файл);
	ИсторияРаботыПользователя.Добавить(НавигационнаяСсылкаФайла);
	
	ЗаписатьОбращениеКВерсииФайла(Версия.Ссылка);
	
	ПротоколированиеРаботыПользователей.ЗаписатьИзменениеФайла(Версия.Владелец);
	
	Возврат Версия.Ссылка;
	
КонецФункции // ОбновитьВерсию

// Обновляет или создает версию Файла и снимает заем. Возвращает Истина, если создание версии выполнено (и файл бинарно изменен)
// Параметры
// ДанныеФайла  - структура с данными файла
// СоздаватьВерсию  - Булево - создавать новую версию, если Истина (если Ложь - изменяет существующую)
// АдресВременногоХранилищаФайла  - Строка - содержит адрес во временном хранилище, где находятся двоичные данные с файлом или ХранилищеЗначения - непосредственно содержит  двоичные данные с файлом
// Комментарий  - Строка - комментарий к версии
// ВремяИзменения  - Дата - дата и время изменения файла
// ВремяИзмененияУниверсальное  - Дата - UTC дата и время изменения файла
// Размер - размер файла в байтах
// ИмяБезРасширения  - Строка - имя файла без расширения
// Расширение - Строка - расширение файла
// ПолныйПутьКФайлу - полный путь к файлу на клиенте в рабочем каталоге
// АдресВременногоХранилищаТекста - Строка - содержит адрес во временном хранилище, где находятся двоичные данные с файлом текста или ХранилищеЗначения - непосредственно содержит  двоичные данные с файлом текста
// ЭтоВебКлиент - Булево - Истина, если вызов идет из веб клиента
// ТекстНеИзвлеченНаКлиенте - Булево - текст не извлечен на клиенте - т.е. его надо извлекать на сервере
// ВРабочемКаталогеВладельца - Булево - файл находится в рабочем каталоге владельца
// НеМенятьЗаписьВРабочемКаталоге - Булево - не менять запись в регистре сведений ФайлыВРабочемКаталоге 
//  УникальныйИдентификатор - уникальный идентификатор формы
//
// Возвращаемое значение:
//   Булево  - успешно ли выполнена операция
Функция ОпубликоватьИОсвободитьФайл(
	ДанныеФайла, 
	СоздаватьВерсию, 
	АдресВременногоХранилищаФайла, 
	Комментарий, 
	ВремяИзменения,
	ВремяИзмененияУниверсальное,
	Размер, 
	ИмяБезРасширения, 
	Расширение, 
	ПолныйПутьКФайлу,
	АдресВременногоХранилищаТекста,
	ЭтоВебКлиент,
	ТекстНеИзвлеченНаКлиенте,
	ВРабочемКаталогеВладельца,
	НеМенятьЗаписьВРабочемКаталоге,
	УникальныйИдентификатор = Неопределено,
	ПараметрыАвтозапускаБизнесПроцессов = Неопределено,
	Кодировка = Неопределено) Экспорт
	
	ДанныеФайлаТекущие = ПолучитьДанныеФайла(ДанныеФайла.Ссылка);
	Если Не ДанныеФайлаТекущие.РедактируетТекущийПользователь Тогда
		ВызватьИсключение НСтр("ru = 'Файл не занят текущим пользователем'");
	КонецЕсли;    
	
	ВерсияНеСоздана = Ложь;
	ДанныеДляВосстановленияФайловВТоме = Новый Массив;
	
	НачатьТранзакцию();
	Попытка
		
		// в самом начале блокируем файл, чтобы не делать обновление версии, если файл заблокирован.
		ЗаблокироватьДанныеДляРедактирования(ДанныеФайла.Ссылка, , УникальныйИдентификатор);
		
		ПредыдущаяВерсия = ДанныеФайла.ТекущаяВерсия;
		НужноЗановоРаспознатьВерсию = Ложь;
		
		КодВозвратаОбновитьВерсию = ОбновитьВерсию(
			ДанныеФайла.Ссылка, 
			СоздаватьВерсию, 
			АдресВременногоХранилищаФайла, 
			Комментарий, 
			ВремяИзменения, 
			ВремяИзмененияУниверсальное,
			Размер, 
			ИмяБезРасширения, 
			Расширение, 
			ПолныйПутьКФайлу,
			АдресВременногоХранилищаТекста,
			ЭтоВебКлиент,
			ТекстНеИзвлеченНаКлиенте,
			УникальныйИдентификатор,
			НужноЗановоРаспознатьВерсию,
			ДанныеФайлаТекущие.Зашифрован,,,
			ДанныеДляВосстановленияФайловВТоме);

		НоваяВерсия	= Неопределено;
		Если ТипЗнч(КодВозвратаОбновитьВерсию) = Тип("Булево") Тогда
			ВерсияНеСоздана = Истина;
		Иначе	
			НоваяВерсия = КодВозвратаОбновитьВерсию;
		КонецЕсли;	
		
		Если Не ВерсияНеСоздана Тогда
			Если СоздаватьВерсию Тогда
				ОбновитьВерсиюВФайле(ДанныеФайла.Ссылка, НоваяВерсия, АдресВременногоХранилищаТекста, УникальныйИдентификатор);
			Иначе
				Если НужноЗановоРаспознатьВерсию = Истина Тогда
					УстановитьСтратегиюРаспознавания(ДанныеФайла.Ссылка, Перечисления.СтратегииРаспознаванияТекста.ПоместитьТолькоВТекстовыйОбраз, УникальныйИдентификатор);
				Иначе
					ОбновитьТекстВФайле(ДанныеФайла.Ссылка, АдресВременногоХранилищаТекста, УникальныйИдентификатор);
				КонецЕсли;	
			КонецЕсли;
			ДанныеФайла.ТекущаяВерсия = НоваяВерсия;
		КонецЕсли;		
		
		ОсвободитьФайл(ДанныеФайла, УникальныйИдентификатор);
		
		Если Кодировка <> Неопределено Тогда
			Если Не ЗначениеЗаполнено(ПолучитьКодировкуВерсииФайла(ДанныеФайла.ТекущаяВерсия)) Тогда
				ЗаписатьКодировкуВерсииФайла(ДанныеФайла.ТекущаяВерсия, Кодировка);
			КонецЕсли;	
		КонецЕсли;	
		
		Если НЕ ЭтоВебКлиент И Не НеМенятьЗаписьВРабочемКаталоге Тогда
			
			Если ВерсияНеСоздана Тогда
				НоваяВерсия = ПредыдущаяВерсия;
			КонецЕсли;	
			
			ИмяКаталога = ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить("ЛокальныйКэшФайлов", "ПутьКЛокальномуКэшуФайлов");
			УдалитьВерсиюИЗанестиИнформациюФайлаВРегистр(
				ПредыдущаяВерсия, 
				НоваяВерсия, 
				ПолныйПутьКФайлу, 
				ИмяКаталога,
				ДанныеФайла.РабочийКаталогВладельца <> "");
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
		РазблокироватьДанныеДляРедактирования(ДанныеФайла.Ссылка, УникальныйИдентификатор);
		
		// после успешного завершения удаляем временные файлы и каталог, если он пуст
		ЗафиксироватьТранзакциюДляФайловВТоме(ДанныеДляВосстановленияФайловВТоме);	
		
	Исключение
	     ОтменитьТранзакцию();
		 ОтменитьТранзакциюДляФайловВТоме(ДанныеДляВосстановленияФайловВТоме);
	     ВызватьИсключение;
	КонецПопытки;
	 
	Возврат (Не ВерсияНеСоздана);

КонецФункции // ОпубликоватьИОсвободитьФайл()

// Получает данные файла, затем обновляет или создает версию Файла и снимает заем
// Нужно для случаев, когда на клиенте нет ДанныеФайла (из соображений экономии вызовов клиент-сервер)
// Возвращает Истина, если создание версии выполнено (и файл бинарно изменен)
// Параметры
// ОбъектСсылка - СправочникСсылка.Файлы - Файл, в котором обновляется версия
// ДанныеФайла  - структура с данными файла
// СоздаватьВерсию  - Булево - создавать новую версию, если Истина (если Ложь - изменяет существующую)
// АдресВременногоХранилищаФайла  - Строка - содержит адрес во временном хранилище, где находятся двоичные данные с файлом или ХранилищеЗначения - непосредственно содержит  двоичные данные с файлом
// Комментарий  - Строка - комментарий к версии
// ВремяИзменения  - Дата - дата и время изменения файла
// ВремяИзмененияУниверсальное  - Дата - UTC дата и время изменения файла
// Размер - размер файла в байтах
// ИмяБезРасширения  - Строка - имя файла без расширения
// Расширение - Строка - расширение файла
// ПолныйПутьКФайлу - полный путь к файлу на клиенте в рабочем каталоге
// АдресВременногоХранилищаТекста - Строка - содержит адрес во временном хранилище, где находятся двоичные данные с файлом текста или ХранилищеЗначения - непосредственно содержит  двоичные данные с файлом текста
// ЭтоВебКлиент - Булево - Истина, если вызов идет из веб клиента
// ТекстНеИзвлеченНаКлиенте - Булево - текст не извлечен на клиенте - т.е. его надо извлекать на сервере
// УникальныйИдентификатор - уникальный идентификатор формы
//
// Возвращаемое значение:
//   Булево  - успешно ли выполнена операция
Функция ПолучитьДанныеФайлаИОпубликоватьИОсвободитьФайл(
	ОбъектСсылка, 
	ДанныеФайла,
	СоздаватьВерсию, 
	АдресВременногоХранилищаФайла, 
	Комментарий, 
	ВремяИзменения, 
	ВремяИзмененияУниверсальное,
	Размер, 
	ИмяБезРасширения, 
	Расширение, 
	ПолныйПутьКФайлу,
	АдресВременногоХранилищаТекста,
	ЭтоВебКлиент,
	ТекстНеИзвлеченНаКлиенте,
	УникальныйИдентификатор = Неопределено,
	ПараметрыАвтозапускаБизнесПроцессов = Неопределено) Экспорт

	ДанныеФайла = ПолучитьДанныеФайла(ОбъектСсылка);
	
	Если Не ДанныеФайла.РедактируетТекущийПользователь Тогда
		ВызватьИсключение НСтр("ru = 'Файл не занят текущим пользователем'");
	КонецЕсли;    
	
	ВерсияНеСоздана = Ложь;
	ДанныеДляВосстановленияФайловВТоме = Новый Массив;
	
	НачатьТранзакцию();
	Попытка
	
		ПредыдущаяВерсия = ДанныеФайла.ТекущаяВерсия;
		НужноЗановоРаспознатьВерсию = Ложь;
		
		КодВозвратаОбновитьВерсию = ОбновитьВерсию(
			ДанныеФайла.Ссылка, 
			СоздаватьВерсию, 
			АдресВременногоХранилищаФайла, 
			Комментарий, 
			ВремяИзменения, 
			ВремяИзмененияУниверсальное,
			Размер, 
			ИмяБезРасширения, 
			Расширение, 
			ПолныйПутьКФайлу,
			АдресВременногоХранилищаТекста,
			ЭтоВебКлиент,
			ТекстНеИзвлеченНаКлиенте,
			УникальныйИдентификатор,
			НужноЗановоРаспознатьВерсию,
			ДанныеФайла.Зашифрован,,,
			ДанныеДляВосстановленияФайловВТоме);

		НоваяВерсия	= Неопределено;
		Если ТипЗнч(КодВозвратаОбновитьВерсию) = Тип("Булево") Тогда
			ВерсияНеСоздана = Истина;
		Иначе	
			НоваяВерсия = КодВозвратаОбновитьВерсию;
		КонецЕсли;	
		
		Если Не ВерсияНеСоздана Тогда
			Если СоздаватьВерсию Тогда
				ОбновитьВерсиюВФайле(ДанныеФайла.Ссылка, НоваяВерсия, АдресВременногоХранилищаТекста, УникальныйИдентификатор);
			Иначе
				Если НужноЗановоРаспознатьВерсию = Истина Тогда
					УстановитьСтратегиюРаспознавания(ДанныеФайла.Ссылка, Перечисления.СтратегииРаспознаванияТекста.ПоместитьТолькоВТекстовыйОбраз, УникальныйИдентификатор);
				Иначе
					ОбновитьТекстВФайле(ДанныеФайла.Ссылка, АдресВременногоХранилищаТекста, УникальныйИдентификатор);
				КонецЕсли;	
			КонецЕсли;
		КонецЕсли;
		
		ДанныеФайла.ТекущаяВерсия = НоваяВерсия;
		
		ОсвободитьФайл(ДанныеФайла, УникальныйИдентификатор);
		
		Если НЕ ЭтоВебКлиент Тогда
			
			Если ВерсияНеСоздана Тогда
				НоваяВерсия = ПредыдущаяВерсия;
			КонецЕсли;	
			
			ИмяКаталога = ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить("ЛокальныйКэшФайлов", "ПутьКЛокальномуКэшуФайлов");
			УдалитьВерсиюИЗанестиИнформациюФайлаВРегистр(
				ПредыдущаяВерсия, 
				НоваяВерсия, 
				ПолныйПутьКФайлу, 
				ИмяКаталога,
				ДанныеФайла.РабочийКаталогВладельца <> "");
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
		
		// после успешного завершения удаляем временные файлы и каталог, если он пуст
		ЗафиксироватьТранзакциюДляФайловВТоме(ДанныеДляВосстановленияФайловВТоме);	
		
	Исключение
	     ОтменитьТранзакцию();
		 ОтменитьТранзакциюДляФайловВТоме(ДанныеДляВосстановленияФайловВТоме);
	     ВызватьИсключение;
	КонецПопытки;
	 
	Возврат (Не ВерсияНеСоздана); 
	
КонецФункции // ПолучитьДанныеФайлаИОпубликоватьИОсвободитьФайл()

// Предназначена для опубликования файла без его освобождения. Возвращает Истина, если создание версии выполнено (и файл бинарно изменен)
// Параметры
// Файл - СправочникСсылка.Файлы - Файл, в котором обновляется версия
// СоздаватьВерсию  - Булево - создавать новую версию, если Истина (если Ложь - изменяет существующую)
// АдресВременногоХранилищаФайла  - Строка - содержит адрес во временном хранилище, где находятся двоичные данные с файлом или ХранилищеЗначения - непосредственно содержит  двоичные данные с файлом
// Комментарий  - Строка - комментарий к версии
// ВремяИзменения  - Дата - дата и время изменения файла
// ВремяИзмененияУниверсальное  - Дата - UTC дата и время изменения файла
// Размер - размер файла в байтах
// ИмяБезРасширения  - Строка - имя файла без расширения
// Расширение - Строка - расширение файла
// ОтносительныйПутьКФайлу - Строка - относительный путь к файлу - не содержащий пути рабочего каталога, например "А1/Приказ.doc"
// ПолныйПутьКФайлу - полный путь к файлу на клиенте в рабочем каталоге
// АдресВременногоХранилищаТекста - Строка - содержит адрес во временном хранилище, где находятся двоичные данные с файлом текста или ХранилищеЗначения - непосредственно содержит  двоичные данные с файлом текста
// ЭтоВебКлиент - Булево - Истина, если вызов идет из веб клиента
// ТекстНеИзвлеченНаКлиенте - Булево - текст не извлечен на клиенте - т.е. его надо извлекать на сервере
// ВРабочемКаталогеВладельца - Булево - файл находится в рабочем каталоге владельца
// НеМенятьЗаписьВРабочемКаталоге - Булево - не менять запись в регистре сведений ФайлыВРабочемКаталоге 
// УникальныйИдентификатор - уникальный идентификатор формы
//
// Возвращаемое значение:
//   Булево  - успешно ли выполнена операция
Функция ОпубликоватьФайл(
	Файл, 
	СоздаватьВерсию, 
	АдресВременногоХранилищаФайла, 
	Комментарий, 
	ВремяИзменения,
	ВремяИзмененияУниверсальное,
	Размер, 
	ИмяБезРасширения, 
	Расширение, 
	ОтносительныйПутьКФайлу, 
	ПолныйПутьКФайлу,
	АдресВременногоХранилищаТекста,
	ЭтоВебКлиент,
	ТекстНеИзвлеченНаКлиенте,
	ВРабочемКаталогеВладельца,
	НеМенятьЗаписьВРабочемКаталоге,
	УникальныйИдентификатор = Неопределено,
	Кодировка = Неопределено) Экспорт
	
	ДанныеФайлаТекущие = ПолучитьДанныеФайла(Файл);
	Если Не ДанныеФайлаТекущие.РедактируетТекущийПользователь Тогда
		ВызватьИсключение НСтр("ru = 'Файл не занят текущим пользователем'");
	КонецЕсли;	
	
	ВерсияНеСоздана = Ложь;
	ТекущаяВерсия = ДанныеФайлаТекущие.ТекущаяВерсия;
	ДанныеДляВосстановленияФайловВТоме = Новый Массив;
	
	НачатьТранзакцию();
	Попытка
	
		СтараяВерсия = Файл.ТекущаяВерсия;
		НужноЗановоРаспознатьВерсию = Ложь;
		
		КодВозвратаОбновитьВерсию = ОбновитьВерсию(
			Файл, 
			СоздаватьВерсию, 
			АдресВременногоХранилищаФайла, 
			Комментарий, 
			ВремяИзменения, 
			ВремяИзмененияУниверсальное,
			Размер, 
			ИмяБезРасширения, 
			Расширение, 
			ПолныйПутьКФайлу,
			АдресВременногоХранилищаТекста,
			ЭтоВебКлиент,
			ТекстНеИзвлеченНаКлиенте,
			УникальныйИдентификатор,
			НужноЗановоРаспознатьВерсию,
			ДанныеФайлаТекущие.Зашифрован,,,
			ДанныеДляВосстановленияФайловВТоме);

		НоваяВерсия	= Неопределено;
		Если ТипЗнч(КодВозвратаОбновитьВерсию) = Тип("Булево") Тогда
			ВерсияНеСоздана = Истина;
		Иначе	
			НоваяВерсия = КодВозвратаОбновитьВерсию;
			ТекущаяВерсия = НоваяВерсия;
		КонецЕсли;	
		
		Если Не ВерсияНеСоздана Тогда
			Если СоздаватьВерсию Тогда
				ОбновитьВерсиюВФайле(Файл, НоваяВерсия, АдресВременногоХранилищаТекста, УникальныйИдентификатор);
			Иначе
				Если НужноЗановоРаспознатьВерсию = Истина Тогда
					УстановитьСтратегиюРаспознавания(Файл, Перечисления.СтратегииРаспознаванияТекста.ПоместитьТолькоВТекстовыйОбраз, УникальныйИдентификатор);
				Иначе
					ОбновитьТекстВФайле(Файл, АдресВременногоХранилищаТекста, УникальныйИдентификатор);
				КонецЕсли;	
			КонецЕсли;
			
			Если НЕ ЭтоВебКлиент И Не НеМенятьЗаписьВРабочемКаталоге Тогда
				УдалитьИзРегистра(СтараяВерсия);
				НаЧтение = Ложь; 
				ЗаписатьИмяФайлаСПутемВРегистр(НоваяВерсия, ОтносительныйПутьКФайлу, НаЧтение, ВРабочемКаталогеВладельца);
			КонецЕсли;
		КонецЕсли;
		
		Если Кодировка <> Неопределено Тогда
			Если Не ЗначениеЗаполнено(ПолучитьКодировкуВерсииФайла(ТекущаяВерсия)) Тогда
				ЗаписатьКодировкуВерсииФайла(ТекущаяВерсия, Кодировка);
			КонецЕсли;		
		КонецЕсли;	
		
		ЗафиксироватьТранзакцию();
		
		// после успешного завершения удаляем временные файлы и каталог, если он пуст
		ЗафиксироватьТранзакциюДляФайловВТоме(ДанныеДляВосстановленияФайловВТоме);	
		
	Исключение
	     ОтменитьТранзакцию();
		 ОтменитьТранзакциюДляФайловВТоме(ДанныеДляВосстановленияФайловВТоме);
	     ВызватьИсключение;
	КонецПопытки;
	 
	Возврат (Не ВерсияНеСоздана);
	
КонецФункции // ОпубликоватьФайл()

// получает РедактируетТекущийПользователь - в привилегированном режиме
Функция ПолучитьРедактируетТекущийПользователь(ВерсияСсылка) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = "ВЫБРАТЬ
	               |	Файлы.Редактирует КАК Редактирует
	               |ИЗ
	               |	Справочник.Файлы КАК Файлы
	               |		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ВерсииФайлов КАК ВерсииФайлов
	               |		ПО (ИСТИНА)
	               |ГДЕ
	               |	ВерсииФайлов.Ссылка = &Версия
	               |	И Файлы.Ссылка = ВерсииФайлов.Владелец";
				   
	Запрос.Параметры.Вставить("Версия", ВерсияСсылка);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		РедактируетТекущийПользователь = (Выборка.Редактирует = Пользователи.ТекущийПользователь());
		Возврат РедактируетТекущийПользователь;
	КонецЕсли;
	
	Возврат Ложь;
КонецФункции    

// Функция возвращает структуру, содержащую различные сведения о Файле и версии
// Параметры
//  ФайлСсылка  - СправочникСсылка.Файлы - файл
//  ВерсияСсылка  - СправочникСсылка.ВерсииФайлов - версия файла
//
// Возвращаемое значение:
//   Структура - структура с данными файла
Функция ПолучитьДанныеФайла(ФайлСсылка, ВерсияСсылка = Неопределено) Экспорт
	
	Запрос = Новый Запрос;

	Если ВерсияСсылка = Справочники.ВерсииФайлов.ПустаяСсылка() Тогда
		ВерсияСсылка = Неопределено;
	КонецЕсли;
	
	Если ВерсияСсылка = Неопределено Тогда
		
		Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
		               |	Файлы.Ссылка КАК Ссылка,
		               |	Файлы.Код КАК Код,
		               |	Файлы.Редактирует КАК Редактирует,
		               |	Файлы.ТекущаяВерсия КАК ТекущаяВерсия,
		               |	Файлы.ВладелецФайла КАК ВладелецФайла,
		               |	Файлы.ХранитьВерсии КАК ХранитьВерсии,
		               |	Файлы.ПометкаУдаления КАК ПометкаУдаления,
		               |	ВерсииФайлов.ПолноеНаименование КАК ПолноеНаименование,
		               |	ВерсииФайлов.Расширение КАК Расширение,
		               |	ВерсииФайлов.Размер КАК Размер,
		               |	ВерсииФайлов.НомерВерсии КАК НомерВерсии,
		               |	ВерсииФайлов.ПутьКФайлу КАК ПутьКФайлу,
		               |	ВерсииФайлов.Том КАК Том,
		               |	ВерсииФайлов.ДатаМодификацииУниверсальная КАК ДатаМодификацииУниверсальная,
		               |	ВерсииФайлов.Автор КАК Автор,
		               |	ВерсииФайлов.СтатусИзвлеченияТекста КАК СтатусИзвлеченияТекста,
		               |	ВерсииФайлов.СтатусРаспознаванияТекста КАК СтатусРаспознаванияТекста,
		               |	Файлы.Зашифрован КАК Зашифрован,
		               |	ВерсииФайлов.ТипХраненияФайла КАК ТипХраненияФайла,
		               |	Файлы.ДатаЗаема КАК ДатаЗаема
		               |ИЗ
		               |	Справочник.Файлы КАК Файлы
		               |		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ВерсииФайлов КАК ВерсииФайлов
		               |		ПО Файлы.ТекущаяВерсия = ВерсииФайлов.Ссылка";
		
		Если ТипЗнч(ФайлСсылка) = Тип("Массив") Тогда 
			Запрос.Текст = Запрос.Текст + " ГДЕ Файлы.Ссылка В (&Файл) ";
		Иначе
			Запрос.Текст = Запрос.Текст + " ГДЕ Файлы.Ссылка = &Файл ";
		КонецЕсли;
		
		Запрос.Параметры.Вставить("Файл", ФайлСсылка);
		
	Иначе
		
		Если ФайлСсылка <> Неопределено Тогда 
			Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
			               |	Файлы.Ссылка КАК Ссылка,
			               |	Файлы.Код КАК Код,
			               |	Файлы.Редактирует КАК Редактирует,
			               |	Файлы.ТекущаяВерсия КАК ТекущаяВерсия,
			               |	Файлы.ВладелецФайла КАК ВладелецФайла,
			               |	Файлы.ХранитьВерсии КАК ХранитьВерсии,
			               |	Файлы.ПометкаУдаления КАК ПометкаУдаления,
			               |	ВерсииФайлов.ПолноеНаименование КАК ПолноеНаименование,
			               |	ВерсииФайлов.Расширение КАК Расширение,
			               |	ВерсииФайлов.Размер КАК Размер,
			               |	ВерсииФайлов.НомерВерсии КАК НомерВерсии,
			               |	ВерсииФайлов.ПутьКФайлу КАК ПутьКФайлу,
			               |	ВерсииФайлов.Том КАК Том,
			               |	ВерсииФайлов.ДатаМодификацииУниверсальная КАК ДатаМодификацииУниверсальная,
			               |	ВерсииФайлов.Автор КАК Автор,
			               |	ВерсииФайлов.СтатусИзвлеченияТекста КАК СтатусИзвлеченияТекста,
			               |	ВерсииФайлов.СтатусРаспознаванияТекста КАК СтатусРаспознаванияТекста,
			               |	Файлы.Зашифрован КАК Зашифрован,
			               |	ВерсииФайлов.ТипХраненияФайла КАК ТипХраненияФайла,
						   |	Файлы.ДатаЗаема КАК ДатаЗаема
			               |ИЗ
			               |	Справочник.Файлы КАК Файлы
			               |		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ВерсииФайлов КАК ВерсииФайлов
			               |		ПО (ИСТИНА)
			               |ГДЕ
			               |	Файлы.Ссылка = &Файл
			               |	И ВерсииФайлов.Ссылка = &Версия";
			
			Запрос.Параметры.Вставить("Файл", ФайлСсылка);
			Запрос.Параметры.Вставить("Версия", ВерсияСсылка);
		Иначе
			Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
			               |	Файлы.Ссылка КАК Ссылка,
			               |	Файлы.Код КАК Код,
			               |	Файлы.Редактирует КАК Редактирует,
			               |	Файлы.ТекущаяВерсия КАК ТекущаяВерсия,
			               |	Файлы.ВладелецФайла КАК ВладелецФайла,
			               |	Файлы.ХранитьВерсии КАК ХранитьВерсии,
			               |	Файлы.ПометкаУдаления КАК ПометкаУдаления,
			               |	ВерсииФайлов.ПолноеНаименование КАК ПолноеНаименование,
			               |	ВерсииФайлов.Расширение КАК Расширение,
			               |	ВерсииФайлов.Размер КАК Размер,
			               |	ВерсииФайлов.НомерВерсии КАК НомерВерсии,
			               |	ВерсииФайлов.ПутьКФайлу КАК ПутьКФайлу,
			               |	ВерсииФайлов.Том КАК Том,
			               |	ВерсииФайлов.ДатаМодификацииУниверсальная КАК ДатаМодификацииУниверсальная,
			               |	ВерсииФайлов.Автор КАК Автор,
			               |	ВерсииФайлов.СтатусИзвлеченияТекста КАК СтатусИзвлеченияТекста,
			               |	ВерсииФайлов.СтатусРаспознаванияТекста КАК СтатусРаспознаванияТекста,
			               |	Файлы.Зашифрован КАК Зашифрован,
			               |	ВерсииФайлов.ТипХраненияФайла КАК ТипХраненияФайла,
						   |	Файлы.ДатаЗаема КАК ДатаЗаема
			               |ИЗ
			               |	Справочник.Файлы КАК Файлы
			               |		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ВерсииФайлов КАК ВерсииФайлов
			               |		ПО (ИСТИНА)
			               |ГДЕ
			               |	ВерсииФайлов.Ссылка = &Версия
			               |	И Файлы.Ссылка = ВерсииФайлов.Владелец";
						   
			Запрос.Параметры.Вставить("Версия", ВерсияСсылка);
		КонецЕсли;    
		
	КонецЕсли;    
	
	МассивДанныеФайла = Новый Массив;
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
	
		ДанныеФайла = Новый Структура;
		ДанныеФайла.Вставить("Ссылка", Выборка.Ссылка);
		ДанныеФайла.Вставить("КодФайла", Выборка.Код);
		ДанныеФайла.Вставить("Редактирует", Выборка.Редактирует);
		ДанныеФайла.Вставить("Владелец", Выборка.ВладелецФайла);
		ДанныеФайла.Вставить("НавигационнаяСсылка", ПолучитьНавигационнуюСсылку(Выборка.Ссылка));
		
		Если ВерсияСсылка <> Неопределено Тогда
			ДанныеФайла.Вставить("Версия", ВерсияСсылка);
		Иначе
			ДанныеФайла.Вставить("Версия", Выборка.ТекущаяВерсия);
		КонецЕсли;    

		ДанныеФайла.Вставить("ТекущаяВерсия", Выборка.ТекущаяВерсия);
		
		СтруктураКлюча = Новый Структура("ВерсияФайла", ДанныеФайла.ТекущаяВерсия);
		КлючЗаписи = РегистрыСведений.ХранимыеФайлыВерсий.СоздатьКлючЗаписи(СтруктураКлюча);
		НавигационнаяСсылкаТекущейВерсии = ПолучитьНавигационнуюСсылку(КлючЗаписи, "ХранимыйФайл");
		ДанныеФайла.Вставить("НавигационнаяСсылкаТекущейВерсии", НавигационнаяСсылкаТекущейВерсии);
		
        КодировкаТекущейВерсии = ПолучитьКодировкуВерсииФайла(ДанныеФайла.ТекущаяВерсия);
        ДанныеФайла.Вставить("КодировкаТекущейВерсии", КодировкаТекущейВерсии);
		
		ДанныеФайла.Вставить("Размер", Выборка.Размер);
		ДанныеФайла.Вставить("НомерВерсии", Выборка.НомерВерсии);
		ДанныеФайла.Вставить("ДатаМодификацииУниверсальная", Выборка.ДатаМодификацииУниверсальная);
		ДанныеФайла.Вставить("Расширение", Выборка.Расширение);
		ДанныеФайла.Вставить("ПолноеНаименованиеВерсии", СокрЛП(Выборка.ПолноеНаименование));
		ДанныеФайла.Вставить("ХранитьВерсии", Выборка.ХранитьВерсии);
		ДанныеФайла.Вставить("ПометкаУдаления", Выборка.ПометкаУдаления);
		ДанныеФайла.Вставить("АвторТекущейВерсии", Выборка.Автор);
		ДанныеФайла.Вставить("Зашифрован", Выборка.Зашифрован);
		ДанныеФайла.Вставить("ДатаЗаема", Выборка.ДатаЗаема);
		
		ДанныеФайла.Вставить("ПутьКФайлу", Выборка.ПутьКФайлу);
		ДанныеФайла.Вставить("Том", Выборка.Том);	   
		ДанныеФайла.Вставить("ТипХраненияФайла", Выборка.ТипХраненияФайла);	   
		
		Если ДанныеФайла.Зашифрован Тогда
			МассивСертификатовШифрования = ПолучитьМассивСертификатовШифрования(ДанныеФайла.Ссылка);
			ДанныеФайла.Вставить("МассивСертификатовШифрования", МассивСертификатовШифрования);
		КонецЕсли;	
		
		НаЧтение = ДанныеФайла.Редактирует <> Пользователи.ТекущийПользователь();
		ДанныеФайла.Вставить("НаЧтение", НаЧтение);
		
		ВРабочемКаталогеНаЧтение = Истина;
		ВРабочемКаталогеВладельца = Ложь;
		ИмяКаталога = ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить("ЛокальныйКэшФайлов", "ПутьКЛокальномуКэшуФайлов");
		Если ИмяКаталога = Неопределено Тогда
			ИмяКаталога = "";
		КонецЕсли;	

		Если ВерсияСсылка <> Неопределено Тогда
			ИмяФайлаСПутемВРабочемКаталоге = ПолучитьИмяФайлаСПутемИзРегистра(ВерсияСсылка, ИмяКаталога, ВРабочемКаталогеНаЧтение, ВРабочемКаталогеВладельца);
		Иначе
			ИмяФайлаСПутемВРабочемКаталоге = ПолучитьИмяФайлаСПутемИзРегистра(Выборка.ТекущаяВерсия, ИмяКаталога, ВРабочемКаталогеНаЧтение, ВРабочемКаталогеВладельца);
		КонецЕсли;	

		ДанныеФайла.Вставить("ПолноеИмяФайлаВРабочемКаталоге", ИмяФайлаСПутемВРабочемКаталоге);
		ДанныеФайла.Вставить("ВРабочемКаталогеНаЧтение", ВРабочемКаталогеНаЧтение);
		ДанныеФайла.Вставить("РабочийКаталогВладельца", "");
		
		РедактируетТекущийПользователь = (ДанныеФайла.Редактирует = Пользователи.ТекущийПользователь());
		ДанныеФайла.Вставить("РедактируетТекущийПользователь", РедактируетТекущийПользователь);
		
		СтатусИзвлеченияТекстаСтрока = "НеИзвлечен";
		Если Выборка.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.НеИзвлечен Тогда
			СтатусИзвлеченияТекстаСтрока = "НеИзвлечен";
		ИначеЕсли Выборка.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.Извлечен Тогда
			СтатусИзвлеченияТекстаСтрока = "Извлечен";
		ИначеЕсли Выборка.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.ИзвлечьНеУдалось Тогда
			СтатусИзвлеченияТекстаСтрока = "ИзвлечьНеУдалось";
		КонецЕсли;	
		ДанныеФайла.Вставить("СтатусИзвлеченияТекста", СтатусИзвлеченияТекстаСтрока);
		
		СтатусРаспознаванияТекстаСтрока = "НеНужноРаспознавать";
		Если Выборка.СтатусРаспознаванияТекста = Перечисления.СтатусыРаспознаванияТекста.НеРаспознано Тогда
			СтатусРаспознаванияТекстаСтрока = "НеРаспознано";
		ИначеЕсли Выборка.СтатусРаспознаванияТекста = Перечисления.СтатусыРаспознаванияТекста.НужноРаспознать Тогда
			СтатусРаспознаванияТекстаСтрока = "НужноРаспознать";
		ИначеЕсли Выборка.СтатусРаспознаванияТекста = Перечисления.СтатусыРаспознаванияТекста.Распознано Тогда
			СтатусРаспознаванияТекстаСтрока = "Распознано";
		ИначеЕсли Выборка.СтатусРаспознаванияТекста = Перечисления.СтатусыРаспознаванияТекста.НеНужноРаспознавать Тогда
			СтатусРаспознаванияТекстаСтрока = "НеНужноРаспознавать";
		КонецЕсли;	
		ДанныеФайла.Вставить("СтатусРаспознаванияТекста", СтатусРаспознаванияТекстаСтрока);
		
		МассивДанныеФайла.Добавить(ДанныеФайла); 
		
	КонецЦикла;
	
	// если был передан массив - возвращаем массив
	Если ТипЗнч(ФайлСсылка) = Тип("Массив") Тогда 
		Возврат МассивДанныеФайла;
	КонецЕсли;

	Если МассивДанныеФайла.Количество() > 0 Тогда 
		Возврат МассивДанныеФайла[0];
	Иначе
		ВызватьИсключение НСтр("ru='У пользователя недостаточно прав на исполнение операции над базой данных.'");
	КонецЕсли;
	
КонецФункции

// Создает карточку Файла в БД вместе с версией
// Параметры
// Владелец - владелец файла - будет установлен в реквизит ВладелецФайла у созданного файла
// ИмяБезРасширения  - Строка - имя файла без расширения
// РасширениеБезТочки - Строка - расширение файла
// ВремяИзменения  - Дата - дата и время изменения файла
// ВремяИзмененияУниверсальное  - Дата - UTC дата и время изменения файла
// Размер - размер файла в байтах
// АдресВременногоХранилищаФайла  - Строка - содержит адрес во временном хранилище, где находятся двоичные данные с файлом или ХранилищеЗначения - непосредственно содержит  двоичные данные с файлом
// АдресВременногоХранилищаТекста - Строка - содержит адрес во временном хранилище, где находятся двоичные данные с файлом текста или ХранилищеЗначения - непосредственно содержит  двоичные данные с файлом текста
// ЭтоВебКлиент - Булево - Истина, если вызов идет из веб клиента
// Пользователь - СправочникСсылка.Пользователи - ссылка на пользователя - автора файла
// Комментарий  - Строка - комментарий к файлу
//
// Возвращаемое значение:
//    СправочникСсылка.Файлы - созданный файл
Функция СоздатьФайлСВерсией(
	ВладелецФайла,
	ИмяБезРасширения,
	РасширениеБезТочки,
	ВремяИзменения,
	ВремяИзмененияУниверсальное,
	Размер,
	АдресВременногоХранилищаФайла,
	АдресВременногоХранилищаТекста,
	ЭтоВебКлиент,
	Пользователь = Неопределено,
	Комментарий = "",
	ПараметрыРаспознавания = Неопределено,
	ХранитьВерсии = Истина,
	ЗаписатьВИсторию = Ложь,
	СписокКатегорий = Неопределено,
	НеобходимоВыполнитьВставкуШКНаКлиенте = Ложь,
	ДополнительныеПараметры = Неопределено,
	Кодировка = Неопределено,
	ИдентификаторФайла = Неопределено) Экспорт
	
	ВнешняяТранзакция = ТранзакцияАктивна();
	
	Если Не ВнешняяТранзакция Тогда
		НачатьТранзакцию();
	КонецЕсли;
	
	Попытка

		// Создадим карточку Файла в БД
		Док = СоздатьФайл(
			ВладелецФайла,
			Комментарий,
			ИмяБезРасширения,
			ХранитьВерсии,
			АдресВременногоХранилищаТекста,
			Пользователь,
			ИдентификаторФайла);
		
		// Создадим версию сохраняемого файла для сохранения в карточке Файла
		Версия = СоздатьВерсию(
			ВремяИзменения,
			ВремяИзмененияУниверсальное,
			Док,
			ИмяБезРасширения,
			Размер,
			РасширениеБезТочки,
			АдресВременногоХранилищаФайла,
			АдресВременногоХранилищаТекста,
			ЭтоВебКлиент,
			Неопределено, // СсылкаНаВерсиюИсточник
			Неопределено, // НоваяВерсияДатаСоздания
			Пользователь);

		// Подставим ссылку на версию в карточку Файла
		ОбновитьВерсиюВФайле(Док, Версия, АдресВременногоХранилищаТекста);
		
		Если СписокКатегорий <> Неопределено Тогда  
			Если ТипЗнч(ВладелецФайла) = Тип("СправочникСсылка.ПапкиФайлов") Тогда
				РаботаСКатегориямиДанных.ЗаписатьСписокКатегорийУОбъекта(СписокКатегорий, Док);
			Иначе
				РаботаСКатегориямиДанных.ЗаписатьСписокКатегорийУОбъекта(СписокКатегорий, ВладелецФайла);
			КонецЕсли;
		КонецЕсли;
		
		Если Кодировка <> Неопределено Тогда
			ЗаписатьКодировкуВерсииФайла(Версия, Кодировка);
		КонецЕсли;	
		
		Если Не ВнешняяТранзакция Тогда
			ЗафиксироватьТранзакцию();
		КонецЕсли;
		
	Исключение
		Если Не ВнешняяТранзакция Тогда
			ОтменитьТранзакцию();
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	
	Попытка
		Если ПолучитьФункциональнуюОпцию("ИспользоватьШтрихкоды") Тогда
			ДанныеОШтрихкодеФайла = ШтрихкодированиеСервер.ПолучитьДанныеДляВставкиШтрихкодаВОбъект(Док);
			Если ДанныеОШтрихкодеФайла <> Неопределено И ДанныеОШтрихкодеФайла.Свойство("ДвоичныеДанныеФайла") Тогда
				
				Результат = ШтрихкодированиеКлиентСервер.ВставитьШтрихкодВместоТэга(Док.Ссылка,
					НСтр("ru = 'ВставитьИзображениеШтрихкода'"), 
					Ложь, 
					ДанныеОШтрихкодеФайла.ДвоичныеДанныеИзображения, 
					ДанныеОШтрихкодеФайла.ДвоичныеДанныеФайла,
					ДанныеОШтрихкодеФайла.Расширение,
					ДанныеОШтрихкодеФайла.ФайлРедактируется,
					ДанныеОШтрихкодеФайла.ИзменениеФайловMSWordТолькоНаСервере,
					ДанныеОШтрихкодеФайла.НастройкиШтрихкода.ВысотаШК);
					
				НеобходимоВыполнитьВставкуШКНаКлиенте = НЕ (Результат <> Ложь);
				
			КонецЕсли;
		КонецЕсли;
	Исключение
		Инфо = ИнформацияОбОшибке();
		НеобходимоВыполнитьВставкуШКНаКлиенте = НЕ (Инфо.Описание = "ТэгНеНайден");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'При автоматической вставке штрихкода в файл возникло исключение:
				|%1'"),
			Инфо.Описание);
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Вставка штрихкода'"),
			УровеньЖурналаРегистрации.Информация,
			,
			Док.Ссылка,
			ТекстСообщения);
	КонецПопытки;
	
	Если ЗаписатьВИсторию Тогда
		НавигационнаяСсылкаФайла = ПолучитьНавигационнуюСсылку(Док);
		ИсторияРаботыПользователя.Добавить(НавигационнаяСсылкаФайла);
	КонецЕсли;		
	
	Если ПараметрыРаспознавания = Неопределено Тогда
		
		ПараметрыРаспознавания = ПодготовитьПараметрыРаспознавания();
		
	Иначе		
		
		Если НЕ ПараметрыРаспознавания.Свойство("РаспознатьПослеДобавления") Тогда
			РаспознатьПослеДобавления = ПараметрыРаспознавания.СтратегияРаспознавания <> Перечисления.СтратегииРаспознаванияТекста.НеРаспознавать;
			ПараметрыРаспознавания.Вставить("РаспознатьПослеДобавления", РаспознатьПослеДобавления);
		КонецЕсли;			
		
	КонецЕсли;		

	Если ПараметрыРаспознавания <> Неопределено И ПараметрыРаспознавания.Свойство("РаспознатьПослеДобавления") И ПараметрыРаспознавания.РаспознатьПослеДобавления Тогда
		РаспознатьНемедленно = Ложь;
		ОписаниеОшибки = "";
		РаспознанныйТекст = "";
		РаспознатьФайл(Док, ПараметрыРаспознавания, ОписаниеОшибки, РаспознанныйТекст, Неопределено, 
			РаспознатьНемедленно);		
	КонецЕсли;			

	
	Если ДополнительныеПараметры <> Неопределено И ТипЗнч(ДополнительныеПараметры) = Тип("Структура")
		И ДополнительныеПараметры.Свойство("Сканирование") Тогда
		
		Если ДополнительныеПараметры.Сканирование Тогда
			ПротоколированиеРаботыПользователей.ЗаписатьСканирование(Док.Ссылка);	
		КонецЕсли;	
		
	КонецЕсли;	
	
	Возврат Док;
	
КонецФункции

// Получает данные файла и делает заем (checkout) - для экономии вызовов 
//клиент сервер поместили ПолучитьДанныеФайла и ЗанятьФайл в одну функцию
// Параметры
//  ФайлСсылка  - СправочникСсылка.Файлы - файл
//  ДанныеФайла  - Структура - структура с данными файла
//  СтрокаОшибки - строка, в которой возвращается причина ошибки в случае неуспеха (скажем "Файл занят другим пользователем")
//  УникальныйИдентификатор - уникальный идентификатор формы
//
// Возвращаемое значение:
//   Булево  - успешно ли выполнена операция
Функция ПолучитьДанныеФайлаИЗанятьФайл(ФайлСсылка, ДанныеФайла, СтрокаОшибки, ДатаЗаема, УникальныйИдентификатор = Неопределено) Экспорт

	Попытка
		НачатьТранзакцию();
		
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить("Справочник.Файлы");
		ЭлементБлокировки.УстановитьЗначение("Ссылка", ФайлСсылка);
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
		Блокировка.Заблокировать();
	
		ДанныеФайла = ПолучитьДанныеФайла(ФайлСсылка);

		СтрокаОшибки = "";
		Если НЕ РаботаСФайламиКлиентСервер.МожноЛиЗанятьФайл(ДанныеФайла, СтрокаОшибки) Тогда
			ОтменитьТранзакцию();
			Возврат Ложь;
		КонецЕсли;	
		
		Если ДанныеФайла.Редактирует.Пустая() Тогда
			
			СтрокаОшибки = "";
			Если Не ЗанятьФайл(ДанныеФайла, СтрокаОшибки, ДатаЗаема, УникальныйИдентификатор) Тогда 
				ОтменитьТранзакцию();
				Возврат Ложь;
			КонецЕсли;
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
	
	Исключение
		ОтменитьТранзакцию();
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Заем файла для редактирования'"), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение;
	КонецПопытки;
		
	Возврат Истина;
	
КонецФункции // ПолучитьДанныеФайлаИЗанятьФайл()

// получает ДанныеФайла и делает заем для массива файлов. При ошибке продолжает работу
//  в МассивДанныхФайла возвращает только успешно занятые файлы
Процедура ПолучитьДанныеИЗанятьМассивФайлов(МассивОтмеченныхПодчиненных, МассивДанныхФайла, УникальныйИдентификатор = Неопределено) Экспорт
	
	Для Каждого СтруктураПодчиненного Из МассивОтмеченныхПодчиненных Цикл
		ДанныеФайла = ПолучитьДанныеФайла(СтруктураПодчиненного.ПодчиненныйФайл, Неопределено);

		СтрокаОшибки = "";
		Если РаботаСФайламиКлиентСервер.МожноЛиЗанятьФайл(ДанныеФайла, СтрокаОшибки) Тогда
			
			Если ДанныеФайла.Редактирует.Пустая() Тогда
				Если ЗанятьФайл(ДанныеФайла, СтрокаОшибки, УникальныйИдентификатор) Тогда 
					МассивДанныхФайла.Добавить(ДанныеФайла);
				КонецЕсли;	
			КонецЕсли;
			
		КонецЕсли;	
	КонецЦикла;
	
КонецПроцедуры	

// получает ДанныеФайла для подчиненных файлов и помещает в МассивДанныхФайла
Процедура ПолучитьДанныеМассиваФайлов(МассивОтмеченныхПодчиненных, МассивДанныхФайла) Экспорт
	
	Для Каждого СтруктураПодчиненного Из МассивОтмеченныхПодчиненных Цикл
		ДанныеФайла = ПолучитьДанныеФайла(СтруктураПодчиненного.ПодчиненныйФайл, Неопределено);
		МассивДанныхФайла.Добавить(ДанныеФайла);
	КонецЦикла;
	
КонецПроцедуры

// получает ДанныеФайла для файлов и помещает в МассивДанныхФайла
Процедура ПолучитьДанныеДляМассиваФайлов(Знач МассивФайлов, МассивДанныхФайла) Экспорт
	
	Для Каждого Файл Из МассивФайлов Цикл
		ДанныеФайла = ПолучитьДанныеФайла(Файл, Неопределено);
		МассивДанныхФайла.Добавить(ДанныеФайла);
	КонецЦикла;
	
КонецПроцедуры	

// Получает данные файла для открытия и делает заем (checkout) - для экономии вызовов 
//клиент сервер поместили ПолучитьДанныеФайлаДляОткрытия и ЗанятьФайл в одну функцию
// Параметры
//  ФайлСсылка  - СправочникСсылка.Файлы - файл
//  ДанныеФайла  - Структура - структура с данными файла
//  СтрокаОшибки - строка, в которой возвращается причина ошибки в случае неуспеха (скажем "Файл занят другим пользователем")
//  УникальныйИдентификатор - уникальный идентификатор формы
//  РабочийКаталогВладельца - Строка - рабочий каталог владельца файла
//
// Возвращаемое значение:
//   Булево  - успешно ли выполнена операция
Функция ПолучитьДанныеФайлаДляОткрытияИЗанятьФайл(ФайлСсылка, ДанныеФайла, СтрокаОшибки, 
	ДатаЗаема, УникальныйИдентификатор = Неопределено, РабочийКаталогВладельца = Неопределено) Экспорт

	НачатьТранзакцию();
	Попытка
		
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить("Справочник.Файлы");
		ЭлементБлокировки.УстановитьЗначение("Ссылка", ФайлСсылка);
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
		Блокировка.Заблокировать();
	
		ДанныеФайла = ПолучитьДанныеФайлаДляОткрытия(ФайлСсылка, Неопределено, УникальныйИдентификатор, РабочийКаталогВладельца);

		СтрокаОшибки = "";
		Если НЕ РаботаСФайламиКлиентСервер.МожноЛиЗанятьФайл(ДанныеФайла, СтрокаОшибки) Тогда
			Возврат Ложь;
		КонецЕсли;	
		
		Если ДанныеФайла.Редактирует.Пустая() Тогда
			
			СтрокаОшибки = "";
			Если Не ЗанятьФайл(ДанныеФайла, СтрокаОшибки, ДатаЗаема, УникальныйИдентификатор) Тогда 
				Возврат Ложь;
			КонецЕсли;	
		КонецЕсли;
		
		ДанныеФайла.Вставить("ЕстьЗашифрованныеИлиЗанятыеФайлы", ЕстьЗашифрованныеИлиЗанятыеФайлы(ДанныеФайла.Владелец));
		
		ЗафиксироватьТранзакцию();
	
	Исключение
		ОтменитьТранзакцию();
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Заем файла для редактирования'"), 
			УровеньЖурналаРегистрации.Ошибка, , , ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат Истина;
	
КонецФункции // ПолучитьДанныеФайлаИЗанятьФайл()

// делает ПоместитьВоВременноеХранилище (если файл хранится на диске) и возвращает нужную ссылку
// Параметры
// ВерсияСсылка - версия файла
//  ИдентификаторФормы - уникальный идентификатор формы
//
// Возвращаемое значение:
//   Строка  - навигационная ссылка во временном хранилище
Функция ПолучитьНавигационнуюСсылкуДляОткрытия(ВерсияСсылка, ИдентификаторФормы = Неопределено,
	ДополнительныеПараметры = Неопределено) Экспорт
	Адрес = "";
	
	ТипХраненияФайла = ВерсияСсылка.ТипХраненияФайла;
	
	Если ВерсияСсылка.ФайлУдален Тогда
		
		СтрокаОшибки = НСтр("ru='Эта версия файла является устаревшей и сейчас недоступна. 
			|Для получения доступа обратитесь к администратору системы.'");
		
		ВызватьИсключение СтрокаОшибки;
		
	КонецЕсли;	
	
	Если ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
		Если НЕ ВерсияСсылка.Том.Пустая() Тогда
			ПолныйПуть = ФайловыеФункции.ПолныйПутьТома(ВерсияСсылка.Том) + ВерсияСсылка.ПутьКФайлу; 
			Попытка
				ДвоичныеДанные = Новый ДвоичныеДанные(ПолныйПуть);
				Адрес = ПоместитьВоВременноеХранилище(ДвоичныеДанные, ИдентификаторФормы);
			Исключение
				// запись в журнал регистрации
				СообщениеОбОшибке = СформироватьТекстОшибкиПолученияФайлСТомаДляАдминистратора(ИнформацияОбОшибке(), ВерсияСсылка.Владелец);
				ЗаписьЖурналаРегистрации(НСтр("ru = 'Открытие файла'"), УровеньЖурналаРегистрации.Ошибка, Метаданные.Справочники.Файлы, ВерсияСсылка.Владелец, СообщениеОбОшибке);
				
				ВызватьИсключение ФайловыеФункцииСлужебныйКлиентСервер.ОшибкаФайлНеНайденВХранилищеФайлов(
					ВерсияСсылка.ПолноеНаименование + "." + ВерсияСсылка.Расширение);
					
			КонецПопытки;
		КонецЕсли;
	Иначе
		СтруктураКлюча = Новый Структура("ВерсияФайла", ВерсияСсылка);
		КлючЗаписи = РегистрыСведений.ХранимыеФайлыВерсий.СоздатьКлючЗаписи(СтруктураКлюча);
		Адрес = ПолучитьНавигационнуюСсылку(КлючЗаписи, "ХранимыйФайл");
	КонецЕсли;
	
	Если ДополнительныеПараметры <> Неопределено И ТипЗнч(ДополнительныеПараметры) = Тип("Структура")
		И ДополнительныеПараметры.Свойство("ЭкспортПапки") Тогда
		
		Если ДополнительныеПараметры.ЭкспортПапки Тогда
			ПротоколированиеРаботыПользователей.ЗаписатьЭкспортФайлов(ВерсияСсылка.Владелец, ДополнительныеПараметры.ПолныйПуть);
		КонецЕсли;	
		
	КонецЕсли;	
	
	Возврат Адрес;
КонецФункции // ПолучитьНавигационнуюСсылкуДляОткрытия()

// Делает ПолучитьДанныеФайла и вычисляет РабочийКаталогВладельца
// Параметры
//  ФайлСсылка  - СправочникСсылка.Файлы - файл
//  ВерсияСсылка  - СправочникСсылка.ВерсииФайлов - версия файла
//  РабочийКаталогВладельца - Строка - в ней возвращается рабочий каталог владельца файла
//
// Возвращаемое значение:
//   Структура - структура с данными файла
Функция ПолучитьДанныеФайлаИРабочийКаталог(ФайлСсылка, ВерсияСсылка = Неопределено, 
	РабочийКаталогВладельца = Неопределено) Экспорт
	
	ДанныеФайла = ПолучитьДанныеФайла(ФайлСсылка, ВерсияСсылка);
	
	Если РабочийКаталогВладельца = Неопределено Тогда
		РабочийКаталогВладельца = ПолучитьРабочийКаталог(ДанныеФайла.Владелец);
	КонецЕсли;
	ДанныеФайла.Вставить("РабочийКаталогВладельца", РабочийКаталогВладельца);
	
	Если ДанныеФайла.РабочийКаталогВладельца <> "" Тогда
		
		ИмяФайлаСПутемВРабочемКаталоге = "";
		ИмяКаталога = ""; // путь к локальному кешу здесь не используется
		ВРабочемКаталогеНаЧтение = Истина; // не используется 
		ВРабочемКаталогеВладельца = Истина;
		
		Если ВерсияСсылка <> Неопределено Тогда
			ИмяФайлаСПутемВРабочемКаталоге = ПолучитьИмяФайлаСПутемИзРегистра(ВерсияСсылка, ИмяКаталога, ВРабочемКаталогеНаЧтение, ВРабочемКаталогеВладельца);
		Иначе
			ИмяФайлаСПутемВРабочемКаталоге = ПолучитьИмяФайлаСПутемИзРегистра(ФайлСсылка.ТекущаяВерсия, ИмяКаталога, ВРабочемКаталогеНаЧтение, ВРабочемКаталогеВладельца);
		КонецЕсли;	
		
		ДанныеФайла.Вставить("ПолноеИмяФайлаВРабочемКаталоге", ИмяФайлаСПутемВРабочемКаталоге);
	КонецЕсли;
	
	Возврат ДанныеФайла;
КонецФункции // ПолучитьДанныеФайлаИРабочийКаталог()

// Делает ПолучитьДанныеФайла и вычисляет количество версий файла
// Параметры
//  ФайлСсылка  - СправочникСсылка.Файлы - файл
//
// Возвращаемое значение:
//   Структура - структура с данными файла
Функция ПолучитьДанныеФайлаИКоличествоВерсий(ФайлСсылка) Экспорт
	
	ДанныеФайла = ПолучитьДанныеФайла(ФайлСсылка);
	КоличествоВерсий = ПолучитьКоличествоВерсий(ФайлСсылка);
	ДанныеФайла.Вставить("КоличествоВерсий", КоличествоВерсий);
	Возврат ДанныеФайла;
КонецФункции // ПолучитьДанныеФайлаИРабочийКаталог()

// Формирует текст ошибки для помещения в журнал регистрации
// Параметры
//  ИнформацияОбОшибкеФункции  - ИнформацияОбОшибке
//  ФайлСсылка  - СправочникСсылка.Файлы - файл
//
// Возвращаемое значение:
//   Строка - описание ошибки
Функция СформироватьТекстОшибкиПолученияФайлСТомаДляАдминистратора(ИнформацияОбОшибкеФункции, ФайлСсылка) Экспорт
	
	СообщениеОбОшибке = ПодробноеПредставлениеОшибки(ИнформацияОбОшибкеФункции);
	Если ФайлСсылка <> Неопределено Тогда
		СообщениеОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = '%1
			|Ссылка на файл: %2'"),
			СообщениеОбОшибке, ПолучитьНавигационнуюСсылку(ФайлСсылка));
	КонецЕсли;
	
	Возврат СообщениеОбОшибке;
	
КонецФункции // СформироватьТекстОшибкиПолученияФайлСТомаДляАдминистратора()

// Делает ПолучитьДанныеФайла + ПоместитьВоВременноеХранилище (если файл хранится на диске)
// Функция возвращает структуру, содержащую различные сведения о Файле и версии
// Параметры
//  ФайлСсылка  - СправочникСсылка.Файлы - файл
//  ВерсияСсылка  - СправочникСсылка.ВерсииФайлов - версия файла
//  ИдентификаторФормы - уникальный идентификатор формы
//  РабочийКаталогВладельца - Строка - в ней возвращается рабочий каталог владельца файла
//
// Возвращаемое значение:
//   Структура - структура с данными файла
Функция ПолучитьДанныеФайлаДляОткрытия(
	ФайлСсылка, 
	ВерсияСсылка = Неопределено, 
	ИдентификаторФормы = Неопределено, 
	РабочийКаталогВладельца = Неопределено,
	ПредыдущийАдресФайла = Неопределено) Экспорт
	
	Если ПредыдущийАдресФайла <> Неопределено Тогда
		Если НЕ ПустаяСтрока(ПредыдущийАдресФайла) И ЭтоАдресВременногоХранилища(ПредыдущийАдресФайла) Тогда
			УдалитьИзВременногоХранилища(ПредыдущийАдресФайла);
		КонецЕсли;	
	КонецЕсли;	
	
	ДанныеФайла = ПолучитьДанныеФайла(ФайлСсылка, ВерсияСсылка);
	
	Если РабочийКаталогВладельца = Неопределено Тогда
		РабочийКаталогВладельца = ПолучитьРабочийКаталог(ДанныеФайла.Владелец);
	КонецЕсли;
	ДанныеФайла.Вставить("РабочийКаталогВладельца", РабочийКаталогВладельца);
	
	Если ДанныеФайла.РабочийКаталогВладельца <> "" Тогда
		ИмяФайла = ФайловыеФункцииКлиентСервер.ПолучитьИмяСРасширением(ДанныеФайла.ПолноеНаименованиеВерсии, ДанныеФайла.Расширение);
		ИмяФайлаСПутемВРабочемКаталоге = РабочийКаталогВладельца + ИмяФайла;
		ДанныеФайла.Вставить("ПолучитьДанныеФайлаДляОткрытия", ИмяФайлаСПутемВРабочемКаталоге);
	КонецЕсли;
	
	ТипХраненияФайла = ДанныеФайла.ТипХраненияФайла;
	
	Если ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске И ДанныеФайла.Версия <> Неопределено Тогда
		
		УстановитьПривилегированныйРежим(Истина);
		
		Запрос = Новый Запрос;
		
		Запрос.Текст = "ВЫБРАТЬ
					   |	ВерсииФайлов.ПутьКФайлу КАК ПутьКФайлу,
					   |	ВерсииФайлов.Том КАК Том
					   |ИЗ
					   |	Справочник.ВерсииФайлов КАК ВерсииФайлов
					   |ГДЕ
					   |	ВерсииФайлов.Ссылка = &Версия";
					   
		Запрос.Параметры.Вставить("Версия", ДанныеФайла.Версия);
		
		ДанныеФайлаТом = Справочники.ТомаХраненияФайлов.ПустаяСсылка();
		ДанныеФайлаПутьКФайлу = ""; 
		
		Выборка = Запрос.Выполнить().Выбрать();
		Если Выборка.Следующий() Тогда
			ДанныеФайлаТом = Выборка.Том;
			ДанныеФайлаПутьКФайлу = Выборка.ПутьКФайлу;
		КонецЕсли;
		
		Если НЕ ДанныеФайлаТом.Пустая() Тогда
			ПолныйПуть = ФайловыеФункции.ПолныйПутьТома(ДанныеФайлаТом) + ДанныеФайлаПутьКФайлу; 
			Попытка
				ДвоичныеДанные = Новый ДвоичныеДанные(ПолныйПуть);
				// работаем только с текущей версией - для не-текущей ссылку получаем в ПолучитьНавигационнуюСсылкуДляОткрытия
				ДанныеФайла.НавигационнаяСсылкаТекущейВерсии = ПоместитьВоВременноеХранилище(ДвоичныеДанные, ИдентификаторФормы);
			Исключение
				// запись в журнал регистрации
				СообщениеОбОшибке = СформироватьТекстОшибкиПолученияФайлСТомаДляАдминистратора(ИнформацияОбОшибке(), ФайлСсылка);
				ЗаписьЖурналаРегистрации(НСтр("ru = 'Открытие файла'"), УровеньЖурналаРегистрации.Ошибка, Метаданные.Справочники.Файлы, ФайлСсылка, СообщениеОбОшибке);
				
				ВызватьИсключение ФайловыеФункцииСлужебныйКлиентСервер.ОшибкаФайлНеНайденВХранилищеФайлов(
					ДанныеФайла.ПолноеНаименованиеВерсии + "." + ДанныеФайла.Расширение);
					
			КонецПопытки;
		КонецЕсли;
	КонецЕсли;
	
	ПротоколированиеРаботыПользователей.ЗаписатьПолучениеФайла(ДанныеФайла.Ссылка);
	
	ПредыдущийАдресФайла = ДанныеФайла.НавигационнаяСсылкаТекущейВерсии;
	ЗаписатьОбращениеКВерсииФайла(ДанныеФайла.Версия);
	РаботаСПоследнимиОбъектами.ЗаписатьОбращениеКОбъекту(ДанныеФайла.Ссылка);
	
	Возврат ДанныеФайла;
	
КонецФункции // ПолучитьДанныеФайлаДляОткрытия()

// 
Функция ПолучитьДанныеФайловДляОткрытия(
	МассивФайлов, 
	ИдентификаторФормы = Неопределено) Экспорт 
	
	ДанныеФайлов = ПолучитьДанныеФайла(МассивФайлов);
	
	СоответствиеФайлов = Новый Соответствие;
	Для Каждого ДанныеФайла Из ДанныеФайлов Цикл
		СоответствиеФайлов.Вставить(ДанныеФайла.Ссылка, ДанныеФайла);
	КонецЦикла;	
	
	Для Каждого Файл Из МассивФайлов Цикл
		ДанныеФайла = СоответствиеФайлов.Получить(Файл);
		
		РабочийКаталогВладельца = ПолучитьРабочийКаталог(ДанныеФайла.Владелец);
		ДанныеФайла.Вставить("РабочийКаталогВладельца", РабочийКаталогВладельца);
		
		Если ДанныеФайла.РабочийКаталогВладельца <> "" Тогда
			ИмяФайла = ФайловыеФункцииКлиентСервер.ПолучитьИмяСРасширением(ДанныеФайла.ПолноеНаименованиеВерсии, ДанныеФайла.Расширение);
			ИмяФайлаСПутемВРабочемКаталоге = РабочийКаталогВладельца + ИмяФайла;
			ДанныеФайла.Вставить("ПолноеИмяФайлаВРабочемКаталоге", ИмяФайлаСПутемВРабочемКаталоге);
		КонецЕсли;
		
		ТипХраненияФайла = ДанныеФайла.ТипХраненияФайла;
		Если ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске И ДанныеФайла.Версия <> Неопределено Тогда
			
			УстановитьПривилегированныйРежим(Истина);
			
			Запрос = Новый Запрос;
			Запрос.Текст = 
			"ВЫБРАТЬ
			|	ВерсииФайлов.ПутьКФайлу КАК ПутьКФайлу,
			|	ВерсииФайлов.Том КАК Том
			|ИЗ
			|	Справочник.ВерсииФайлов КАК ВерсииФайлов
			|ГДЕ
			|	ВерсииФайлов.Ссылка = &Версия";
			
			Запрос.Параметры.Вставить("Версия", ДанныеФайла.Версия);
			
			ДанныеФайлаТом = Справочники.ТомаХраненияФайлов.ПустаяСсылка();
			ДанныеФайлаПутьКФайлу = ""; 
			
			Выборка = Запрос.Выполнить().Выбрать();
			Если Выборка.Следующий() Тогда
				ДанныеФайлаТом = Выборка.Том;
				ДанныеФайлаПутьКФайлу = Выборка.ПутьКФайлу;
			КонецЕсли;
			
			Если НЕ ДанныеФайлаТом.Пустая() Тогда
				ПолныйПуть = ФайловыеФункции.ПолныйПутьТома(ДанныеФайлаТом) + ДанныеФайлаПутьКФайлу; 
				Попытка
					ДвоичныеДанные = Новый ДвоичныеДанные(ПолныйПуть);
					// работаем только с текущей версией - для не-текущей ссылку получаем в ПолучитьНавигационнуюСсылкуДляОткрытия
					ДанныеФайла.НавигационнаяСсылкаТекущейВерсии = ПоместитьВоВременноеХранилище(ДвоичныеДанные, ИдентификаторФормы);
				Исключение
					// запись в журнал регистрации
					СообщениеОбОшибке = СформироватьТекстОшибкиПолученияФайлСТомаДляАдминистратора(ИнформацияОбОшибке(), ДанныеФайла.Ссылка);
					ЗаписьЖурналаРегистрации(НСтр("ru = 'Получение данных файла для открытия'"), УровеньЖурналаРегистрации.Ошибка, Метаданные.Справочники.Файлы, ДанныеФайла.Ссылка, СообщениеОбОшибке);
					
					ВызватьИсключение ФайловыеФункцииСлужебныйКлиентСервер.ОшибкаФайлНеНайденВХранилищеФайлов(
						ДанныеФайла.ПолноеНаименованиеВерсии + "." + ДанныеФайла.Расширение);
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
		
		ЗаписатьОбращениеКВерсииФайла(ДанныеФайла.Версия);
		РаботаСПоследнимиОбъектами.ЗаписатьОбращениеКОбъекту(ДанныеФайла.Ссылка);
		
	КонецЦикла;
	
	Возврат ДанныеФайлов;
	
КонецФункции // ПолучитьДанныеФайлаДляОткрытия()

// Освобождение Файла с получением данных
// Параметры
//  ФайлСсылка  - СправочникСсылка.Файлы - файл
//  ДанныеФайла  - структура с данными файла
//  УникальныйИдентификатор - уникальный идентификатор формы
Процедура ПолучитьДанныеФайлаИОсвободитьФайл(ФайлСсылка, ДанныеФайла, УникальныйИдентификатор = Неопределено) Экспорт
	
	ДанныеФайла = ПолучитьДанныеФайла(
		ФайлСсылка);
		
	ОсвободитьФайл(ДанныеФайла, УникальныйИдентификатор);	
КонецПроцедуры	

// получает ДанныеФайла и делает освобождение для массива файлов. При ошибке продолжает работу
//  в МассивДанныхФайла возвращает только успешно освобожденные файлы
Процедура ПолучитьДанныеИОсвободитьМассивФайлов(МассивОтмеченныхПодчиненных, МассивДанныхФайла, УникальныйИдентификатор = Неопределено) Экспорт
	
	Для Каждого СтруктураПодчиненного Из МассивОтмеченныхПодчиненных Цикл
		
		ДанныеФайла = ПолучитьДанныеФайла(СтруктураПодчиненного.ПодчиненныйФайл, Неопределено);

		Если Не ДанныеФайла.Редактирует.Пустая() Тогда
			ОсвободитьФайл(ДанныеФайла, УникальныйИдентификатор);	
			МассивДанныхФайла.Добавить(ДанныеФайла);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры	

// Процедура предназначена для опубликования файла без его освобождения
// Параметры
// Файл - СправочникСсылка.Файлы - Файл, в котором обновляется версия
// ДанныеФайла  - структура с данными файла
// СоздаватьВерсию  - Булево - создавать новую версию, если Истина (если Ложь - изменяет существующую)
// АдресВременногоХранилищаФайла  - Строка - содержит адрес во временном хранилище, где находятся двоичные данные с файлом или ХранилищеЗначения - непосредственно содержит  двоичные данные с файлом
// Комментарий  - Строка - комментарий к версии
// ВремяИзменения  - Дата - дата и время изменения файла
// ВремяИзмененияУниверсальное  - Дата - UTC дата и время изменения файла
// Размер - размер файла в байтах
// ИмяБезРасширения  - Строка - имя файла без расширения
// Расширение - Строка - расширение файла
// ОтносительныйПутьКФайлу - Строка - относительный путь к файлу - не содержащий пути рабочего каталога, например "А1/Приказ.doc"
// ПолныйПутьКФайлу - полный путь к файлу на клиенте в рабочем каталоге
// АдресВременногоХранилищаТекста - Строка - содержит адрес во временном хранилище, где находятся двоичные данные с файлом текста или ХранилищеЗначения - непосредственно содержит  двоичные данные с файлом текста
// ЭтоВебКлиент - Булево - Истина, если вызов идет из веб клиента
// ТекстНеИзвлеченНаКлиенте - Булево - текст не извлечен на клиенте - т.е. его надо извлекать на сервере
// ВРабочемКаталогеВладельца - Булево - файл находится в рабочем каталоге владельца
// УникальныйИдентификатор - уникальный идентификатор формы
Процедура ПолучитьДанныеФайлаИОпубликоватьФайл(
	Файл, 
	ДанныеФайла,
	СоздаватьВерсию, 
	АдресВременногоХранилищаФайла, 
	Комментарий, 
	ВремяИзменения, 
	ВремяИзмененияУниверсальное,
	Размер, 
	ИмяБезРасширения, 
	Расширение, 
	ОтносительныйПутьКФайлу, 
	ПолныйПутьКФайлу,
	АдресВременногоХранилищаТекста,
	ЭтоВебКлиент,
	ТекстНеИзвлеченНаКлиенте,
	ВРабочемКаталогеВладельца,
	УникальныйИдентификатор = Неопределено) Экспорт

	ДанныеФайла = ПолучитьДанныеФайла(
		Файл);
		
	Если Не ДанныеФайла.РедактируетТекущийПользователь Тогда
		ВызватьИсключение НСтр("ru = 'Файл не занят текущим пользователем'");
	КонецЕсли;	
		
	НеМенятьЗаписьВРабочемКаталоге = Ложь;

	ОпубликоватьФайл(
		Файл, 
		СоздаватьВерсию,
		АдресВременногоХранилищаФайла,
		Комментарий,
		ВремяИзменения,
		ВремяИзмененияУниверсальное,
		Размер,
		ИмяБезРасширения,
		Расширение,
		ОтносительныйПутьКФайлу,
		ПолныйПутьКФайлу,
		АдресВременногоХранилищаТекста,
		ЭтоВебКлиент,
		ТекстНеИзвлеченНаКлиенте,
		ВРабочемКаталогеВладельца,
		НеМенятьЗаписьВРабочемКаталоге,
		УникальныйИдентификатор);
КонецПроцедуры	

// Получает синтетический рабочий каталог папки на диске (он может прийти от родительской папки)
// Параметры
//  СсылкаПапки  - СправочникСсылка.ПапкиФайлов - владелец файла
//
// Возвращаемое значение:
//   Строка  - рабочий каталог
Функция ПолучитьРабочийКаталог(СсылкаПапки) Экспорт
	Если ТипЗнч(СсылкаПапки) <> Тип("СправочникСсылка.ПапкиФайлов") Тогда
		Возврат "";
	КонецЕсли;	
	
	УстановитьПривилегированныйРежим(Истина);
	
	РабочийКаталог = "";
	
	// Подготовить структуру отбора по измерениям      
	СтруктураОтбора = Новый Структура;
	СтруктураОтбора.Вставить("Папка", СсылкаПапки);
	СтруктураОтбора.Вставить("Пользователь", Пользователи.ТекущийПользователь());
	   
	// Получить структуру с данными ресурсов записи
	СтруктураРесурсов = РегистрыСведений.РабочиеКаталогиФайлов.Получить(СтруктураОтбора);
	   
	// Получить путь из регистра
	РабочийКаталог = СтруктураРесурсов.Путь;
	
	Если НЕ ПустаяСтрока(РабочийКаталог) Тогда
		// Добавляем слэш в конце, если его нет
		РабочийКаталог = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(РабочийКаталог, ОбщегоНазначенияПовтИсп.ТипПлатформыСервера());
	КонецЕсли;
	
	Возврат РабочийКаталог;
КонецФункции	

// Сохраняет в регистре сведений рабочий каталог папки
// Параметры
//  СсылкаПапки  - СправочникСсылка.ПапкиФайлов - владелец файла
//  РабочийКаталогВладельца - Строка - рабочий каталог владельца
Процедура СохранитьРабочийКаталог(СсылкаПапки, РабочийКаталогВладельца) Экспорт
	УстановитьПривилегированныйРежим(Истина);
	
	НаборЗаписей = РегистрыСведений.РабочиеКаталогиФайлов.СоздатьНаборЗаписей();
	
	НаборЗаписей.Отбор.Папка.Установить(СсылкаПапки);
	НаборЗаписей.Отбор.Пользователь.Установить(Пользователи.ТекущийПользователь());

	НоваяЗапись = НаборЗаписей.Добавить();
	НоваяЗапись.Папка = СсылкаПапки;
	НоваяЗапись.Пользователь = Пользователи.ТекущийПользователь();
	НоваяЗапись.Путь = РабочийКаталогВладельца;

	НаборЗаписей.Записать();
КонецПроцедуры

// Сохраняет в регистре сведений рабочий каталог папки и заменяет пути в регистре сведений ФайлыВРабочемКаталоге
// Параметры
//  СсылкаПапки  - СправочникСсылка.ПапкиФайлов - владелец файла
//  РабочийКаталогВладельца - Строка - рабочий каталог владельца
//  ИмяКаталогаПрежнееЗначение - Строка - прежнее значение рабочего каталога 
Процедура СохранитьРабочийКаталогИЗаменитьПутиВРегистре(СсылкаПапки, РабочийКаталогВладельца,
						ИмяКаталогаПрежнееЗначение) Экспорт
						
	СохранитьРабочийКаталог(СсылкаПапки, РабочийКаталогВладельца);						
	
	// ниже заменяем пути в регистре сведений ФайлыВРабочемКаталоге                        
	УстановитьПривилегированныйРежим(Истина);
	
	СписокДляЗамены = Новый Массив;
	ТекущийПользователь = Пользователи.ТекущийПользователь();
	
	// для каждой нашей записи находим запись в регистре сведений - оттуда берем поле Версия и Редактирует
	ЗапросВРегистр = Новый Запрос;
	ЗапросВРегистр.УстановитьПараметр("Пользователь", ТекущийПользователь);
	ЗапросВРегистр.УстановитьПараметр("Путь", ИмяКаталогаПрежнееЗначение + "%");
	ЗапросВРегистр.Текст = "ВЫБРАТЬ
	                       |	ФайлыВРабочемКаталоге.Версия КАК Версия,
	                       |	ФайлыВРабочемКаталоге.Путь КАК Путь,
	                       |	ФайлыВРабочемКаталоге.Размер КАК Размер,
	                       |	ФайлыВРабочемКаталоге.ДатаПомещенияВРабочийКаталог КАК ДатаПомещенияВРабочийКаталог,
	                       |	ФайлыВРабочемКаталоге.НаЧтение КАК НаЧтение
	                       |ИЗ
	                       |	РегистрСведений.ФайлыВРабочемКаталоге КАК ФайлыВРабочемКаталоге
	                       |ГДЕ
	                       |	ФайлыВРабочемКаталоге.Пользователь = &Пользователь
	                       |	И ФайлыВРабочемКаталоге.ВРабочемКаталогеВладельца = ИСТИНА
	                       |	И ФайлыВРабочемКаталоге.Путь ПОДОБНО &Путь";
	
	РезультатЗапроса = ЗапросВРегистр.Выполнить(); 
	
	Выборка = РезультатЗапроса.Выбрать();
	Пока Выборка.Следующий() Цикл
			
		НовыйПуть = Выборка.Путь;
		НовыйПуть = СтрЗаменить(НовыйПуть, ИмяКаталогаПрежнееЗначение, РабочийКаталогВладельца);
		
		СтруктураЗаписи = Новый Структура("Версия, Путь, Размер, ДатаПомещенияВРабочийКаталог, НаЧтение",
			Выборка.Версия, НовыйПуть, Выборка.Размер, 
			Выборка.ДатаПомещенияВРабочийКаталог, Выборка.НаЧтение);
		СписокДляЗамены.Добавить(СтруктураЗаписи);
		
	КонецЦикла;
	
	Для Каждого СтруктураЗаписи из СписокДляЗамены Цикл
		
		ВРабочемКаталогеВладельца = Истина;
		ЗаписатьСтруктуруЗаписиВРегистр(СтруктураЗаписи.Версия, СтруктураЗаписи.Путь, СтруктураЗаписи.Размер, 
			СтруктураЗаписи.ДатаПомещенияВРабочийКаталог, СтруктураЗаписи.НаЧтение, ВРабочемКаталогеВладельца);
		
	КонецЦикла;
	
КонецПроцедуры		

// После смены пути запишем заново - с теми же значениями остальных полей
// Параметры
//  Версия - СправочникСсылка.ВерсииФайлов - версия
//  Путь - Строка - относительный путь внутри рабочего каталога
//  Размер  - размер файла в байтах
//  ДатаПомещенияВРабочийКаталог - Дата - дата помещения файла в рабочий каталог
//  НаЧтение - Булево - файл помещен на чтение
//  ВРабочемКаталогеВладельца - Булево - файл в рабочем каталоге владельца (а не в основном рабочем каталоге)
Процедура ЗаписатьСтруктуруЗаписиВРегистр(Версия, Путь, Размер, ДатаПомещенияВРабочийКаталог, НаЧтение, ВРабочемКаталогеВладельца) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	// Создать набор записей
	НаборЗаписей = РегистрыСведений.ФайлыВРабочемКаталоге.СоздатьНаборЗаписей();
	
	НаборЗаписей.Отбор.Версия.Установить(Версия);
	НаборЗаписей.Отбор.Пользователь.Установить(Пользователи.ТекущийПользователь());

	НоваяЗапись = НаборЗаписей.Добавить();
	НоваяЗапись.Версия = Версия;
	НоваяЗапись.Путь = Путь;
	НоваяЗапись.Размер = Размер;
	НоваяЗапись.ДатаПомещенияВРабочийКаталог = ДатаПомещенияВРабочийКаталог;
	НоваяЗапись.Пользователь = Пользователи.ТекущийПользователь();

	НоваяЗапись.НаЧтение = НаЧтение;
	НоваяЗапись.ВРабочемКаталогеВладельца = ВРабочемКаталогеВладельца;
	
	НаборЗаписей.Записать();
КонецПроцедуры

// Очищает в регистре сведений рабочий каталог папки
// Параметры
//  СсылкаПапки  - СправочникСсылка.ПапкиФайлов - владелец файла
Процедура ОчиститьРабочийКаталог(СсылкаПапки) Экспорт
	УстановитьПривилегированныйРежим(Истина);
	
	НаборЗаписей = РегистрыСведений.РабочиеКаталогиФайлов.СоздатьНаборЗаписей();
	
	НаборЗаписей.Отбор.Папка.Установить(СсылкаПапки);
	НаборЗаписей.Отбор.Пользователь.Установить(Пользователи.ТекущийПользователь());
	
	// не добавляем записи в набор - чтобы все стереть
	НаборЗаписей.Записать();
	
	
	// для дочерних папок очищаем рабочие каталоги
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ 
		|	ПапкиФайлов.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.ПапкиФайлов КАК ПапкиФайлов
		|ГДЕ
		|	ПапкиФайлов.Родитель = &Ссылка";
	
	Запрос.УстановитьПараметр("Ссылка", СсылкаПапки);
	
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	Пока Выборка.Следующий() Цикл
		ОчиститьРабочийКаталог(Выборка.Ссылка);
	КонецЦикла;
	
КонецПроцедуры

// Находит запись в регистре сведений ФайлыВРабочемКаталоге по пути файла на диске (относительному)
// Параметры
//  ИмяФайла - Строка - имя файла
//  Версия - СправочникСсылка.ВерсииФайлов - сюда помещается найденная версия
//  ДатаПомещения - Дата - дата помещения файла в рабочий каталог
//  Владелец - СправочникСсылка.Файлы - файл - владелец версии
// НомерВерсии - сюда помещается номер версии
// ВРегистреНаЧтение - сюда помещается значение ресурса НаЧтение 
// ВРегистреКодФайла - сюда помещается код файла
// ВРегистреПапка - сюда помещается папка файла
Функция НайтиВРегистреПоПути(ИмяФайла, Версия, ДатаПомещения, Владелец, НомерВерсии, ВРегистреНаЧтение, ВРегистреКодФайла, ВРегистреПапка) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Версия = Новый ("СправочникСсылка.ВерсииФайлов");
	
	// Для каждого по пути находим запись в регистре сведений - оттуда берем поле 
	// Версия и Размер и ДатаПомещенияВРабочийКаталог
	ЗапросВРегистр = Новый Запрос;
	ЗапросВРегистр.УстановитьПараметр("ИмяФайла", ИмяФайла);
	ЗапросВРегистр.УстановитьПараметр("Пользователь", Пользователи.ТекущийПользователь());
	ЗапросВРегистр.Текст = "ВЫБРАТЬ
	                       |	ФайлыВРабочемКаталоге.Версия КАК Версия,
	                       |	ФайлыВРабочемКаталоге.ДатаПомещенияВРабочийКаталог КАК ДатаПомещенияВРабочийКаталог,
						   |    ФайлыВРабочемКаталоге.НаЧтение КАК НаЧтение
	                       |ИЗ
	                       |	РегистрСведений.ФайлыВРабочемКаталоге КАК ФайлыВРабочемКаталоге
	                       |ГДЕ
	                       |	ФайлыВРабочемКаталоге.Путь = &ИмяФайла
	                       |	И ФайлыВРабочемКаталоге.Пользователь = &Пользователь";
	
	РезультатЗапроса = ЗапросВРегистр.Выполнить(); 
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		
		Версия = Выборка.Версия;
		ДатаПомещения = Выборка.ДатаПомещенияВРабочийКаталог;
		
		Владелец = Версия.Владелец;
		НомерВерсии = Версия.НомерВерсии;
		ВРегистреНаЧтение = Выборка.НаЧтение;
		ВРегистреКодФайла = Версия.Владелец.Код;
		ВРегистреПапка = Владелец.ВладелецФайла;
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
КонецФункции

// Возвращает с сервера на клиент идентификатор текущего пользователя
// Возвращаемое значение:
//   УникальныйИдентификатор  - Уникальный идентификатор текущего пользователя
Функция ПараметрыСеансаИдентификаторТекущегоПользователя() Экспорт
	Возврат Пользователи.ТекущийПользователь().УникальныйИдентификатор();
КонецФункции

// Находит в регистре сведений ФайлыВРабочемКаталоге информацию о ВерсииФайла (путь к файлу версии в рабочем каталоге, и статус - на чтение или на редактирование)
// Параметры
//  Версия - СправочникСсылка.ВерсииФайлов - версия
//  ИмяКаталога - путь рабочего каталога
//  ВРабочемКаталогеНаЧтение - Булево - файл помещен на чтение
//  ВРабочемКаталогеВладельца - Булево - файл в рабочем каталоге владельца (а не в основном рабочем каталоге)
Функция ПолучитьИмяФайлаСПутемИзРегистра(Версия, ИмяКаталога, ВРабочемКаталогеНаЧтение, ВРабочемКаталогеВладельца) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ИмяФайлаСПутем = "";
	
	// Подготовить структуру отбора по измерениям      
	СтруктураОтбора = Новый Структура;
	СтруктураОтбора.Вставить("Версия", Версия.Ссылка);
	СтруктураОтбора.Вставить("Пользователь", Пользователи.ТекущийПользователь());
	   
	// Получить структуру с данными ресурсов записи
	СтруктураРесурсов = РегистрыСведений.ФайлыВРабочемКаталоге.Получить(СтруктураОтбора);
	   
	// Получить путь из регистра
	ИмяФайлаСПутем = СтруктураРесурсов.Путь;
	ВРабочемКаталогеНаЧтение = СтруктураРесурсов.НаЧтение;
	ВРабочемКаталогеВладельца = СтруктураРесурсов.ВРабочемКаталогеВладельца;
	Если ИмяФайлаСПутем <> "" И ВРабочемКаталогеВладельца = Ложь Тогда
		ИмяФайлаСПутем = ИмяКаталога + ИмяФайлаСПутем;
	КонецЕсли;
	
	Возврат ИмяФайлаСПутем;
КонецФункции

// Находит в регистре сведений ФайлыВРабочемКаталоге информацию о ВерсииФайла (путь к файлу версии в рабочем каталоге)
// Параметры
//  Ссылка  - СправочникСсылка.ВерсииФайлов - версия файла
//
// Возвращаемое значение:
//   Строка - имя с путем в рабочем каталоге
Функция ПолучитьИмяФайлаИзРегистра(Ссылка) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ИмяФайлаСПутем = "";
	
	// Подготовить структуру отбора по измерениям      
	СтруктураОтбора = Новый Структура;
	СтруктураОтбора.Вставить("Версия", Ссылка);
	СтруктураОтбора.Вставить("Пользователь", Пользователи.ТекущийПользователь());
	   
	// Получить структуру с данными ресурсов записи
	СтруктураРесурсов = РегистрыСведений.ФайлыВРабочемКаталоге.Получить(СтруктураОтбора);
	   
	// Получить путь из регистра
	ИмяФайлаСПутем = СтруктураРесурсов.Путь;
	
	Возврат ИмяФайлаСПутем;
КонецФункции

// Записать в регистр сведений ФайлыВРабочемКаталоге информацию о пути файла
// Параметры
//  ТекущаяВерсия - СправочникСсылка.ВерсииФайлов - версия
//  ИмяФайлаСПутем - имя с путем в рабочем каталоге
//  НаЧтение - Булево - файл помещен на чтение
//  ВРабочемКаталогеВладельца - Булево - файл в рабочем каталоге владельца (а не в основном рабочем каталоге)
Процедура ЗаписатьИмяФайлаСПутемВРегистр(ТекущаяВерсия, ИмяФайлаСПутем, НаЧтение, ВРабочемКаталогеВладельца) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	// Создать набор записей
	НаборЗаписей = РегистрыСведений.ФайлыВРабочемКаталоге.СоздатьНаборЗаписей();
	
	НаборЗаписей.Отбор.Версия.Установить(ТекущаяВерсия.Ссылка);
	НаборЗаписей.Отбор.Пользователь.Установить(Пользователи.ТекущийПользователь());

	НоваяЗапись = НаборЗаписей.Добавить();
	НоваяЗапись.Версия = ТекущаяВерсия.Ссылка;
	НоваяЗапись.Путь = ИмяФайлаСПутем;
	НоваяЗапись.Размер = ТекущаяВерсия.Размер;
	НоваяЗапись.ДатаПомещенияВРабочийКаталог = ТекущаяДатаСеанса();
	НоваяЗапись.Пользователь = Пользователи.ТекущийПользователь();

	НоваяЗапись.НаЧтение = НаЧтение;
	НоваяЗапись.ВРабочемКаталогеВладельца = ВРабочемКаталогеВладельца;
	
	НаборЗаписей.Записать();
КонецПроцедуры

// Удалить из регистра сведений ФайлыВРабочемКаталоге запись о данной версии файла
// Параметры
//  Версия - СправочникСсылка.ВерсииФайлов - версия
Процедура УдалитьИзРегистра(Версия) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	НаборЗаписей = РегистрыСведений.ФайлыВРабочемКаталоге.СоздатьНаборЗаписей();
	
	НаборЗаписей.Отбор.Версия.Установить(Версия);
	НаборЗаписей.Отбор.Пользователь.Установить(Пользователи.ТекущийПользователь());
	
	НаборЗаписей.Записать();
КонецПроцедуры

// Удалить из регистра сведений ФайлыВРабочемКаталоге все записи, кроме записей о файлах занятых текущим пользователем
Процедура ОчиститьВсеСвоиКромеЗанятых() Экспорт
	// Отбираем все в регистре сведений. Перебираем - находим те, что не заняты текущим пользователем -
	//  и все удаляем - считаем, что на диске они уже удалены
	
	УстановитьПривилегированныйРежим(Истина);
	
	СписокУдалить = Новый Массив;
	ТекущийПользователь = Пользователи.ТекущийПользователь();

	// для каждой нашей записи находим запись в регистре сведений - оттуда берем поле Версия и Редактирует
	ЗапросВРегистр = Новый Запрос;
	ЗапросВРегистр.УстановитьПараметр("Пользователь", ТекущийПользователь);
	ЗапросВРегистр.Текст = "ВЫБРАТЬ 
	                       |	ФайлыВРабочемКаталоге.Версия КАК Версия,
	                       |	ФайлыВРабочемКаталоге.Версия.Владелец.Редактирует КАК Редактирует
	                       |ИЗ
	                       |	РегистрСведений.ФайлыВРабочемКаталоге КАК ФайлыВРабочемКаталоге
	                       |ГДЕ
	                       |	ФайлыВРабочемКаталоге.Пользователь = &Пользователь
						   |И   ФайлыВРабочемКаталоге.ВРабочемКаталогеВладельца = Ложь";
	
	РезультатЗапроса = ЗапросВРегистр.Выполнить(); 
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		
		Выборка = РезультатЗапроса.Выбрать();
		Пока Выборка.Следующий() Цикл
				
			Если Выборка.Редактирует <> ТекущийПользователь Тогда
				СписокУдалить.Добавить(Выборка.Версия);
			КонецЕсли;
			
		КонецЦикла;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	Для Каждого Версия из СписокУдалить Цикл
		// Создать набор записей
		НаборЗаписей = РегистрыСведений.ФайлыВРабочемКаталоге.СоздатьНаборЗаписей();
		
		НаборЗаписей.Отбор.Версия.Установить(Версия);
		НаборЗаписей.Отбор.Пользователь.Установить(ТекущийПользователь);
		
		НаборЗаписей.Записать();
	КонецЦикла;
КонецПроцедуры

// Удалить из регистра сведений ФайлыВРабочемКаталоге запись о старой версии и внести запись о новой
// Параметры
//  СтараяВерсия - СправочникСсылка.ВерсииФайлов - старая версия
//  НоваяВерсия - СправочникСсылка.ВерсииФайлов - новая версия
//  ПолноеИмяФайла - имя с путем в рабочем каталоге
//  ИмяКаталога - путь рабочего каталога
//  ВРабочемКаталогеВладельца - Булево - файл в рабочем каталоге владельца (а не в основном рабочем каталоге)
Процедура УдалитьВерсиюИЗанестиИнформациюФайлаВРегистр(СтараяВерсия, НоваяВерсия, ПолноеИмяФайла, ИмяКаталога, ВРабочемКаталогеВладельца)
	УдалитьИзРегистра(СтараяВерсия);
	НаЧтение = Истина;
	ЗанестиИнформациюФайлаВРегистр(НоваяВерсия, ПолноеИмяФайла, ИмяКаталога, НаЧтение, 0, ВРабочемКаталогеВладельца);
КонецПроцедуры

// Записать в регистр сведений ФайлыВРабочемКаталоге информацию о пути файла
//  Версия - СправочникСсылка.ВерсииФайлов - версия
//  ПолныйПуть - Строка - полный путь файла
//  ИмяКаталога - путь рабочего каталога
//  НаЧтение - Булево - файл помещен на чтение
//  РазмерФайла  - размер файла в байтах
//  ВРабочемКаталогеВладельца - Булево - файл в рабочем каталоге владельца (а не в основном рабочем каталоге)
Процедура ЗанестиИнформациюФайлаВРегистр(Версия, ПолныйПуть, ИмяКаталога, НаЧтение, РазмерФайла, ВРабочемКаталогеВладельца)  Экспорт
	ИмяФайлаСПутем = ПолныйПуть;
	
	Если ВРабочемКаталогеВладельца = Ложь Тогда
		ИмяКаталогаДляПроверки = ИмяКаталога;
		ФайловыеФункцииКлиентСервер.УдалитьСлешЕслиНужно(ИмяКаталогаДляПроверки);
		Если Найти(ПолныйПуть, ИмяКаталогаДляПроверки) = 1 Тогда
			ИмяФайлаСПутем = Сред(ПолныйПуть, СтрДлина(ИмяКаталогаДляПроверки) + 2);
		КонецЕсли;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	// Создать набор записей
	НаборЗаписей = РегистрыСведений.ФайлыВРабочемКаталоге.СоздатьНаборЗаписей();
	
	НаборЗаписей.Отбор.Версия.Установить(Версия.Ссылка);
	НаборЗаписей.Отбор.Пользователь.Установить(Пользователи.ТекущийПользователь());

	НоваяЗапись = НаборЗаписей.Добавить();
	НоваяЗапись.Версия = Версия.Ссылка;
	НоваяЗапись.Путь = ИмяФайлаСПутем;

	Если РазмерФайла <> 0 Тогда
		НоваяЗапись.Размер = РазмерФайла;
	Иначе 
		НоваяЗапись.Размер = Версия.Размер;
	КонецЕсли;

	НоваяЗапись.ДатаПомещенияВРабочийКаталог = ТекущаяДатаСеанса();
	НоваяЗапись.Пользователь = Пользователи.ТекущийПользователь();
	НоваяЗапись.НаЧтение = НаЧтение;
	НоваяЗапись.ВРабочемКаталогеВладельца = ВРабочемКаталогеВладельца;

	НаборЗаписей.Записать();
КонецПроцедуры

// Возвращает массив файлов в регистре сведений ФайлыВРабочемКаталоге
// Возвращаемое значение:
//   Массив - массив структур описывающих файлы
Функция СписокФайловВРегистре() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	СписокФайлов = Новый Массив;
	ТекущийПользователь = Пользователи.ТекущийПользователь();
	
	// Для каждой нашей записи находим запись в регистре сведений - оттуда берем поле Версия и Редактирует
	ЗапросВРегистр = Новый Запрос;
	ЗапросВРегистр.УстановитьПараметр("Пользователь", ТекущийПользователь);
	
	ЗапросВРегистр.Текст = 
	"ВЫБРАТЬ
	|	ФайлыВРабочемКаталоге.Версия КАК Версия,
	|	ФайлыВРабочемКаталоге.НаЧтение КАК НаЧтение,
	|	ФайлыВРабочемКаталоге.Размер КАК Размер,
	|	ФайлыВРабочемКаталоге.Путь КАК Путь
	|ИЗ
	|	РегистрСведений.ФайлыВРабочемКаталоге КАК ФайлыВРабочемКаталоге
	|ГДЕ
	|	ФайлыВРабочемКаталоге.Пользователь = &Пользователь
	|	И ФайлыВРабочемКаталоге.ВРабочемКаталогеВладельца = ЛОЖЬ
	|
	|УПОРЯДОЧИТЬ ПО
	|	ФайлыВРабочемКаталоге.Версия.ПолноеНаименование";
	
	РезультатЗапроса = ЗапросВРегистр.Выполнить(); 
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		
		Выборка = РезультатЗапроса.Выбрать();
		Пока Выборка.Следующий() Цикл
			Версия = Выборка.Версия;
			
			Запись = Новый Структура;
			Запись.Вставить("ДатаМодификацииУниверсальная", Версия.ДатаМодификацииУниверсальная);
			Запись.Вставить("ПолноеНаименование", Версия.ПолноеНаименование);
			Запись.Вставить("ИндексКартинки", Версия.ИндексКартинки);
			Запись.Вставить("Размер", Выборка.Размер);
			Запись.Вставить("Ссылка", Версия.Ссылка);
			Запись.Вставить("Редактирует", Версия.Владелец.Редактирует);
			Запись.Вставить("НаЧтение", Выборка.НаЧтение);
			Запись.Вставить("ЧастичныйПуть", Выборка.Путь);
			
			СписокФайлов.Добавить(Запись);
		КонецЦикла;
	КонецЕсли;
	
	Возврат СписокФайлов;
КонецФункции	

// Создать папку файлов
// Параметры
// Имя - Строка - имя папки
// Родитель - СправочникСсылка.ПапкиФайлов - родительская папка
// Пользователь - СправочникСсылка.Пользователи - ответственный за папку
//
// Возвращаемое значение:
//   СправочникСсылка.ПапкиФайлов
Функция СправочникиПапкиСоздатьЭлемент(Имя, Родитель, Пользователь = Неопределено) Экспорт
	Папка = Справочники.ПапкиФайлов.СоздатьЭлемент();
	Папка.Наименование = Имя;
	Папка.Родитель = Родитель;
	Папка.ДатаСоздания = ТекущаяДатаСеанса();
	
	Если Пользователь = Неопределено Тогда
		Папка.Ответственный = Пользователи.ТекущийПользователь();
	Иначе	
		Папка.Ответственный = Пользователь;
	КонецЕсли;	
	
	Папка.Записать();
	Возврат Папка.Ссылка;
КонецФункции

// Формирует отчет для файлов с ошибками
// Параметры
// МассивИменФайловСОшибками - массив строк путей к файлам
//
// Возвращаемое значение:
//   ТабличныйДокумент с отчетом
Функция ИмпортФайловСформироватьОтчет(МассивИменФайловСОшибками) Экспорт
	ТабДок = Новый ТабличныйДокумент;
	ТабМакет = Справочники.Файлы.ПолучитьМакет("МакетОтчета");
	
	ОбластьЗаголовок = ТабМакет.ПолучитьОбласть("Заголовок");
	ОбластьЗаголовок.Параметры.Описание = "Файлы с ошибками:";
	ТабДок.Вывести(ОбластьЗаголовок);
	
	ОбластьСтрока = ТабМакет.ПолучитьОбласть("Строка");

	Для Каждого Выборка Из МассивИменФайловСОшибками Цикл
		ОбластьСтрока.Параметры.Название = Выборка.ИмяФайла;
		ОбластьСтрока.Параметры.Ошибка = Выборка.Ошибка;
		ТабДок.Вывести(ОбластьСтрока);
	КонецЦикла; 	
	
	Отчет = Новый ТабличныйДокумент;
	Отчет.Вывести(ТабДок);

	Возврат Отчет;
КонецФункции

// Сортирует массив структур по полю Дата - на сервере, т.к. на тонком клиенте нет ТаблицаЗначений
// Параметры
// МассивСтруктур - массив структур описаний файлов
Процедура СортироватьМассивСтруктур(МассивСтруктур) Экспорт
	
	ТаблицаФайлов = Новый ТаблицаЗначений;
	ТаблицаФайлов.Колонки.Добавить("Путь");
	ТаблицаФайлов.Колонки.Добавить("Версия");
	ТаблицаФайлов.Колонки.Добавить("Размер");
	ТаблицаФайлов.Колонки.Добавить("ДатаПомещенияВРабочийКаталог", Новый ОписаниеТипов("Дата"));
	
	Для Каждого Строка из МассивСтруктур Цикл
		
		НоваяСтрока = ТаблицаФайлов.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка, 
			"Путь, Размер, Версия, ДатаПомещенияВРабочийКаталог");
		
		
		//  будет самой старой - и удалится при очистке из рабочего каталога самых старых файлов
		ДатаПомещения = Дата('00010101');
		
		Версия = Неопределено;
		Владелец = Неопределено;
		НомерВерсии = Неопределено;
		ВРегистреНаЧтение = Неопределено;
		ВРегистреКодФайла = Неопределено;
		ВРегистреПапка = Неопределено;
		ФайлЕстьВРегистре = НайтиВРегистреПоПути(НоваяСтрока.Путь, Версия, ДатаПомещения, Владелец, НомерВерсии, 
			ВРегистреНаЧтение, ВРегистреКодФайла, ВРегистреПапка);
			
		НоваяСтрока.Версия = Версия;
		НоваяСтрока.ДатаПомещенияВРабочийКаталог = ДатаПомещения;
			
		Если ФайлЕстьВРегистре Тогда
				
			РедактируетТекущийПользователь = ПолучитьРедактируетТекущийПользователь(Версия);
			Если РедактируетТекущийПользователь Тогда // удалим из списка - т.е. не будем удалять из кеша	
				ТаблицаФайлов.Удалить(НоваяСтрока);
			КонецЕсли;
			
		КонецЕсли;
			
	КонецЦикла;
	
	// Сортировка по дате - в начале будут самые давно помещенные в рабочий каталог
	ТаблицаФайлов.Сортировать("ДатаПомещенияВРабочийКаталог Возр");  
	
	МассивСтруктурВозврат = Новый Массив;
	
	Для Каждого Строка из ТаблицаФайлов Цикл
		Запись = Новый Структура;
		Запись.Вставить("Путь", Строка.Путь);
		Запись.Вставить("Размер", Строка.Размер);
		Запись.Вставить("Версия", Строка.Версия);
		Запись.Вставить("ДатаПомещенияВРабочийКаталог", Строка.ДатаПомещенияВРабочийКаталог);
		МассивСтруктурВозврат.Добавить(Запись);
	КонецЦикла;			
	
	МассивСтруктур = МассивСтруктурВозврат;	
КонецПроцедуры // СортироватьМассивСтруктур()

// Удаляет массив версий из регистра
Процедура УдалитьМассивВерсийИзРегистра(МассивДляУдаленияИзРегистра) Экспорт
	
	Для Каждого Описание Из МассивДляУдаленияИзРегистра Цикл
		УдалитьИзРегистра(Описание.Версия);
	КонецЦикла;	
	
КонецПроцедуры	

// Возвращает настройку - Спрашивать режим редактирования при открытии файла
// Возвращаемое значение:
//   Булево - Спрашивать режим редактирования при открытии файла
Функция СпрашиватьРежимРедактированияПриОткрытииФайла()
	СпрашиватьРежимРедактированияПриОткрытииФайла = 
		ХранилищеОбщихНастроек.Загрузить("НастройкиОткрытияФайлов", "СпрашиватьРежимРедактированияПриОткрытииФайла");
	Если СпрашиватьРежимРедактированияПриОткрытииФайла = Неопределено Тогда
		СпрашиватьРежимРедактированияПриОткрытииФайла = Истина;
		ХранилищеОбщихНастроек.Сохранить("НастройкиОткрытияФайлов", "СпрашиватьРежимРедактированияПриОткрытииФайла", СпрашиватьРежимРедактированияПриОткрытииФайла);
	КонецЕсли;
	
	Возврат СпрашиватьРежимРедактированияПриОткрытииФайла;
КонецФункции	
	
// Считаем ДействиеПоДвойномуЩелчкуМыши - если первый раз - поставим правильное значение
//
// Возвращаемое значение:
//   Строка - Действие по двойному щелчку мыши
Функция ДействиеПоДвойномуЩелчкуМыши()
	КакОткрывать = ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить("НастройкиОткрытияФайлов", "ДействиеПоДвойномуЩелчкуМыши");
	
	Если КакОткрывать = Неопределено Или КакОткрывать = Перечисления.ДействияСФайламиПоДвойномуЩелчку.ПустаяСсылка() Тогда
		КакОткрывать = Перечисления.ДействияСФайламиПоДвойномуЩелчку.ОткрыватьФайл;
		ОбщегоНазначения.ХранилищеОбщихНастроекСохранить("НастройкиОткрытияФайлов", "ДействиеПоДвойномуЩелчкуМыши", КакОткрывать);
	КонецЕсли;
	
	Если КакОткрывать = Перечисления.ДействияСФайламиПоДвойномуЩелчку.ОткрыватьФайл Тогда
		Возврат "ОткрыватьФайл";
	Иначе
		Возврат "ОткрыватьКарточку";
	КонецЕсли;
КонецФункции

// Считаем из настроек СпособСравненияВерсийФайлов
//
// Возвращаемое значение:
//   Строка - Способ сравнения версий файлов
Функция СпособСравненияВерсийФайлов()
	СпособСравнения = ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить("НастройкиСравненияФайлов", "СпособСравненияВерсийФайлов");
	
	Если СпособСравнения = Перечисления.СпособыСравненияВерсийФайлов.MicrosoftOfficeWord Тогда
		Возврат "MicrosoftOfficeWord";
	ИначеЕсли СпособСравнения = Перечисления.СпособыСравненияВерсийФайлов.OpenOfficeOrgWriter Тогда
		Возврат "OpenOfficeOrgWriter";
	Иначе
		Возврат Неопределено;
	КонецЕсли;
КонецФункции

// Функция возвращает количество Файлов, занятых текущим пользователем
// в разрезе владельца
// Параметры
//  ВладелецФайла  - ЛюбаяСсылка - владелец файла
//
// Возвращаемое значение:
//   Число  - количество занятых файлов
Функция КоличествоЗанятыхФайлов(ВладелецФайла) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	КОЛИЧЕСТВО(*) КАК Количество
		|ИЗ
		|	Справочник.Файлы КАК Файлы
		|ГДЕ
		|	Файлы.Редактирует = &Редактирует
		|	И Файлы.ВладелецФайла = &Владелец";
	
	Запрос.УстановитьПараметр("Редактирует", Пользователи.ТекущийПользователь());
	Запрос.УстановитьПараметр("Владелец", ВладелецФайла);
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Результат = Выборка.Количество;
	
	Возврат Результат;
КонецФункции

// Получает значение настройки  ПоказыватьКолонкуРазмер
// Возвращаемое значение:
//   Булево - Показывать колонку размер
Функция ПолучитьПоказыватьКолонкуРазмер() Экспорт
	ПоказыватьКолонкуРазмер = ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить("НастройкиПрограммы", "ПоказыватьКолонкуРазмер");
	Если ПоказыватьКолонкуРазмер = Неопределено Тогда
		ПоказыватьКолонкуРазмер = Ложь;
		ОбщегоНазначения.ХранилищеОбщихНастроекСохранить("НастройкиПрограммы", "ПоказыватьКолонкуРазмер", ПоказыватьКолонкуРазмер);
	КонецЕсли;
	
	Возврат ПоказыватьКолонкуРазмер;
КонецФункции	
	
// Функция меняет ВладелецФайла объектам типа Справочник.Файл, вернет Истина при успехе
// Параметры
//  МассивСсылокНаФайлы - Массив - массив файлов
//  НовыйВладелецФайла  - ЛюбаяСсылка - новый владелец файла
//
// Возвращаемое значение:
//   Булево  - успешно ли выполнена операция
Функция УстановитьВладельцаФайла(МассивСсылокНаФайлы, НовыйВладелецФайла) Экспорт
	
	Если МассивСсылокНаФайлы.Количество() = 0 Или Не ЗначениеЗаполнено(НовыйВладелецФайла) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ПрежнийВладелец = МассивСсылокНаФайлы[0].ВладелецФайла;
	
	// тот же родитель - ничего делать не надо
	Если (ПрежнийВладелец = НовыйВладелецФайла) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// другой тип владельца - скажем было письмо, стала папка файлов - нужно копировать, а не перемещать
	Если ТипЗнч(НовыйВладелецФайла) <> ТипЗнч(ПрежнийВладелец) Тогда 
		
		ХранитьВерсии = Истина;
		СкопироватьФайлы(МассивСсылокНаФайлы, НовыйВладелецФайла, ХранитьВерсии);
		ВыполненноеДействие = "Копирование";
		Возврат Истина;
		
	КонецЕсли;	
	
	СтараяПапка = МассивСсылокНаФайлы[0].ВладелецФайла;
	Если Не ДокументооборотПраваДоступа.ПолучитьПраваПоОбъекту(МассивСсылокНаФайлы[0]).Изменение Тогда
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		                     НСтр("ru = 'У вас нет права на изменение файлов в папке ""%1"".'"),
		                     Строка(СтараяПапка));
	КонецЕсли;	
	
	НачатьТранзакцию();
	Попытка
	
		Для Каждого ФайлПринятый Из МассивСсылокНаФайлы Цикл
			
			ПрежнийВладелец = ФайлПринятый.ВладелецФайла; 
			
			ФайлОбъект = ФайлПринятый.ПолучитьОбъект();
			ФайлОбъект.Заблокировать();
			ФайлОбъект.ВладелецФайла = НовыйВладелецФайла;
			ФайлОбъект.Записать();
			
			ПротоколированиеРаботыПользователей.ЗаписатьПеремещениеФайла(ФайлПринятый, ПрежнийВладелец, НовыйВладелецФайла);
		КонецЦикла;
	
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат Истина;
КонецФункции

// Вернет Истина если есть зацикливание (если одну из папок переносим в ее же дочернюю папку)
// Параметры
//  МассивСсылокНаФайлы - Массив - массив файлов
//  НовыйРодитель  - ЛюбаяСсылка - новый владелец файла
//
// Возвращаемое значение:
//   Булево  - есть зацикливание
Функция ЕстьЗацикливание(Знач МассивСсылокНаФайлы, НовыйРодитель)
	
	Если МассивСсылокНаФайлы.Найти(НовыйРодитель) <> Неопределено Тогда
		Возврат Истина; // нашли зацикливание
	КонецЕсли;
	
	Родитель = НовыйРодитель.Родитель;
	Если Родитель.Пустая() Тогда // дошли до корня
		Возврат Ложь;
	КонецЕсли;
	
	Если ЕстьЗацикливание(МассивСсылокНаФайлы, Родитель) = Истина Тогда
		Возврат Истина; // нашли зацикливание
	КонецЕсли;
	
	Возврат Ложь;
КонецФункции

// Функция меняет свойство Родитель объектам типа Справочник.ПапкиФайла, вернет Истина при успехе, 
// в переменной НайденоЗацикливание вернет Истина, если одну из папок переносим в ее же дочернюю папку
//
// Параметры
//  МассивСсылокНаФайлы - Массив - массив файлов
//  НовыйРодитель  - ЛюбаяСсылка - новый владелец файла
//  НайденоЗацикливание - Булево - возвращает Истина, если найдено зацикливание
//
// Возвращаемое значение:
//   Булево  - успешно ли выполнена операция
Функция СменитьРодителяПапок(МассивСсылокНаФайлы, НовыйРодитель, НайденоЗацикливание) Экспорт
	НайденоЗацикливание = Ложь;
	
	Если МассивСсылокНаФайлы.Количество() = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// тот же родитель - ничего делать не надо
	Если МассивСсылокНаФайлы.Количество() = 1 И (МассивСсылокНаФайлы[0].Родитель = НовыйРодитель) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ЕстьЗацикливание(МассивСсылокНаФайлы, НовыйРодитель) Тогда
		НайденоЗацикливание = Истина;
		Возврат Ложь;
	КонецЕсли;
	
	НачатьТранзакцию();
	Попытка
	
		Для Каждого ФайлПринятый Из МассивСсылокНаФайлы Цикл
			ФайлОбъект = ФайлПринятый.ПолучитьОбъект();
			ФайлОбъект.Заблокировать();
			ФайлОбъект.Родитель = НовыйРодитель;
			ФайлОбъект.Записать();
		КонецЦикла;
	
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат Истина;
КонецФункции

// Вернет Истина, если в указанном элементе справочника ПапкиФайлов есть дочерний элемент с таким именем
// Параметры
//  ИмяФайла  - имя папки
//  Родитель - СправочникСсылка.ПапкиФайлов - Родитель папки
//  ПерваяПапкаСТакимЖеИменем - СправочникСсылка.ПапкиФайлов - первая же найденная папка с указанным именем
//
// Возвращаемое значение:
//   Булево  - есть дочерний элемент с таким именем
Функция ЕстьПапкаСТакимИменем(ИмяФайла, Родитель, ПерваяПапкаСТакимЖеИменем) Экспорт
	
	ПерваяПапкаСТакимЖеИменем = Справочники.ПапкиФайлов.ПустаяСсылка();
	
	ЗапросВПапки = Новый Запрос;
	ЗапросВПапки.УстановитьПараметр("Наименование", ИмяФайла);
	ЗапросВПапки.УстановитьПараметр("Родитель", Родитель);
	ЗапросВПапки.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	                     |	ПапкиФайлов.Ссылка КАК Ссылка
	                     |ИЗ
	                     |	Справочник.ПапкиФайлов КАК ПапкиФайлов
	                     |ГДЕ
	                     |	ПапкиФайлов.Наименование = &Наименование
	                     |	И ПапкиФайлов.Родитель = &Родитель
	                     |	И ПапкиФайлов.ПометкаУдаления = ЛОЖЬ";
	
	РезультатЗапроса = ЗапросВПапки.Выполнить(); 
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		ВыборкаЗапроса = РезультатЗапроса.Выгрузить();
		ПерваяПапкаСТакимЖеИменем = ВыборкаЗапроса[0].Ссылка;
		Возврат Истина;
	КонецЕсли;
	
	
	Возврат Ложь;
КонецФункции

// Вернет Истина, если в указанном элементе справочника Файлы есть файл с таким именем
// Параметры
//  ИмяФайла  - имя файла
//  Родитель - ЛюбаяСсылка - владелец файла
//  ПерваяПапкаСТакимЖеИменем - СправочникСсылка.ПапкиФайлов - первая же найденная папка с указанным именем
//
// Возвращаемое значение:
//   Булево  - есть дочерний элемент с таким именем
Функция ЕстьФайлСТакимИменем(ИмяФайла, Родитель) Экспорт
	
	ЗапросВПапки = Новый Запрос;
	ЗапросВПапки.УстановитьПараметр("Наименование", ИмяФайла);
	ЗапросВПапки.УстановитьПараметр("Родитель", Родитель);
	ЗапросВПапки.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	                     |	Файлы.Ссылка КАК Ссылка
	                     |ИЗ
	                     |	Справочник.Файлы КАК Файлы
	                     |ГДЕ
	                     |	Файлы.ПолноеНаименование = &Наименование
	                     |	И Файлы.ВладелецФайла = &Родитель";
	
	РезультатЗапроса = ЗапросВПапки.Выполнить(); 
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		Возврат Истина;
	КонецЕсли;
	
	
	Возврат Ложь;
КонецФункции

// Получает список найденных по владельцу элементов справочника "Файлы" на основании переданного массива имен
// Параметры
//   ИменаФайлов - строка, массив строк
//	 Владелец - ссылка на владельца файла
// Возвращаемое значение:
//   Соответствие: Ключ - полное имя файла, Значение - ссылка
Функция НайтиФайлыПоПолнымИменам(ИменаФайлов, Владелец) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	Файлы.Ссылка,
		|	Файлы.ПолноеНаименование
		|ИЗ
		|	Справочник.Файлы КАК Файлы
		|ГДЕ
		|	Файлы.ВладелецФайла = &Владелец
		|	И Файлы.ПолноеНаименование В(&МассивИмен)
		|	И НЕ Файлы.ПометкаУдаления";
		
	Запрос.УстановитьПараметр("Владелец", Владелец);
	Запрос.УстановитьПараметр("МассивИмен", ИменаФайлов);
	
	Выборка = Запрос.Выполнить().Выбрать();

	Результат = Новый Соответствие;
	Пока Выборка.Следующий() Цикл
		Результат.Вставить(Выборка.ПолноеНаименование, Выборка.Ссылка);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Получает список найденных по владельцу элементов справочника "Файлы" на основании переданного массива
//   структур имен и расширений
// Параметры
//   ДанныеФайловДляПоиска - массив структур с наименованиями и расширениями
//	 Владелец - ссылка на владельца файла
// Возвращаемое значение:
//   Соответствие: Ключ - полное имя файла, Значение - ссылка
Функция НайтиФайлыПоПолнымИменамСРасширением(ДанныеФайловДляПоиска, Владелец) Экспорт
	
	ТаблицаОтбора = Новый ТаблицаЗначений;
	ТипСтрока = Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки(500));
	ТаблицаОтбора.Колонки.Добавить("ПолноеНаименование", ТипСтрока);
	ТаблицаОтбора.Колонки.Добавить("ТекущаяВерсияРасширение", ТипСтрока);
	
	Для Каждого Эл Из ДанныеФайловДляПоиска Цикл
		ЗаполнитьЗначенияСвойств(ТаблицаОтбора.Добавить(), Эл);
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	Файлы.Ссылка,
		|	Файлы.ПолноеНаименование,
		|	Файлы.ТекущаяВерсияРасширение
		|ИЗ
		|	Справочник.Файлы КАК Файлы
		|ГДЕ
		|	Файлы.ВладелецФайла = &Владелец
		|	И (Файлы.ПолноеНаименование, Файлы.ТекущаяВерсияРасширение) В (&ТаблицаОтбора)
		|	И НЕ Файлы.ПометкаУдаления";
		
	Запрос.УстановитьПараметр("Владелец", Владелец);
	Запрос.УстановитьПараметр("ТаблицаОтбора", ТаблицаОтбора);
	
	Выборка = Запрос.Выполнить().Выбрать();

	Результат = Новый Соответствие;
	Пока Выборка.Следующий() Цикл
		
		ИмяСРасширением = Выборка.ПолноеНаименование; 
		Если ЗначениеЗаполнено(Выборка.ТекущаяВерсияРасширение) Тогда
			ИмяСРасширением = ИмяСРасширением + "." + Выборка.ТекущаяВерсияРасширение;
		КонецЕсли;
			
		Результат.Вставить(ИмяСРасширением, Выборка.Ссылка);
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Получает список файлов указанного владельца с отбором по полным наименованиям файлов из переданного массива
Функция СписокОбновляемыхФайлов(Файлы, ВладелецФайла) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
		|	Файлы.Ссылка,
		|	Файлы.ПолноеНаименование
		|ПОМЕСТИТЬ ВТ_Источники
		|ИЗ
		|	Справочник.Файлы КАК Файлы
		|ГДЕ
		|	Файлы.Ссылка В(&МассивИсточников)
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	ВТ_Источники.Ссылка КАК Источник,
		|	Файлы.Ссылка КАК Приемник
		|ИЗ
		|	Справочник.Файлы КАК Файлы
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ВТ_Источники КАК ВТ_Источники
		|		ПО Файлы.ПолноеНаименование = ВТ_Источники.ПолноеНаименование
		|ГДЕ
		|	Файлы.ВладелецФайла = &Владелец";
		
	Запрос.УстановитьПараметр("Владелец", ВладелецФайла);
	Запрос.УстановитьПараметр("МассивИсточников", Файлы);
	
	Выборка = Запрос.Выполнить().Выбрать();

	Результат = Новый Соответствие;
	Пока Выборка.Следующий() Цикл
		Результат.Вставить(Выборка.Источник, Выборка.Приемник);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// в справочнике ВерсииФайлов из данных в Код(Строка) заполняет НомерВерсии(Число)
Процедура ЗаполнитьНомерВерсииИзКодаСправочника() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ВерсииФайлов.Ссылка
		|ИЗ
		|	Справочник.ВерсииФайлов КАК ВерсииФайлов";

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		
		Объект = Выборка.Ссылка.ПолучитьОбъект();
		
		Если Объект.НомерВерсии = 0 Тогда 
		
			// коррекция ситуации, допустимой ранее, но недопустимой сейчас - активная версия помечена на удаление, а владелец - нет
			Если Объект.ПометкаУдаления = Истина И Объект.Владелец.ПометкаУдаления = Ложь И Объект.Владелец.ТекущаяВерсия = Объект.Ссылка Тогда
				Объект.ПометкаУдаления = Ложь;
			КонецЕсли;
			
			Попытка
				Объект.НомерВерсии = Число(Объект.Код);
				Объект.Записать();
			Исключение // код например с префиксом базы - не используем. Это не ошибка  - т.к. только в старых версиях конфигурации
			КонецПопытки;
			
		КонецЕсли;
	
	КонецЦикла;
		
КонецПроцедуры	

// в справочнике ВерсииФайлов заполняет ТипХраненияФайла значением ВБазе
Процедура ЗаполнитьТипХраненияФайлаВБазе() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ВерсииФайлов.Ссылка
		|ИЗ
		|	Справочник.ВерсииФайлов КАК ВерсииФайлов";

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Объект = Выборка.Ссылка.ПолучитьОбъект();
		
		Если Объект.ТипХраненияФайла.Пустая() Тогда
			Объект.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе;
			Объект.Записать();
		КонецЕсли;
		
	КонецЦикла;
		
КонецПроцедуры	

// Для справочника ВерсииФайлов переименует файл на диске, если ТипХраненияФайла = ВТомахНаДиске
// Параметры
//  Версия  - СправочникСсылка.ВерсииФайлов - версия файла
//  СтароеНаименование - Строка - старое наименование
//  НовоеНаименование - Строка - новое наименование
Процедура ПереименоватьФайлВерсииНаДиске(Версия, СтароеНаименование, НовоеНаименование,
	УникальныйИдентификатор = Неопределено) Экспорт
	
	Если НЕ Версия.Том.Пустая() Тогда
		Попытка
			ВерсияОбъект = Версия.ПолучитьОбъект();
			ЗаблокироватьДанныеДляРедактирования(Версия, , УникальныйИдентификатор);
			
			СтарыйПолныйПуть = ФайловыеФункции.ПолныйПутьТома(Версия.Том) + Версия.ПутьКФайлу; 
			
			ФайлНаДиске = Новый Файл(СтарыйПолныйПуть);
			ПолныйПуть = ФайлНаДиске.Путь;
			ИмяБезРасширения = ФайлНаДиске.ИмяБезРасширения;
			Расширение = ФайлНаДиске.Расширение;
			НовоеИмяБезРасширения = СтрЗаменить(ИмяБезРасширения, СтароеНаименование, НовоеНаименование);
			
			НовыйПолныйПуть = ПолныйПуть + НовоеИмяБезРасширения + Расширение;
			ПолныйПутьКТому = ФайловыеФункции.ПолныйПутьТома(Версия.Том);
			НовыйЧастичныйПуть = Прав(НовыйПолныйПуть, СтрДлина(НовыйПолныйПуть) - СтрДлина(ПолныйПутьКТому));
		
			ПереместитьФайл(СтарыйПолныйПуть, НовыйПолныйПуть);
			ВерсияОбъект.ПутьКФайлу = НовыйЧастичныйПуть;
			ВерсияОбъект.Записать();
			РазблокироватьДанныеДляРедактирования(Версия, УникальныйИдентификатор);
		Исключение
		КонецПопытки;
	КонецЕсли;
КонецПроцедуры	

// в справочнике ВерсииФайлов и Файлы ИндексКартинки увеличивает в 2 раза
Процедура СменитьИндексПиктограммы() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ВерсииФайлов.Ссылка
		|ИЗ
		|	Справочник.ВерсииФайлов КАК ВерсииФайлов";

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Объект = Выборка.Ссылка.ПолучитьОбъект();
		Объект.ОбменДанными.Загрузка = Истина;
		Объект.ИндексКартинки = ФайловыеФункцииКлиентСервер.ПолучитьИндексПиктограммыФайла(Объект.Расширение);
		Объект.Записать();
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	Файлы.Ссылка
		|ИЗ
		|	Справочник.Файлы КАК Файлы";

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Объект = Выборка.Ссылка.ПолучитьОбъект();
		Объект.ОбменДанными.Загрузка = Истина;
		Объект.ИндексКартинки = Объект.ТекущаяВерсия.ИндексКартинки;
		Объект.Записать();
	КонецЦикла;	
	
КонецПроцедуры	

// Возвращает количество занятых файлов
// Параметры
// ВладельцыФайлов - ЛюбаяСсылка, Массив ссылок - владельцы файлов
// Редактирует - СправочникСсылка.Пользователи - ссылка на пользователя, занявшего файл
// 
// Возвращаемое значение:
//   Число  - число занятых файлов
Функция ПолучитьКоличествоЗанятыхФайлов(ВладельцыФайлов = Неопределено, Редактирует = Неопределено) Экспорт
	
	Если НЕ ПравоДоступа("Чтение", Метаданные.Справочники.Файлы) Тогда
		Возврат 0;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	КОЛИЧЕСТВО(*) КАК Количество
	|ИЗ
	|	Справочник.Файлы КАК Файлы
	|ГДЕ
	|	Файлы.Редактирует <> ЗНАЧЕНИЕ(Справочник.Пользователи.ПустаяСсылка)";
	
	Если Редактирует <> Неопределено Тогда 
		Запрос.Текст = Запрос.Текст + " И Файлы.Редактирует = &Редактирует ";
		Запрос.УстановитьПараметр("Редактирует", Редактирует);
	КонецЕсли;
	
	Если ВладельцыФайлов <> Неопределено Тогда
		Если ТипЗнч(ВладельцыФайлов) = Тип("Массив") Тогда
			Запрос.Текст = Запрос.Текст + " И Файлы.ВладелецФайла В (&ВладельцыФайлов)";
			Запрос.УстановитьПараметр("ВладельцыФайлов", ВладельцыФайлов);
		Иначе
			Запрос.Текст = Запрос.Текст + " И Файлы.ВладелецФайла = &ВладельцыФайлов ";
			Запрос.УстановитьПараметр("ВладельцыФайлов", ВладельцыФайлов);
		КонецЕсли;	
	КонецЕсли;    
	
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Возврат Выборка.Количество;
	
КонецФункции

// Помечает / снимает пометку удаления у приложенных файлов.
//
Процедура ПометитьНаУдалениеПриложенныеФайлы(ВладелецФайла, ПометкаУдаления) Экспорт 
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	Файлы.Ссылка КАК Ссылка,
		|	Файлы.Редактирует КАК Редактирует,
		|	Файлы.ПодписанЭП КАК ПодписанЭП
		|ИЗ
		|	Справочник.Файлы КАК Файлы
		|ГДЕ
		|	Файлы.ВладелецФайла = &ВладелецФайла";
	
	Запрос.УстановитьПараметр("ВладелецФайла", ВладелецФайла);
	
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	
	ВладелецФайлаДокумент = ДелопроизводствоКлиентСервер.ЭтоДокумент(ВладелецФайла);
	
	Пока Выборка.Следующий() Цикл
		Если ПометкаУдаления И Не Выборка.Редактирует.Пустая() Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = '""%1"" не может быть удален, т.к. содержит файл ""%2"", занятый для редактирования.'"),
				Строка(ВладелецФайла),
				Строка(Выборка.Ссылка));
		КонецЕсли;
			
		Если ВладелецФайлаДокумент И Выборка.ПодписанЭП Тогда
			
			НачатьТранзакцию();
			Попытка
				ФайлОбъект = Выборка.Ссылка.ПолучитьОбъект();
				ФайлОбъект.Заблокировать();
				ФайлОбъект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина);
				ФайлОбъект.УстановитьПометкуУдаления(ПометкаУдаления, Ложь);
				ФайлОбъект.Разблокировать();
				
				ЗапросВерсий = Новый Запрос;
				ЗапросВерсий.Текст = 
					"ВЫБРАТЬ РАЗРЕШЕННЫЕ
					|	ВерсииФайлов.Ссылка КАК Ссылка
					|ИЗ
					|	Справочник.ВерсииФайлов КАК ВерсииФайлов
					|ГДЕ
					|	ВерсииФайлов.Владелец = &Файл";
				ЗапросВерсий.УстановитьПараметр("Файл", ФайлОбъект.Ссылка);
				РезультатВерсий = ЗапросВерсий.Выполнить();
				ВыборкаВерсий = РезультатВерсий.Выбрать();
				Пока ВыборкаВерсий.Следующий() Цикл
					ВерсияФайлаОбъект = ВыборкаВерсий.Ссылка.ПолучитьОбъект();
					ВерсияФайлаОбъект.Заблокировать();
					ВерсияФайлаОбъект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина);
					ВерсияФайлаОбъект.УстановитьПометкуУдаления(ПометкаУдаления);
					ВерсияФайлаОбъект.Разблокировать();
				КонецЦикла;
				
				ЗафиксироватьТранзакцию();
			Исключение
				ОтменитьТранзакцию();
				ИнформацияОбОшибке = ИнформацияОбОшибке();
				ВызватьИсключение(КраткоеПредставлениеОшибки(ИнформацияОбОшибке));
			КонецПопытки;
			
		Иначе
			ФайлОбъект = Выборка.Ссылка.ПолучитьОбъект();
			ФайлОбъект.Заблокировать();
			ФайлОбъект.УстановитьПометкуУдаления(ПометкаУдаления);
			ФайлОбъект.Разблокировать();
		КонецЕсли;
	
	КонецЦикла;
	
КонецПроцедуры

// Помечает / снимает пометку удаления у писем в папке.
//
Процедура ПометитьНаУдалениеПисьмаВПапке(Папка, ПометкаУдаления) Экспорт 
	
	Запрос = Новый Запрос(
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	ЭлектроннаяПочта.Ссылка
		|ИЗ
		|	ЖурналДокументов.ЭлектроннаяПочта КАК ЭлектроннаяПочта
		|ГДЕ
		|	ЭлектроннаяПочта.Ссылка.Папка = &Папка
		|	И ЭлектроннаяПочта.Ссылка.ПометкаУдаления = &ПометкаУдаления");
	Запрос.УстановитьПараметр("Папка", Папка);
	Запрос.УстановитьПараметр("ПометкаУдаления", Не ПометкаУдаления);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		ПисьмоОбъект = Выборка.Ссылка.ПолучитьОбъект();
		ПисьмоОбъект.Заблокировать();
		ПисьмоОбъект.УстановитьПометкуУдаления(ПометкаУдаления);
	КонецЦикла;
	
КонецПроцедуры

// Получает данные для переноса файла из одного списка приложенных файлов в другой
// Параметры
// ФайлМассив - массив ссылок на файлы или СправочникСсылка.Файлы
// ВладелецФайла - ЛюбаяСсылка - владелец файла
//
// Возвращаемое значение:
//   ТаблицаЗначений - описания файлов
Функция ПолучитьДанныеДляПереносаВПриложенныеФайлы(ФайлМассив, ВладелецФайла) Экспорт

	Если ТипЗнч(ФайлМассив) = Тип("Массив") Тогда 
		МассивФайлов = ФайлМассив;
	Иначе
		МассивФайлов = Новый Массив;
		МассивФайлов.Добавить(ФайлМассив);
	КонецЕсли;	
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Файлы.Ссылка КАК Ссылка,
	|	Файлы.ПолноеНаименование КАК ПолноеНаименование
	|ИЗ
	|	Справочник.Файлы КАК Файлы
	|ГДЕ
	|	Файлы.ВладелецФайла = &ВладелецФайла";
	Запрос.УстановитьПараметр("ВладелецФайла", ВладелецФайла);
	ТаблРезультат = Запрос.Выполнить().Выгрузить();
	
	Результат = Новый Соответствие;
	Для Каждого ФайлСсылка Из МассивФайлов Цикл
		
		Если ТаблРезультат.Найти(ФайлСсылка, "Ссылка") <> Неопределено Тогда 
			Результат.Вставить(ФайлСсылка, "Пропустить");
		ИначеЕсли ТаблРезультат.Найти(ФайлСсылка.ПолноеНаименование, "ПолноеНаименование") <> Неопределено Тогда 
			Результат.Вставить(ФайлСсылка, "Обновить");
		Иначе 	
			Результат.Вставить(ФайлСсылка, "Скопировать");
		КонецЕсли;	
		
	КонецЦикла;	
	
	Возврат Результат;
	
КонецФункции	

// копирует файлы при переносе из одного списка приложенных файлов в другой
// Параметры
// ФайлМассив - массив ссылок на файлы или СправочникСсылка.Файлы
// ВладелецФайла - ЛюбаяСсылка - владелец файла
//
// Возвращаемое значение:
//   СправочникСсылка.Файлы - скопированный файл
Функция СкопироватьФайлВПриложенных(ФайлМассив, ВладелецФайла) Экспорт
	
	Если ТипЗнч(ФайлМассив) = Тип("Массив") Тогда 
		МассивФайлов = ФайлМассив;
	Иначе
		МассивФайлов = Новый Массив;
		МассивФайлов.Добавить(ФайлМассив);
	КонецЕсли;
	
	Для Каждого ФайлСсылка Из МассивФайлов Цикл
		Источник = ФайлСсылка;
		
		Приемник = СоздатьФайл(
				ВладелецФайла,
				Источник.Описание,
				Источник.ПолноеНаименование,
				Источник.ХранитьВерсии,
				"");
		
		Если Не Источник.ТекущаяВерсия.Пустая() Тогда
			
			ХранилищеФайла = Неопределено;
			Если Источник.ТекущаяВерсия.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда 
				ХранилищеФайла = ПолучитьХранилищеФайлаИзИнформационнойБазы(Источник.ТекущаяВерсия);
			КонецЕсли;	
					
			Версия = СоздатьВерсию(
				ТекущаяДата(),
				РаботаСФайламиКлиентСервер.ПолучитьУниверсальноеВремя(ТекущаяДата()),
				Приемник,
				Приемник.Наименование,
				Источник.ТекущаяВерсия.Размер,
				Источник.ТекущаяВерсия.Расширение,
				ХранилищеФайла,
				Источник.ТекущаяВерсия.ТекстХранилище,
				Ложь,
				Источник.ТекущаяВерсия);
			
			ОбновитьВерсиюВФайле(Приемник, Версия, Источник.ТекущаяВерсия.ТекстХранилище);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Приемник;
	
КонецФункции

// Обновляет версии одноименных файлов при переносе из одного списка приложенных файлов в другой
// Параметры
// ФайлМассив - массив ссылок на файлы или СправочникСсылка.Файлы
// ВладелецФайла - ЛюбаяСсылка - владелец файла
//
// Возвращаемое значение:
//   СправочникСсылка.Файлы - скопированный файл
Функция ОбновитьФайлВПриложенных(ФайлМассив, Приемники, ВладелецФайла) Экспорт
	
	Если ТипЗнч(ФайлМассив) = Тип("Массив") Тогда 
		МассивФайлов = ФайлМассив;
	Иначе
		МассивФайлов = Новый Массив;
		МассивФайлов.Добавить(ФайлМассив);
	КонецЕсли;

	Для Каждого ФайлСсылка Из МассивФайлов Цикл

		Источник = ФайлСсылка;
		Приемник = Приемники.Получить(ФайлСсылка);
		
		Если Не Источник.ТекущаяВерсия.Пустая() Тогда
			
			ХранилищеФайла = Неопределено;
			Если Источник.ТекущаяВерсия.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда 
				ХранилищеФайла = ПолучитьХранилищеФайлаИзИнформационнойБазы(Источник.ТекущаяВерсия);
			КонецЕсли;	
			
			Версия = СоздатьВерсию(
				ТекущаяДата(),
				РаботаСФайламиКлиентСервер.ПолучитьУниверсальноеВремя(ТекущаяДата()),
				Приемник,
				Приемник.Наименование,
				Источник.ТекущаяВерсия.Размер,
				Источник.ТекущаяВерсия.Расширение,
				ХранилищеФайла,
				Источник.ТекущаяВерсия.ТекстХранилище,
				Ложь,
				Источник.ТекущаяВерсия);
			
			ОбновитьВерсиюВФайле(Приемник, Версия, Источник.ТекущаяВерсия.ТекстХранилище);
		КонецЕсли;
		
	КонецЦикла;    
	
	Возврат Приемник;
	
КонецФункции

// Есть ли дублирующийся элемент в условном оформлении списка
// Параметры
// Элементы - массив элементов условного оформления списка
// ЭлементПоиска - элемент условного оформления списка
//
// Возвращаемое значение:
//   Булево - есть дублирующийся элемент
Функция ЕстьДублирующийсяЭлемент(Элементы, ЭлементПоиска)
	
	Для Каждого Элемент Из Элементы Цикл
		Если Элемент <> ЭлементПоиска Тогда
			
			Если Элемент.Оформление.Элементы.Количество() <> ЭлементПоиска.Оформление.Элементы.Количество() Тогда
				Продолжить;
			КонецЕсли;	
			
			НайденОтличающийсяЭлемент = Ложь;
			
			// обходим все элементы оформления - если есть хоть один отличающийся - делаем Продолжить;
			ЧислоЭлементов = Элемент.Оформление.Элементы.Количество();
			Для Индекс = 0 По ЧислоЭлементов - 1 Цикл
				Элемент1 = Элемент.Оформление.Элементы[Индекс];
				Элемент2 = ЭлементПоиска.Оформление.Элементы[Индекс];
				
				Если Элемент1.Использование И Элемент2.Использование Тогда
					Если Элемент1.Параметр <> Элемент2.Параметр ИЛИ Элемент1.Значение <> Элемент2.Значение Тогда
						НайденОтличающийсяЭлемент = Истина;
						Прервать;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;	
			
			Если НайденОтличающийсяЭлемент Тогда
				Продолжить;
			КонецЕсли;	
			
			Если Элемент.Отбор.Элементы.Количество() <> ЭлементПоиска.Отбор.Элементы.Количество() Тогда
				Продолжить;
			КонецЕсли;	
			
			// обходим все элементы отбора - если есть хоть один отличающийся - делаем Продолжить;
			ЧислоЭлементов = Элемент.Отбор.Элементы.Количество();
			Для Индекс = 0 По ЧислоЭлементов - 1 Цикл
				Элемент1 = Элемент.Отбор.Элементы[Индекс];
				Элемент2 = ЭлементПоиска.Отбор.Элементы[Индекс];
				
				Если Элемент1.Использование И Элемент2.Использование Тогда
					Если Элемент1.ВидСравнения <> Элемент2.ВидСравнения
						ИЛИ Элемент1.ЛевоеЗначение <> Элемент2.ЛевоеЗначение
						ИЛИ Элемент1.ПравоеЗначение <> Элемент2.ПравоеЗначение Тогда
						
						НайденОтличающийсяЭлемент = Истина;
						Прервать;
						
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;	
			
			Если НайденОтличающийсяЭлемент Тогда
				Продолжить;
			КонецЕсли;	
			
			// обошли все элементы оформления и отбора - они все одинаковы - это дубль
			Возврат Истина;	
			
		КонецЕсли;	
	КонецЦикла;	
		
		
	Возврат Ложь;	
	
КонецФункции	

// заполняет условное оформление списка файлов
Процедура ЗаполнитьУсловноеОформлениеСпискаФайлов(Список) Экспорт
	
	Элемент = Список.УсловноеОформление.Элементы.Добавить();
	Элемент.Использование = Истина;
	Элемент.Оформление.УстановитьЗначениеПараметра("ЦветТекста", ЦветаСтиля.ФайлЗанятыйДругимПользователем);
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.Использование = Истина;
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.НеРавно;
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("Редактирует");
	Отбор.ПравоеЗначение = ПредопределенноеЗначение("Справочник.Пользователи.ПустаяСсылка");
	Если ЕстьДублирующийсяЭлемент(Список.УсловноеОформление.Элементы, Элемент) Тогда
		Список.УсловноеОформление.Элементы.Удалить(Элемент);
	КонецЕсли;	
	
	Элемент = Список.УсловноеОформление.Элементы.Добавить();
	Элемент.Использование = Истина;
	Элемент.Оформление.УстановитьЗначениеПараметра("ЦветТекста", ЦветаСтиля.ФайлЗанятыйТекущимПользователем);
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.Использование = Истина;
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("Редактирует");
	Отбор.ПравоеЗначение = Пользователи.ТекущийПользователь();
	Если ЕстьДублирующийсяЭлемент(Список.УсловноеОформление.Элементы, Элемент) Тогда
		Список.УсловноеОформление.Элементы.Удалить(Элемент);
	КонецЕсли;	
	
	Элемент = Список.УсловноеОформление.Элементы.Добавить();
	Элемент.Использование = Истина;
	Элемент.Оформление.УстановитьЗначениеПараметра("ЦветТекста", ЦветаСтиля.НедействительныеОбъекты);
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.Использование = Истина;
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("Автор.Недействителен");
	Отбор.ПравоеЗначение = Истина;
	Поле = Элемент.Поля.Элементы.Добавить();
	Поле.Поле = Новый ПолеКомпоновкиДанных("Автор");
	Если ЕстьДублирующийсяЭлемент(Список.УсловноеОформление.Элементы, Элемент) Тогда
		Список.УсловноеОформление.Элементы.Удалить(Элемент);
	КонецЕсли;	
	
КонецПроцедуры    

// Сохраняет путь к рабочему каталогу пользователя в настройках и параметре сеанса
// Параметры
// ИмяКаталога - Строка - имя каталога
Процедура СохранитьПутьКРабочемуКаталогуПользователя(ИмяКаталога) Экспорт
	ОбщегоНазначения.ХранилищеОбщихНастроекСохранить("ЛокальныйКэшФайлов", "ПутьКЛокальномуКэшуФайлов", ИмяКаталога);	
КонецПроцедуры	

// Возвращает объект, для которого проверяется право доступа - для Файл это ПапкиФайлов (реквизит ВладелецФайла)
// Параметры
//  Объект  - ЛюбаяСсылка - ссылка на объект
//
// Возвращаемое значение:
//   ЛюбаяСсылка  - объект для которого вычисляются права доступа
Функция ПолучитьОбъектДоступа(Объект) Экспорт
	Если ТипЗнч(Объект) <> Тип("СправочникСсылка.Файлы") Тогда
		Возврат Неопределено;
	КонецЕсли;	
	
	Если ТипЗнч(Объект.ВладелецФайла) = Тип("СправочникСсылка.ПапкиФайлов") Тогда
		Возврат Объект.ВладелецФайла;
	КонецЕсли;	
	
	Возврат Неопределено;
КонецФункции	

// Возвращает номер по нарастанию. Предыдущее значение берется из регистра сведений НомераОтсканированныхФайлов
// Параметры
// Владелец - ЛюбаяСсылка - владелец файла
//
// Возвращаемое значение:
//   Число  - новый номер для сканирования
Функция ПолучитьНовыйНомерДляСканирования(Владелец) Экспорт
	
	// Подготовить структуру отбора по измерениям      
	СтруктураОтбора = Новый Структура;
	СтруктураОтбора.Вставить("Владелец", Владелец);
	
	НачатьТранзакцию();
	Попытка
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.НомераОтсканированныхФайлов");
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
		ЭлементБлокировки.УстановитьЗначение("Владелец", Владелец);
		Блокировка.Заблокировать();   		
	
		// Получить структуру с данными ресурсов записи
		СтруктураРесурсов = РегистрыСведений.НомераОтсканированныхФайлов.Получить(СтруктураОтбора);
		   
		// Получить максимальный номер из регистра
		Номер = СтруктураРесурсов.Номер;
		Номер = Номер + 1; // увеличим на 1
		
		
		// запишем новый номер в регистр
		НаборЗаписей = РегистрыСведений.НомераОтсканированныхФайлов.СоздатьНаборЗаписей();
		
		НаборЗаписей.Отбор.Владелец.Установить(Владелец);

		НоваяЗапись = НаборЗаписей.Добавить();
		НоваяЗапись.Владелец = Владелец;
		НоваяЗапись.Номер = Номер;

		НаборЗаписей.Записать();
		
		ЗафиксироватьТранзакцию();
		
		Возврат Номер;
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	
	Возврат 0;
КонецФункции	

// Очищает настройки форм ФормаНового
Процедура ОчиститьНастройкиФормНовогоФайла() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	// Очистка настроек окна ФормаНового
	ХранилищеСистемныхНастроек.Удалить("Справочник.Файлы.Форма.ФормаНового/НастройкиОкна", "", Неопределено);
	
	ОбновитьПовторноИспользуемыеЗначения();
	
КонецПроцедуры	

// Преобразует параметры сканера в виде чисел  - в перечисления
// Параметры
//  РазрешениеЧисло - Число - разрешение dpi 
//  ЦветностьЧисло  - Число - Цветность (0,1,2)
//  ПоворотЧисло    - Число - Поворот
//  РазмерБумагиЧисло - Число - Размер бумаги
//  Разрешение - Перечисление.РазрешенияСканированногоИзображения - Разрешение
//  Цветность  - Перечисление.ЦветностиИзображения - Цветность
//  Поворот  - Перечисление.ПоворотИзображения - Поворот
//  РазмерБумаги - Перечисление.РазмерыБумаги - Размер бумаги
Процедура ПреобразоватьПараметрыСканераВПеречисления(РазрешениеЧисло, ЦветностьЧисло, ПоворотЧисло, РазмерБумагиЧисло, 
	Разрешение, Цветность, Поворот, РазмерБумаги) Экспорт
	
	Если РазрешениеЧисло = 200 Тогда
		Разрешение = Перечисления.РазрешенияСканированногоИзображения.dpi200;
	ИначеЕсли РазрешениеЧисло = 300 Тогда
		Разрешение = Перечисления.РазрешенияСканированногоИзображения.dpi300;
	ИначеЕсли РазрешениеЧисло = 600 Тогда
		Разрешение = Перечисления.РазрешенияСканированногоИзображения.dpi600;
	ИначеЕсли РазрешениеЧисло = 1200 Тогда
		Разрешение = Перечисления.РазрешенияСканированногоИзображения.dpi1200;
	КонецЕсли;
	
	Если ЦветностьЧисло = 0 Тогда
		Цветность = Перечисления.ЦветностиИзображения.Монохромное;
	ИначеЕсли ЦветностьЧисло = 1 Тогда
		Цветность = Перечисления.ЦветностиИзображения.ГрадацииСерого;
	ИначеЕсли ЦветностьЧисло = 2 Тогда
		Цветность = Перечисления.ЦветностиИзображения.Цветное;
	КонецЕсли;
	
	Если ПоворотЧисло = 0 Тогда
		Поворот = Перечисления.СпособыПоворотаИзображения.НетПоворота;
	ИначеЕсли ПоворотЧисло = 90 Тогда
		Поворот = Перечисления.СпособыПоворотаИзображения.ВправоНа90;
	ИначеЕсли ПоворотЧисло = 180 Тогда
		Поворот = Перечисления.СпособыПоворотаИзображения.ВправоНа180;
	ИначеЕсли ПоворотЧисло = 270 Тогда
		Поворот = Перечисления.СпособыПоворотаИзображения.ВлевоНа90;
	КонецЕсли;
	
	Если РазмерБумагиЧисло = 0 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.НеЗадано;
	ИначеЕсли РазмерБумагиЧисло = 11 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.A3;
	ИначеЕсли РазмерБумагиЧисло = 1 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.A4;
	ИначеЕсли РазмерБумагиЧисло = 5 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.A5;
	ИначеЕсли РазмерБумагиЧисло = 6 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.B4;
	ИначеЕсли РазмерБумагиЧисло = 2 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.B5;
	ИначеЕсли РазмерБумагиЧисло = 7 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.B6;
	ИначеЕсли РазмерБумагиЧисло = 14 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.C4;
	ИначеЕсли РазмерБумагиЧисло = 15 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.C5;
	ИначеЕсли РазмерБумагиЧисло = 16 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.C6;
	ИначеЕсли РазмерБумагиЧисло = 3 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.USLetter;
	ИначеЕсли РазмерБумагиЧисло = 4 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.USLegal;
	ИначеЕсли РазмерБумагиЧисло = 10 Тогда
		РазмерБумаги = Перечисления.РазмерыБумаги.USExecutive;
	КонецЕсли;
	
КонецПроцедуры

// Преобразует число в перечисление и сохраняет в настройках
// Параметры
//  РазрешениеЧисло - Число - разрешение dpi 
//  ЦветностьЧисло  - Число - Цветность (0,1,2)
//  ПоворотЧисло    - Число - Поворот
//  РазмерБумагиЧисло - Число - Размер бумаги
//  ИдентификаторКлиента - Строка - Идентификатор клиента
Процедура ПреобразоватьИСохранитьПараметрыСканера(РазрешениеЧисло, ЦветностьЧисло, ПоворотЧисло, 
		РазмерБумагиЧисло, ИдентификаторКлиента) Экспорт
	Перем Разрешение;
	Перем Цветность;
	Перем Поворот;
	Перем РазмерБумаги;
	
	ПреобразоватьПараметрыСканераВПеречисления(РазрешениеЧисло, ЦветностьЧисло, ПоворотЧисло, РазмерБумагиЧисло, 
		Разрешение, Цветность, Поворот, РазмерБумаги);
	ХранилищеОбщихНастроек.Сохранить("НастройкиСканирования/Разрешение", ИдентификаторКлиента, Разрешение);
	ХранилищеОбщихНастроек.Сохранить("НастройкиСканирования/Цветность", ИдентификаторКлиента, Цветность);
КонецПроцедуры	

// Вызывается при обновлении на 1.0.6.3 - заполняет пути ТомаХраненияФайлов
Процедура ЗаполнитьПутиТома() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ТомаХраненияФайлов.Ссылка
		|ИЗ
		|	Справочник.ТомаХраненияФайлов КАК ТомаХраненияФайлов
		|ГДЕ
		|	ТомаХраненияФайлов.ЭтоГруппа = ЛОЖЬ";

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Объект = Выборка.Ссылка.ПолучитьОбъект();
		Объект.ПолныйПутьLinux = Объект.ПолныйПутьWindows;
		Объект.Записать();
	КонецЦикла;
		
КонецПроцедуры	

// В справочнике Файлы перезаписывает все элементы
Процедура ПерезаписатьВсеФайлы() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	Файлы.Ссылка
		|ИЗ
		|	Справочник.Файлы КАК Файлы";

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Объект = Выборка.Ссылка.ПолучитьОбъект();
		Объект.Записать();
	КонецЦикла;
	
КонецПроцедуры	

// Переносит настройку (копирует в новое место, в старом удаляет)
Процедура ПеренестиНастройку(Объект, Настройка, ИмяТекущее, ИмяУстанавливаемое) 
	
	Значение = ХранилищеОбщихНастроек.Загрузить(Объект, Настройка, , ИмяТекущее);
	
	Если Значение <> Неопределено Тогда
		ХранилищеОбщихНастроек.Сохранить(Объект, Настройка, Значение, , ИмяУстанавливаемое);
		ХранилищеОбщихНастроек.Удалить(Объект, Настройка, ИмяТекущее);
	КонецЕсли;
КонецПроцедуры
	
// При переименовании пользователя переносит его настройки - РабочийКаталог, ДействиеПоДвойномуЩелчкуМыши и пр
Процедура ПеренестиНастройкиПриСменеИмениПользователи(знач ИмяТекущее, знач ИмяУстанавливаемое) Экспорт
	
	ПеренестиНастройку("ЛокальныйКэшФайлов", "ПутьКЛокальномуКэшуФайлов", ИмяТекущее, ИмяУстанавливаемое); // путь к раб каталогу тоже переносим - чтобы файлы не потерялись
	ПеренестиНастройку("ЛокальныйКэшФайлов", "МаксимальныйРазмерЛокальногоКэшаФайлов", ИмяТекущее, ИмяУстанавливаемое);
	ПеренестиНастройку("ЛокальныйКэшФайлов", "УдалятьФайлИзЛокальногоКэшаФайловПриЗавершенииРедактирования", ИмяТекущее, ИмяУстанавливаемое);
	ПеренестиНастройку("ЛокальныйКэшФайлов", "ПодтверждатьПриУдаленииИзЛокальногоКэшаФайлов", ИмяТекущее, ИмяУстанавливаемое);
	
	ПеренестиНастройку("НастройкиПрограммы", "ПоказыватьКолонкуРазмер", ИмяТекущее, ИмяУстанавливаемое);
	ПеренестиНастройку("НастройкиПрограммы", "ОткрыватьНачалоРаботыПриЗапуске", ИмяТекущее, ИмяУстанавливаемое);
	ПеренестиНастройку("НастройкиПрограммы", "ПоказыватьПодсказкиПриРедактированииФайлов", ИмяТекущее, ИмяУстанавливаемое);
	ПеренестиНастройку("НастройкиПрограммы", "ПоказыватьЗанятыеФайлыПриЗавершенииРаботы", ИмяТекущее, ИмяУстанавливаемое);
	ПеренестиНастройку("НастройкиПрограммы", "ПапкаДляСохранитьКак", ИмяТекущее, ИмяУстанавливаемое);
	ПеренестиНастройку("НастройкиПрограммы", "ПапкаДляОбновитьИзФайла", ИмяТекущее, ИмяУстанавливаемое);
	
	ПеренестиНастройку("НастройкиСравненияФайлов", "СпособСравненияВерсийФайлов", ИмяТекущее, ИмяУстанавливаемое);
	ПеренестиНастройку("ИмяПапкиВыгрузки", "ИмяПапкиВыгрузки", ИмяТекущее, ИмяУстанавливаемое);
	
	ПеренестиНастройку("НастройкиОткрытияФайлов", "ДействиеПоДвойномуЩелчкуМыши", ИмяТекущее, ИмяУстанавливаемое);
	ПеренестиНастройку("НастройкиОткрытияФайлов", "СпрашиватьРежимРедактированияПриОткрытииФайла", ИмяТекущее, ИмяУстанавливаемое);
	
КонецПроцедуры

// Обработчик события ПриЗаписи. Определен для объектов (кроме Документ), владельцев Файла.
Процедура УстановитьПометкуУдаленияФайловПередЗаписью(Источник, Отказ) Экспорт
	Если Источник.ПометкаУдаления <> Источник.Ссылка.ПометкаУдаления Тогда 
		ПометитьНаУдалениеПриложенныеФайлы(Источник.Ссылка, Источник.ПометкаУдаления);
	КонецЕсли;
КонецПроцедуры

// Обработчик события ПриЗаписи. Определен для объектов типа Документ, владельцев Файла.
Процедура УстановитьПометкуУдаленияФайловДокументовПередЗаписью(Источник, Отказ, РежимЗаписи, РежимПроведения) Экспорт
	Если Источник.ПометкаУдаления <> Источник.Ссылка.ПометкаУдаления Тогда 
		ПометитьНаУдалениеПриложенныеФайлы(Источник.Ссылка, Источник.ПометкаУдаления);
	КонецЕсли;
КонецПроцедуры

// Получает первые 100 версий файлов, у которых еще не извлечен текст 
//
// Возвращаемое значение:
//   Массив - массив версий файлов
Функция ПолучитьМассивВерсийДляИзвлеченияТекста() Экспорт
	
	МассивВерсий = Новый Массив;
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = 			
	 "ВЫБРАТЬ ПЕРВЫЕ 100
	 |	ВерсииФайлов.Ссылка КАК Ссылка,
	 |	ВерсииФайлов.СтатусИзвлеченияТекста КАК СтатусИзвлеченияТекста
	 |ИЗ
	 |	Справочник.ВерсииФайлов КАК ВерсииФайлов
	 |ГДЕ
	 |	(ВерсииФайлов.СтатусИзвлеченияТекста = &Статус
	 |			ИЛИ ВерсииФайлов.СтатусИзвлеченияТекста = ЗНАЧЕНИЕ(Перечисление.СтатусыИзвлеченияТекстаФайлов.ПустаяСсылка))
	 |	И ВерсииФайлов.Зашифрован = &Зашифрован";
	
	Запрос.УстановитьПараметр("Статус", Перечисления.СтатусыИзвлеченияТекстаФайлов.НеИзвлечен);
	Запрос.УстановитьПараметр("Зашифрован", Ложь);
	
	Результат = Запрос.Выполнить();
	ТаблицаВыгрузки = Результат.Выгрузить();
	
	Для Каждого Строка Из ТаблицаВыгрузки Цикл
		ВерсияСсылка = Строка.Ссылка;
		МассивВерсий.Добавить(ВерсияСсылка);
	КонецЦикла;
	
	Возврат МассивВерсий;
	
КонецФункции

// получает первые 100 версий файлов, которые нуждаются в распознавании
Функция ПолучитьМассивВерсийДляРаспознавания(КоличествоФайловВПорции) Экспорт
	
	МассивВерсий = Новый Массив;
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = 			
	 "ВЫБРАТЬ {КоличествоФайловВПорции}
	 |	ВерсииФайлов.Ссылка КАК Ссылка,
	 |	ВерсииФайлов.СтатусРаспознаванияТекста
	 |ИЗ
	 |	Справочник.ВерсииФайлов КАК ВерсииФайлов
	 |ГДЕ
	 |	ВерсииФайлов.СтатусРаспознаванияТекста = &Статус
	 |	И ВерсииФайлов.Зашифрован = ЛОЖЬ
	 |	И ВерсииФайлов.ФайлУдален = ЛОЖЬ";
	 
	Если КоличествоФайловВПорции <> 0 Тогда			
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "{КоличествоФайловВПорции}", "ПЕРВЫЕ " + Формат(КоличествоФайловВПорции, "ЧГ=; ЧН="));
	Иначе
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "{КоличествоФайловВПорции}", "");
	КонецЕсли;	 
	 
	Запрос.УстановитьПараметр("Статус", Перечисления.СтатусыРаспознаванияТекста.НужноРаспознать);
	
	Результат = Запрос.Выполнить();
	ТаблицаВыгрузки = Результат.Выгрузить();
	
	Для Каждого Строка Из ТаблицаВыгрузки Цикл
		ВерсияСсылка = Строка.Ссылка;
		МассивВерсий.Добавить(ВерсияСсылка);
	КонецЦикла;
	
	Возврат МассивВерсий;
	
КонецФункции

// Записывает на сервер результат извлечения текста - извлеченный текст и СтатусИзвлеченияТекста
Процедура ЗаписатьРезультатИзвлеченияТекста(ВерсияСсылка, РезультатИзвлечения, АдресВременногоХранилищаТекста) Экспорт
	
	ФайлЗаблокирован = Ложь;
	Файл = ВерсияСсылка.Владелец;
	
	Если Файл.ТекущаяВерсия = ВерсияСсылка Тогда
		
		Попытка
			ЗаблокироватьДанныеДляРедактирования(Файл);
			ФайлЗаблокирован = Истина;
		Исключение
			Возврат; // ничего не сообщаем
		КонецПопытки;
		
	КонецЕсли;
	
	Текст = "";
	
	ВерсияОбъект = ВерсияСсылка.ПолучитьОбъект();
	
	Если Не ПустаяСтрока(АдресВременногоХранилищаТекста) Тогда
		
		Если ЭтоАдресВременногоХранилища(АдресВременногоХранилищаТекста) Тогда
			Текст = ФайловыеФункции.ПолучитьСтрокуИзВременногоХранилища(АдресВременногоХранилищаТекста);
		Иначе	
			Текст = АдресВременногоХранилищаТекста;
		КонецЕсли;
		
		ВерсияОбъект.ИзвлеченныйТекст = Новый ХранилищеЗначения(Текст);
		ФайловыеФункции.СформироватьРеквизитТекстХранилище(ВерсияОбъект);
		ВерсияОбъект.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.Извлечен;
		
	КонецЕсли;
	
	Если РезультатИзвлечения = "НеИзвлечен" Тогда
		ВерсияОбъект.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.НеИзвлечен;
	ИначеЕсли РезультатИзвлечения = "Извлечен" Тогда
		ВерсияОбъект.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.Извлечен;
	ИначеЕсли РезультатИзвлечения = "ИзвлечьНеУдалось" Тогда
		ВерсияОбъект.СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.ИзвлечьНеУдалось;
	КонецЕсли;	
	
	Попытка
		НачатьТранзакцию();

		ВерсияОбъект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина); // чтобы прошла запись ранее подписанного объекта
		ВерсияОбъект.Записать();

		Если Файл.ТекущаяВерсия = ВерсияСсылка Тогда
			ФайлОбъект = Файл.ПолучитьОбъект();
			ФайлОбъект.ТекстХранилище = ВерсияОбъект.ТекстХранилище;
			ФайлОбъект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина); // чтобы прошла запись ранее подписанного объекта
			ФайлОбъект.Записать();
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
		
		Если ФайлЗаблокирован Тогда
			РазблокироватьДанныеДляРедактирования(Файл);
		КонецЕсли;
		
	Исключение
		ОтменитьТранзакцию();
		
		Если ФайлЗаблокирован Тогда
			РазблокироватьДанныеДляРедактирования(Файл);
		КонецЕсли;
		
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Записывает на сервер результат распознавания
Процедура ЗаписатьРезультатРаспознавания(ВерсияСсылка, 
	СтрокаВозврата, ОписаниеОшибки, АдресВременногоХранилищаФайла, 
	АдресВременногоХранилищаТекста, УникальныйИдентификатор,
	ВремяИзменения, ВремяИзмененияУниверсальное, РазмерФайла, Расширение,
	ЭтоРегламентноеЗадание) Экспорт
	
	РаспознанныйТекст = "";
	Если Не ПустаяСтрока(АдресВременногоХранилищаТекста) Тогда
		РаспознанныйТекст = ФайловыеФункции.ПолучитьСтрокуИзВременногоХранилища(АдресВременногоХранилищаТекста);
	КонецЕсли;
	
	ЗаписатьРезультатРаспознаванияИВыполнитьДействия(ВерсияСсылка, СтрокаВозврата, АдресВременногоХранилищаФайла, 
		РаспознанныйТекст, УникальныйИдентификатор, ЭтоРегламентноеЗадание,
		ВремяИзменения, ВремяИзмененияУниверсальное, РазмерФайла, Расширение);	
	
КонецПроцедуры

// Получает массив ссылок всех файлов в папке (если Рекурсивно, то и в подпапках тоже)
// Параметры
//  Папка  - СправочникСсылка.ПапкиФайлов - папка файлов
//  Рекурсивно - Булево - обходить ли подпапки
//
// Возвращаемое значение:
//   Массив - массив файлов
Функция ПолучитьВсеФайлыВПапке(Папка, Рекурсивно) Экспорт
	
	МассивФайлов = Новый Массив;
	
	ПолучитьВсеФайлыВОднойПапке(Папка, МассивФайлов);
	
	Если Рекурсивно Тогда
		
		МассивПапок = Новый Массив;
		
		ЗапросВПапки = Новый Запрос;
		ЗапросВПапки.УстановитьПараметр("Родитель", Папка);
		ЗапросВПапки.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
		                     |	ПапкиФайлов.Ссылка КАК Ссылка
		                     |ИЗ
		                     |	Справочник.ПапкиФайлов КАК ПапкиФайлов
		                     |ГДЕ
		                     |	ПапкиФайлов.Родитель В ИЕРАРХИИ(&Родитель)";
		
		Результат = ЗапросВПапки.Выполнить();
		Выборка = Результат.Выбрать();
		Пока Выборка.Следующий() Цикл
			МассивПапок.Добавить(Выборка.Ссылка);
		КонецЦикла;
		
		Для Каждого Подпапка Из МассивПапок Цикл
			ПолучитьВсеФайлыВОднойПапке(Подпапка, МассивФайлов);
		КонецЦикла;	
		
	КонецЕсли;	
	
	Возврат МассивФайлов;
КонецФункции	

// Получает массив ссылок всех файлов в папке
// Параметры
//  Папка  - СправочникСсылка.ПапкиФайлов - папка файлов
//  МассивФайлов - Массив - массив файлов
Процедура ПолучитьВсеФайлыВОднойПапке(Папка, МассивФайлов) Экспорт
	
	ЗапросВПапки = Новый Запрос;
	ЗапросВПапки.УстановитьПараметр("Родитель", Папка);
	ЗапросВПапки.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
						 |	Файлы.Ссылка КАК Ссылка
						 |ИЗ
						 |	Справочник.Файлы КАК Файлы
						 |ГДЕ
						 |	Файлы.ВладелецФайла = &Родитель";
	
	Результат = ЗапросВПапки.Выполнить();
	Выборка = Результат.Выбрать();
	Пока Выборка.Следующий() Цикл
		МассивФайлов.Добавить(Выборка.Ссылка);
	КонецЦикла;
	
КонецПроцедуры

// Получает ДанныеФайла и НавигационнуюСсылкуВерсии
// Параметры
//  ФайлСсылка  - СправочникСсылка.Файлы - файл
//  ВерсияСсылка  - СправочникСсылка.ВерсииФайлов - версия файла
//  ИдентификаторФормы - уникальный идентификатор формы
//
// Возвращаемое значение:
//   Структура - структура с данными файла
Функция ПолучитьДанныеФайлаИНавигационнуюСсылкуВерсии(ФайлСсылка, ВерсияСсылка, ИдентификаторФормы) Экспорт
	
	ДанныеФайла = ПолучитьДанныеФайла(ФайлСсылка, ВерсияСсылка);
	Если ВерсияСсылка = Неопределено Тогда
		ВерсияСсылка = ФайлСсылка.ТекущаяВерсия;
	КонецЕсли;	
	НавигационнаяСсылкаВерсии = ПолучитьНавигационнуюСсылкуДляОткрытия(ВерсияСсылка, ИдентификаторФормы);

	СтруктураВозврата = Новый Структура("ДанныеФайла, НавигационнаяСсылкаВерсии", ДанныеФайла, НавигационнаяСсылкаВерсии);
	
	Возврат СтруктураВозврата;
КонецФункции

// получает ДанныеФайла и НавигационнуюСсылкуВерсии для распознавания
Функция ПолучитьДанныеФайлаИНавигационнуюСсылкуВерсииДляРаспознавания(ВерсияСсылка, ИдентификаторФормы) Экспорт
	
	ДанныеФайла = ПолучитьДанныеФайла(, ВерсияСсылка);
	НавигационнаяСсылкаВерсии = ПолучитьНавигационнуюСсылкуДляОткрытия(ВерсияСсылка, ИдентификаторФормы);
	ЯзыкРаспознавания = ВерсияСсылка.Владелец.ЯзыкРаспознавания;
	
	СтратегияРаспознавания = ВерсияСсылка.Владелец.СтратегияРаспознавания;
	РасширениеФайлаРезультата = "txt";
	Если СтратегияРаспознавания = Перечисления.СтратегииРаспознаванияТекста.СоздатьНовуюВерсиюHTML ИЛИ СтратегияРаспознавания = Перечисления.СтратегииРаспознаванияТекста.СоздатьНовыйФайлHTML Тогда
		РасширениеФайлаРезультата = "html";
	КонецЕсли;	                    	

	СтруктураВозврата = Новый Структура("ДанныеФайла, НавигационнаяСсылкаВерсии, РасширениеФайлаРезультата, ЯзыкРаспознавания", 
		ДанныеФайла, НавигационнаяСсылкаВерсии, РасширениеФайлаРезультата, ЯзыкРаспознавания);
	
	Возврат СтруктураВозврата;
КонецФункции

// Получает данные файла для открытия и читает их Общих настроек ПапкаДляСохранитьКак
// Параметры
//  ФайлСсылка  - СправочникСсылка.Файлы - файл
//  ВерсияСсылка  - СправочникСсылка.ВерсииФайлов - версия файла
//  ИдентификаторФормы - уникальный идентификатор формы
//  РабочийКаталогВладельца - Строка - рабочий каталог владельца файла
//
// Возвращаемое значение:
//   Структура - структура с данными файла
Функция ПолучитьДанныеФайлаДляСохранения(ФайлСсылка, ВерсияСсылка = Неопределено, 
	ИдентификаторФормы = Неопределено, РабочийКаталогВладельца = Неопределено) Экспорт

	ДанныеФайла = ПолучитьДанныеФайлаДляОткрытия(ФайлСсылка, ВерсияСсылка, ИдентификаторФормы, РабочийКаталогВладельца);
	
	ПапкаДляСохранитьКак = ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить("НастройкиПрограммы", "ПапкаДляСохранитьКак");
	ДанныеФайла.Вставить("ПапкаДляСохранитьКак", ПапкаДляСохранитьКак);
	
	Возврат ДанныеФайла;
КонецФункции // ПолучитьДанныеФайлаИЗанятьФайл()

// Функция верхнего уровня - вызывается для списка выделенных файлов например из формы ХранилищеФайлов
Функция РаспознатьФайлы(Знач МассивФайлов, ПараметрыРаспознавания, УникальныйИдентификатор = Неопределено) Экспорт
	
	РаспознаноУспешно = 0;
	
	Для Каждого ФайлСсылка Из МассивФайлов Цикл
		ОписаниеОшибки = "";
		РаспознанныйТекст = "";
		СтрокаВозврата = РаспознатьФайл(ФайлСсылка, ПараметрыРаспознавания, ОписаниеОшибки, РаспознанныйТекст, УникальныйИдентификатор);
		
		Если СтрокаВозврата = "Успешно" Тогда
			РаспознаноУспешно = РаспознаноУспешно + 1;
		КонецЕсли;	
	КонецЦикла;	
	
	СтрокаВозвратаОбщая = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Распознано успешно файлов: %1 из %2.'"),
		РаспознаноУспешно, МассивФайлов.Количество());
	
	Возврат СтрокаВозвратаОбщая;
КонецФункции	

// Функция верхнего уровня - вызывается для файла например из формы ХранилищеФайлов
Функция РаспознатьФайл(ФайлСсылка, ПараметрыРаспознавания, ОписаниеОшибки, РаспознанныйТекст, 
	УникальныйИдентификатор = Неопределено, РаспознатьНемедленно = Истина) Экспорт
	
	РеквизитыФайла = ОбщегоНазначения.ПолучитьЗначенияРеквизитов(ФайлСсылка, 
		"Зашифрован, ТекущаяВерсияРасширение, ПодписанЭП, ТекущаяВерсия");
	
	Если РеквизитыФайла.Зашифрован Тогда
		ОписаниеОшибки = НСтр("ru = 'Зашифрованный файл нельзя распознавать.'");
		Возврат "Ошибка";
	КонецЕсли;	
	
	Расширение = РеквизитыФайла.ТекущаяВерсияРасширение;
	ИспользоватьImageMagickДляРаспознаванияPDF = ПолучитьИспользоватьImageMagickДляРаспознаванияPDF();
	РасширениеПоддерживается = РаботаСФайламиКлиентСервер.ЭтотФайлМожноРаспознать(Расширение, ИспользоватьImageMagickДляРаспознаванияPDF);
	Если НЕ РасширениеПоддерживается Тогда
		Возврат "Ошибка";
	КонецЕсли;    	
	
	Если РеквизитыФайла.ПодписанЭП Тогда
		ПараметрыРаспознавания.СтратегияРаспознавания = Перечисления.СтратегииРаспознаванияТекста.ПоместитьТолькоВТекстовыйОбраз;
	КонецЕсли;	
	
	ФайлОбъект = ФайлСсылка.ПолучитьОбъект();
	
	ЗаблокироватьДанныеДляРедактирования(ФайлСсылка, , УникальныйИдентификатор);
	ФайлОбъект.СтратегияРаспознавания = ПараметрыРаспознавания.СтратегияРаспознавания;
	ФайлОбъект.ЯзыкРаспознавания = ПараметрыРаспознавания.ЯзыкРаспознавания;
	ФайлОбъект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина); // чтобы прошла запись ранее подписанного объекта
	ФайлОбъект.Записать();
	РазблокироватьДанныеДляРедактирования(ФайлСсылка, УникальныйИдентификатор);
	
	// тут надо в цикле всем версиям ставить статус
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ВерсииФайлов.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.ВерсииФайлов КАК ВерсииФайлов
		|ГДЕ
		|	ВерсииФайлов.Владелец = &Владелец";

	Запрос.УстановитьПараметр("Владелец", ФайлСсылка);
	
	ИспользоватьImageMagickДляРаспознаванияPDF = ПолучитьИспользоватьImageMagickДляРаспознаванияPDF();

	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	Пока Выборка.Следующий() Цикл
		ВерсияСсылка = Выборка.Ссылка;
		РеквизитыВерсии = ОбщегоНазначения.ПолучитьЗначенияРеквизитов(ВерсияСсылка, "Расширение, СтатусРаспознаванияТекста");
		Расширение = ВерсияСсылка.Расширение;
		
		РасширениеПоддерживается = РаботаСФайламиКлиентСервер.ЭтотФайлМожноРаспознать(Расширение, ИспользоватьImageMagickДляРаспознаванияPDF);
		
		СтатусРаспознаванияТекста = РеквизитыВерсии.СтатусРаспознаванияТекста;
		
		ЭтоТекущаяВерсия = Ложь;
		Если РеквизитыФайла.ТекущаяВерсия = ВерсияСсылка Тогда
			ЭтоТекущаяВерсия = Истина;
		КонецЕсли;	
		
		Если РасширениеПоддерживается Тогда
			Если ЭтоТекущаяВерсия ИЛИ СтатусРаспознаванияТекста = Перечисления.СтатусыРаспознаванияТекста.НеРаспознано ИЛИ СтатусРаспознаванияТекста = Перечисления.СтатусыРаспознаванияТекста.ПустаяСсылка() Тогда
				ВерсияОбъект = ВерсияСсылка.ПолучитьОбъект();
				ЗаблокироватьДанныеДляРедактирования(ВерсияОбъект.Ссылка);
				ВерсияОбъект.СтатусРаспознаванияТекста = Перечисления.СтатусыРаспознаванияТекста.НужноРаспознать;
				ВерсияОбъект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина); // чтобы прошла запись ранее подписанного объекта
				ВерсияОбъект.Записать();
				РазблокироватьДанныеДляРедактирования(ВерсияОбъект.Ссылка);
			КонецЕсли;
		КонецЕсли;	
	КонецЦикла;
	
	// сразу распознаем только активную версию, остальные - фоновым заданием
	Если РаспознатьНемедленно Тогда
		Возврат РаспознатьВерсию(РеквизитыФайла.ТекущаяВерсия, ОписаниеОшибки, РаспознанныйТекст, УникальныйИдентификатор);
	Иначе
		Возврат "ПоставленВОчередь";
	КонецЕсли;

КонецФункции // РаспознатьФайл()

// Запишет в базу результат распознавания и выполнит все действия - создать версию или файл
Функция ЗаписатьРезультатРаспознаванияИВыполнитьДействия(ВерсияСсылка, СтрокаВозврата, 
	АдресВременногоХранилищаФайла, РаспознанныйТекст, УникальныйИдентификатор, 
	ЭтоРегламентноеЗадание, 
	ВремяИзменения, ВремяИзмененияУниверсальное, РазмерФайла, Расширение)
	
	Если СтрокаВозврата = "Успешно" Тогда
	
		ФайлСсылка = ОбщегоНазначения.ПолучитьЗначениеРеквизита(ВерсияСсылка, "Владелец");
		
		РеквизитыФайла = ОбщегоНазначения.ПолучитьЗначенияРеквизитов(ФайлСсылка, 
			"СтратегияРаспознавания, ТекущаяВерсия, Автор, Описание, ВладелецФайла, ХранитьВерсии");
		СтратегияРаспознавания = РеквизитыФайла.СтратегияРаспознавания;
		
		ЭтоТекущаяВерсия = Ложь;
		Если РеквизитыФайла.ТекущаяВерсия = ВерсияСсылка Тогда
			ЭтоТекущаяВерсия = Истина;
		КонецЕсли;	
		
		Попытка
			НачатьТранзакцию();
		
			ВерсияОбъект = ВерсияСсылка.ПолучитьОбъект();
			ВерсияОбъект.РаспознанныйТекст = Новый ХранилищеЗначения(РаспознанныйТекст);
			ФайловыеФункции.СформироватьРеквизитТекстХранилище(ВерсияОбъект);
			ВерсияОбъект.СтатусРаспознаванияТекста = Перечисления.СтатусыРаспознаванияТекста.Распознано;
			ВерсияОбъект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина); // чтобы прошла запись ранее подписанного объекта
			ВерсияОбъект.Записать();
			
			Если ЭтоТекущаяВерсия Тогда
				
				ЗаблокироватьДанныеДляРедактирования(ФайлСсылка, , УникальныйИдентификатор);
				ФайлОбъект = ФайлСсылка.ПолучитьОбъект();
				ФайлОбъект.ТекстХранилище = ВерсияОбъект.ТекстХранилище;
				ФайлОбъект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина); // чтобы прошла запись ранее подписанного объекта
				ФайлОбъект.Записать();
				РазблокироватьДанныеДляРедактирования(ФайлСсылка, УникальныйИдентификатор);
				
				ИмяБезРасширения = Строка(ФайлСсылка);
				
				Если Не ЭтоАдресВременногоХранилища(АдресВременногоХранилищаФайла) Тогда
					ПутьКФайлу = АдресВременногоХранилищаФайла;
					ФайлНаДиске = Новый Файл(ПутьКФайлу);
					ВремяИзменения = ФайлНаДиске.ПолучитьВремяИзменения();
					ВремяИзмененияУниверсальное = ФайлНаДиске.ПолучитьУниверсальноеВремяИзменения();
					РазмерФайла = ФайлНаДиске.Размер();
					Расширение = ФайловыеФункцииКлиентСервер.РасширениеБезТочки(ФайлНаДиске.Расширение);
				КонецЕсли;	
				
				АвторНовойВерсииИлиФайла = Неопределено;
				Если ЭтоРегламентноеЗадание Тогда
					ПользовательЗаданияРаспознавания = ПолучитьПользователяЗаданияРаспознавания();
					Если НЕ ПользовательЗаданияРаспознавания.Пустая() Тогда
						АвторНовойВерсииИлиФайла = ПользовательЗаданияРаспознавания;
					Иначе
						АвторНовойВерсииИлиФайла = РеквизитыФайла.Автор;
					КонецЕсли;	
				КонецЕсли;	
				
				АдресВременногоХранилищаТекста = Новый ХранилищеЗначения(РаспознанныйТекст);
				
				Если СтратегияРаспознавания = Перечисления.СтратегииРаспознаванияТекста.СоздатьНовуюВерсиюHTML ИЛИ СтратегияРаспознавания = Перечисления.СтратегииРаспознаванияТекста.СоздатьНовуюВерсиюTXT Тогда
					
					НовоеОписание = Неопределено;
					
					Если ЭтоРегламентноеЗадание Тогда
						НовоеОписание = НСтр("ru = 'Версия создана регламентным заданием распознавания.'");
					КонецЕсли;	
					
					// новая версия
					СоздатьВерсиюИОбновитьВерсиюВФайле(
						ВремяИзменения,
						ВремяИзмененияУниверсальное,
						ФайлСсылка, 
						ИмяБезРасширения, 
						РазмерФайла, 
						Расширение, 
						АдресВременногоХранилищаФайла, 
						АдресВременногоХранилищаТекста,
						Ложь,
						АвторНовойВерсииИлиФайла,
						НовоеОписание);
					ИначеЕсли СтратегияРаспознавания = Перечисления.СтратегииРаспознаванияТекста.СоздатьНовыйФайлHTML ИЛИ СтратегияРаспознавания = Перечисления.СтратегииРаспознаванияТекста.СоздатьНовыйФайлTXT Тогда
						
						ЭтоВебКлиент = Ложь;
						
						НовоеОписание = РеквизитыФайла.Описание;
						Если ЭтоРегламентноеЗадание Тогда
							Если Не ПустаяСтрока(НовоеОписание) Тогда
								НовоеОписание = НовоеОписание + Символы.ПС;
							КонецЕсли;	
							
							НовоеОписание = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
								НСтр("ru = '%1 Файл создан регламентным заданием распознавания на основании файла %2'"),
								НовоеОписание, ПолучитьНавигационнуюСсылку(ФайлСсылка));
						КонецЕсли;	
					
						СоздатьФайлСВерсией(
							РеквизитыФайла.ВладелецФайла,
							ИмяБезРасширения,
							Расширение,
							ВремяИзменения,
							ВремяИзмененияУниверсальное,
							РазмерФайла,
							АдресВременногоХранилищаФайла,
							АдресВременногоХранилищаТекста,
							ЭтоВебКлиент,
							АвторНовойВерсииИлиФайла,
							НовоеОписание,
							Неопределено, // ПараметрыРаспознавания
							РеквизитыФайла.ХранитьВерсии);
				КонецЕсли;
				
				Если ЭтоАдресВременногоХранилища(АдресВременногоХранилищаФайла) Тогда
					УдалитьИзВременногоХранилища(АдресВременногоХранилищаФайла);
				КонецЕсли;	
				
			КонецЕсли;
			
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			Если Не ЭтоРегламентноеЗадание Тогда
				ВызватьИсключение;
			КонецЕсли;	
		КонецПопытки;
		
	ИначеЕсли СтрокаВозврата = "Ошибка" Тогда // ошибка	
		
		ВерсияОбъект = ВерсияСсылка.ПолучитьОбъект();
		ВерсияОбъект.СтатусРаспознаванияТекста = Перечисления.СтатусыРаспознаванияТекста.НеРаспознано;
		ВерсияОбъект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина); // чтобы прошла запись ранее подписанного объекта
		ВерсияОбъект.Записать();
		
	КонецЕсли;	
	
КонецФункции	

// Распознать - Вызывается для версии файла
Функция РаспознатьВерсию(ВерсияСсылка, ОписаниеОшибки, РаспознанныйТекст, УникальныйИдентификатор = Неопределено, ЭтоРегламентноеЗадание = Ложь) Экспорт
	
	СтратегияРаспознавания = ВерсияСсылка.Владелец.СтратегияРаспознавания;
	РасширениеФайлаРезультата = "txt";
	Если СтратегияРаспознавания = Перечисления.СтратегииРаспознаванияТекста.СоздатьНовуюВерсиюHTML ИЛИ СтратегияРаспознавания = Перечисления.СтратегииРаспознаванияТекста.СоздатьНовыйФайлHTML Тогда
		РасширениеФайлаРезультата = "html";
	КонецЕсли;	
	
	ПутьКФайлу = "";
	СтрокаВозврата = Распознавание.Распознать(ВерсияСсылка, РасширениеФайлаРезультата, ОписаниеОшибки, РаспознанныйТекст, ПутьКФайлу);
	
	ВремяИзменения = Неопределено;
	ВремяИзмененияУниверсальное = Неопределено;
	РазмерФайла = Неопределено;	
	Расширение = Неопределено;	

	ЗаписатьРезультатРаспознаванияИВыполнитьДействия(ВерсияСсылка, СтрокаВозврата, ПутьКФайлу, 
		РаспознанныйТекст, УникальныйИдентификатор, ЭтоРегламентноеЗадание,
		ВремяИзменения, ВремяИзмененияУниверсальное, РазмерФайла, Расширение);	
	
	Возврат СтрокаВозврата;
	
КонецФункции // РаспознатьФайл()

// Формирует представление настроек распознавания, например "Создать новую версию в формате TXT, Язык: Русско-английский"
Функция ПолучитьПредставлениеНастроекРаспознавания(СтратегияРаспознавания, ЯзыкРаспознавания) Экспорт
	Представление = "";
	
	Если СтратегияРаспознавания = Перечисления.СтратегииРаспознаванияТекста.ПоместитьТолькоВТекстовыйОбраз Тогда
		Представление = НСтр("ru = 'Поместить только в текстовый образ'");
	ИначеЕсли СтратегияРаспознавания = Перечисления.СтратегииРаспознаванияТекста.СоздатьНовуюВерсиюHTML Тогда
		Представление = НСтр("ru = 'Создать новую версию в формате HTML'");
	ИначеЕсли СтратегияРаспознавания = Перечисления.СтратегииРаспознаванияТекста.СоздатьНовуюВерсиюTXT Тогда
		Представление = НСтр("ru = 'Создать новую версию в формате TXT'");
	ИначеЕсли СтратегияРаспознавания = Перечисления.СтратегииРаспознаванияТекста.СоздатьНовыйФайлHTML Тогда
		Представление = НСтр("ru = 'Создать новый файл в формате HTML'");
	ИначеЕсли СтратегияРаспознавания = Перечисления.СтратегииРаспознаванияТекста.СоздатьНовыйФайлTXT Тогда
		Представление = НСтр("ru = 'Создать новый файл в формате TXT'");
	ИначеЕсли СтратегияРаспознавания = Перечисления.СтратегииРаспознаванияТекста.НеРаспознавать Тогда
		Представление = НСтр("ru = 'Не распознавать'");
	КонецЕсли;
	
	Если СтратегияРаспознавания <> Перечисления.СтратегииРаспознаванияТекста.НеРаспознавать Тогда
		Макет = Справочники.Файлы.ПолучитьМакет("ЯзыкиРаспознавания");
		ТабЗначений = ОбщегоНазначения.ПрочитатьXMLВТаблицу(Макет.ПолучитьТекст()).Данные;
		СтрокаТаблицы = ТабЗначений.Найти(ЯзыкРаспознавания, "Language");
		Если СтрокаТаблицы <> Неопределено Тогда
			Представление = Представление + НСтр("ru = ', Язык: '") + СтрокаТаблицы.Name;
		КонецЕсли;	
	КонецЕсли;
	
	Возврат Представление;
КонецФункции	

// возвращает представления типов
Функция ПолучитьПредставленияТипов(Типы) Экспорт
	
	СписокТипов = Новый СписокЗначений;
	ТипыОбъекта = Типы;
	
	Для Каждого ТипОбъекта Из ТипыОбъекта Цикл
		
		ОбъектСсылка = Новый(ТипОбъекта);
		ВидОбъекта = ОбщегоНазначения.ВидОбъектаПоТипу(ТипОбъекта);
		Представление = ОбъектСсылка.Метаданные().ПредставлениеОбъекта;
	
		Если ПустаяСтрока(Представление) Тогда
			Представление = ОбъектСсылка.Метаданные().Синоним;
		КонецЕсли;
		
        СписокТипов.Добавить(ВидОбъекта + "." + ОбъектСсылка.Метаданные().Имя, Представление);
	КонецЦикла;	
	
	СписокТипов.СортироватьПоПредставлению();
	
	Возврат СписокТипов;
	
КонецФункции

// Возвращает ИспользоватьЭлектронныеПодписиИШифрование
// Возвращаемое значение:
//   Булево - константа ИспользоватьЭлектронныеПодписи
Функция ПолучитьИспользоватьЭлектронныеПодписиИШифрование() Экспорт
	УстановитьПривилегированныйРежим(Истина);
	ИспользоватьЭлектронныеПодписиИШифрование = Константы.ИспользоватьЭлектронныеПодписи.Получить();
	Возврат ИспользоватьЭлектронныеПодписиИШифрование;
КонецФункции

// Получает ДанныеФайла и НавигационнуюСсылкуВерсии всех подчиненных файлов для Вх Исх Внутр
// Параметры
//  ВладелецФайла - ЛюбаяСсылка - владелец файла
//  ИдентификаторФормы - уникальный идентификатор формы
//
// Возвращаемое значение:
//   Структура - структура с данными файла
Функция ПолучитьДанныеФайлаИНавигационнуюСсылкуВерсииВсехПодчиненныхФайлов(ВладелецФайла, ИдентификаторФормы) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	Файлы.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.Файлы КАК Файлы
		|ГДЕ
		|	Файлы.ВладелецФайла = &ВладелецФайла
		|	И НЕ Файлы.ПометкаУдаления";
	
	Запрос.УстановитьПараметр("ВладелецФайла", ВладелецФайла);
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	
	МассивВозврата = Новый Массив;
	Пока Выборка.Следующий() Цикл
		
		ФайлСсылка = Выборка.Ссылка;
		ВерсияСсылка = ФайлСсылка.ТекущаяВерсия;
		ДанныеФайла = ПолучитьДанныеФайла(ФайлСсылка, ВерсияСсылка);
		НавигационнаяСсылкаВерсии = ПолучитьНавигационнуюСсылкуВоВременномХранилище(ВерсияСсылка, ИдентификаторФормы);

		СтруктураВозврата = Новый Структура("ДанныеФайла, НавигационнаяСсылкаВерсии", ДанныеФайла, НавигационнаяСсылкаВерсии);
		МассивВозврата.Добавить(СтруктураВозврата);
	КонецЦикла;
	
	Возврат МассивВозврата;
КонецФункции

// Получает все подчиненные файлы
// Параметры
//  ВладелецФайла - ЛюбаяСсылка - владелец файла
//
// Возвращаемое значение:
//   Массив - массив файлов
Функция ПолучитьВсеПодчиненныеФайлы(ВладелецФайла, ПолучатьПомеченныеНаУдаление = Истина) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	Файлы.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.Файлы КАК Файлы
		|ГДЕ
		|	Файлы.ВладелецФайла = &ВладелецФайла";
		
	Если НЕ ПолучатьПомеченныеНаУдаление Тогда
		Запрос.Текст = Запрос.Текст + " И Файлы.ПометкаУдаления = &ПометкаУдаления";
	КонецЕсли;	
		
	Запрос.Текст = Запрос.Текст + 	
		" УПОРЯДОЧИТЬ ПО
		|	Файлы.Наименование";
		
	Если НЕ ПолучатьПомеченныеНаУдаление Тогда
		Запрос.УстановитьПараметр("ПометкаУдаления", Ложь);
	КонецЕсли;	
		
	Запрос.УстановитьПараметр("ВладелецФайла", ВладелецФайла);
	Таблица = Запрос.Выполнить().Выгрузить();
	МассивВозврата = Таблица.ВыгрузитьКолонку("Ссылка");
	
	Возврат МассивВозврата;
	
КонецФункции

// Получает количество версий файла
// Параметры
//  ФайлСсылка - СправочникСсылка.Файлы - файл
//
// Возвращаемое значение:
//   Число - число версий
Функция ПолучитьКоличествоВерсий(ФайлСсылка) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	КОЛИЧЕСТВО(*) КАК Количество
	               |ИЗ
	               |	Справочник.ВерсииФайлов КАК ВерсииФайлов
	               |ГДЕ
	               |	ВерсииФайлов.Владелец = &ФайлСсылка";
				  
	Запрос.УстановитьПараметр("ФайлСсылка", ФайлСсылка);
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Возврат Число(Выборка.Количество);
	
КонецФункции	

// Получает ДанныеФайла и НавигационнуюСсылкуВерсии всех подчиненных файлов
// Параметры
//  ФайлСсылка - СправочникСсылка.Файлы - файл
//  ИдентификаторФормы - уникальный идентификатор формы
//
// Возвращаемое значение:
//   Массив - массив структур с данными файлов
Функция ПолучитьДанныеФайлаИНавигационнуюСсылкуВсехВерсийФайла(ФайлСсылка, ИдентификаторФормы) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	ВерсииФайлов.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.ВерсииФайлов КАК ВерсииФайлов
		|ГДЕ
		|	ВерсииФайлов.Владелец = &ФайлСсылка";
	
	Запрос.УстановитьПараметр("ФайлСсылка", ФайлСсылка);
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	
	МассивВозврата = Новый Массив;
	Пока Выборка.Следующий() Цикл
		
		ВерсияСсылка = Выборка.Ссылка;
		ДанныеФайла = ПолучитьДанныеФайла(ФайлСсылка, ВерсияСсылка);
		НавигационнаяСсылкаВерсии = ПолучитьНавигационнуюСсылкуВоВременномХранилище(ВерсияСсылка, ИдентификаторФормы);
		
		СтруктураВозврата = Новый Структура("ДанныеФайла, НавигационнаяСсылкаВерсии, ВерсияСсылка", 
			ДанныеФайла, НавигационнаяСсылкаВерсии, ВерсияСсылка);
		МассивВозврата.Добавить(СтруктураВозврата);
	КонецЦикла;
	
	Возврат МассивВозврата;
КонецФункции

// Помещает шифрованные файлы в базу и ставит признак Зашифрован файлу и всем версиям
// Параметры
//  ФайлСсылка - СправочникСсылка.Файлы - файл
//  Зашифровать - Булево - зашифровать файл, если Истина - иначе расшифровать
//  МассивДанныхДляЗанесенияВБазу - массив структур
//  УникальныйИдентификатор - УникальныйИдентификатор - уникальный идентификатор формы
//  ИмяРабочегоКаталога - Строка - рабочий каталог
//  МассивФайловВРабочемКаталогеДляУдаления - Массив - файлы, которые надо удалить из регистра
//  МассивОтпечатков  - Массив - массив отпечатков сертификатов, использованных для шифрования
Процедура ЗанестиИнформациюОШифровании(ФайлСсылка, Зашифровать, МассивДанныхДляЗанесенияВБазу, УникальныйИдентификатор, 
	ИмяРабочегоКаталога, МассивФайловВРабочемКаталогеДляУдаления, МассивОтпечатков) Экспорт
	
	НачатьТранзакцию();
	Попытка
		
		АдресВременногоХранилищаТекстаТекущейВерсии = "";
		
		Для Каждого ДанныеДляЗаписиНаСервере Из МассивДанныхДляЗанесенияВБазу Цикл
			
			АдресВременногоХранилища = ДанныеДляЗаписиНаСервере.АдресВременногоХранилища;
			ВерсияСсылка = ДанныеДляЗаписиНаСервере.ВерсияСсылка;
			АдресВременногоХранилищаТекста = ДанныеДляЗаписиНаСервере.АдресВременногоХранилищаТекста;
			
			Если ВерсияСсылка = ФайлСсылка.ТекущаяВерсия Тогда
				АдресВременногоХранилищаТекстаТекущейВерсии = АдресВременногоХранилищаТекста;
			КонецЕсли;
			
			ИмяФайлаСПутемВРабочемКаталоге = "";
			ВРабочемКаталогеНаЧтение = Истина; // не используется 
			ВРабочемКаталогеВладельца = Истина;
			ИмяФайлаСПутемВРабочемКаталоге = ПолучитьИмяФайлаСПутемИзРегистра(ВерсияСсылка, ИмяРабочегоКаталога, ВРабочемКаталогеНаЧтение, ВРабочемКаталогеВладельца);
			Если НЕ ПустаяСтрока(ИмяФайлаСПутемВРабочемКаталоге) Тогда
				МассивФайловВРабочемКаталогеДляУдаления.Добавить(ИмяФайлаСПутемВРабочемКаталоге);
			КонецЕсли;	
			
			УдалитьИзРегистра(ВерсияСсылка);
			
			СтатусИзвлеченияТекста = Неопределено;
			Если Зашифровать = Ложь Тогда
				СтатусИзвлеченияТекста = Перечисления.СтатусыИзвлеченияТекстаФайлов.НеИзвлечен;
			КонецЕсли;	
			
			НужноЗановоРаспознатьВерсию = Ложь;
			
			Версия = ОбновитьВерсию(
				ФайлСсылка, 
				Ложь, //СоздаватьВерсию, 
				АдресВременногоХранилища, 
				ВерсияСсылка.Комментарий, 
				ВерсияСсылка.ДатаСоздания, 
				ВерсияСсылка.ДатаМодификацииУниверсальная,
				ВерсияСсылка.Размер, 
				ВерсияСсылка.ПолноеНаименование, 
				ВерсияСсылка.Расширение, 
				"", //ПолныйПутьКФайлу,
				АдресВременногоХранилищаТекста,
				Ложь, //ЭтоВебКлиент,
				Ложь, //ТекстНеИзвлеченНаКлиенте,
				УникальныйИдентификатор,
				НужноЗановоРаспознатьВерсию,
				Зашифровать, // Зашифрован
				ВерсияСсылка,
				СтатусИзвлеченияТекста);
				
				// для варианта с хранением файлов на диске (на сервере) удаляем Файл из временного хранилища после получения
				Если НЕ ПустаяСтрока(ДанныеДляЗаписиНаСервере.АдресФайла) И ЭтоАдресВременногоХранилища(ДанныеДляЗаписиНаСервере.АдресФайла) Тогда
					УдалитьИзВременногоХранилища(ДанныеДляЗаписиНаСервере.АдресФайла);
				КонецЕсли;
				
		КонецЦикла;	
		
		ФайлОбъект = ФайлСсылка.ПолучитьОбъект();
		ЗаблокироватьДанныеДляРедактирования(ФайлСсылка, , УникальныйИдентификатор);
		
		ФайлОбъект.Зашифрован = Зашифровать;
		ФайлОбъект.ТекстХранилище = Новый ХранилищеЗначения(""); // очистим извлеченный текст
		ФайлОбъект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина); // чтобы прошла запись ранее подписанного объекта
		
		СтрокаСертификатов = "";
		
		Если Зашифровать Тогда
			Для Каждого ОтпечатокСтруктура Из МассивОтпечатков Цикл
				НоваяСтрока = ФайлОбъект.СертификатыШифрования.Добавить();
				НоваяСтрока.Отпечаток = ОтпечатокСтруктура.Отпечаток;
				НоваяСтрока.Представление = ОтпечатокСтруктура.Представление;
				НоваяСтрока.Сертификат = Новый ХранилищеЗначения(ОтпечатокСтруктура.Сертификат);
				
				СтрокаСертификатов = СтрокаСертификатов + ОтпечатокСтруктура.Представление + " ";
			КонецЦикла;
		Иначе
			ФайлОбъект.СертификатыШифрования.Очистить();
		КонецЕсли;	
		
		
		Если АдресВременногоХранилищаТекстаТекущейВерсии <> "" Тогда
			Текст = ФайловыеФункции.ПолучитьСтрокуИзВременногоХранилища(АдресВременногоХранилищаТекстаТекущейВерсии);
			ФайлОбъект.ТекстХранилище = Новый ХранилищеЗначения(Текст);
		КонецЕсли;
		
		ФайлОбъект.Записать();
		РазблокироватьДанныеДляРедактирования(ФайлСсылка, УникальныйИдентификатор);
		
		ЗафиксироватьТранзакцию();
		
		Если Зашифровать Тогда
			ПротоколированиеРаботыПользователей.ЗаписатьШифрование(ФайлСсылка, СтрокаСертификатов);
		Иначе
			ПротоколированиеРаботыПользователей.ЗаписатьРасшифрование(ФайлСсылка);
		КонецЕсли;	
		
	Исключение
	     ОтменитьТранзакцию();
	     ВызватьИсключение;
	КонецПопытки;
	
	
КонецПроцедуры	

// Возвращает адрес файла во временном хранилище (независимо от способа хранения файла - в томах или в базе)
// Параметры
//  ВерсияСсылка  - СправочникСсылка.ВерсииФайлов - версия файла
//  ИдентификаторФормы - уникальный идентификатор формы
//
// Возвращаемое значение:
//   Строка - навигационная ссылка (адрес во временном хранилище)
Функция ПолучитьНавигационнуюСсылкуВоВременномХранилище(ВерсияСсылка, 
	ИдентификаторФормы = Неопределено) Экспорт
	
	Адрес = "";
	
	РеквизитыВерсии = ОбщегоНазначения.ПолучитьЗначенияРеквизитов(ВерсияСсылка, 
		"ТипХраненияФайла, Том, ПутьКФайлу, Владелец, ПолноеНаименование, Расширение");
	
	ТипХраненияФайла = РеквизитыВерсии.ТипХраненияФайла;
	
	Если ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
		Если НЕ РеквизитыВерсии.Том.Пустая() Тогда
			ПолныйПуть = ФайловыеФункции.ПолныйПутьТома(РеквизитыВерсии.Том) + РеквизитыВерсии.ПутьКФайлу; 
			Попытка
				ДвоичныеДанные = Новый ДвоичныеДанные(ПолныйПуть);
				Адрес = ПоместитьВоВременноеХранилище(ДвоичныеДанные, ИдентификаторФормы);
			Исключение
				// запись в журнал регистрации
				СообщениеОбОшибке = СформироватьТекстОшибкиПолученияФайлСТомаДляАдминистратора(
					ИнформацияОбОшибке(), РеквизитыВерсии.Владелец);
				ЗаписьЖурналаРегистрации(НСтр("ru = 'Открытие файла'"), УровеньЖурналаРегистрации.Ошибка, 
					Метаданные.Справочники.Файлы, РеквизитыВерсии.Владелец, СообщениеОбОшибке);
				
				ВызватьИсключение ФайловыеФункцииСлужебныйКлиентСервер.ОшибкаФайлНеНайденВХранилищеФайлов(
					РеквизитыВерсии.ПолноеНаименование + "." + РеквизитыВерсии.Расширение);
					
			КонецПопытки;
		КонецЕсли;
	Иначе
		ХранилищеФайла = ПолучитьХранилищеФайлаИзИнформационнойБазы(ВерсияСсылка);
		ДвоичныеДанные = ХранилищеФайла.Получить();
		
		Адрес = ПоместитьВоВременноеХранилище(ДвоичныеДанные, ИдентификаторФормы);
	КонецЕсли;
	
	Возврат Адрес;
	
КонецФункции // ПолучитьНавигационнуюСсылкуВоВременномХранилище()

// Получает ДанныеФайла и НавигационнуюСсылкуВерсии, предварительно поместив файл версии во временное хранилище
// Параметры
//  ФайлСсылка  - СправочникСсылка.Файлы - файл
//  ВерсияСсылка  - СправочникСсылка.ВерсииФайлов - версия файла
//  ИдентификаторФормы - уникальный идентификатор формы
//
// Возвращаемое значение:
//   Структура - данные файла и навигационная ссылка
Функция ПолучитьДанныеФайлаИНавигационнуюСсылкуВерсииВоВременномХранилище(ФайлСсылка, ВерсияСсылка, ИдентификаторФормы) Экспорт
	
	ДанныеФайла = ПолучитьДанныеФайла(ФайлСсылка, ВерсияСсылка);
	Если ВерсияСсылка = Неопределено Тогда
		ВерсияСсылка = ФайлСсылка.ТекущаяВерсия;
	КонецЕсли;	
	НавигационнаяСсылкаВерсии = ПолучитьНавигационнуюСсылкуВоВременномХранилище(ВерсияСсылка, ИдентификаторФормы);

	СтруктураВозврата = Новый Структура("ДанныеФайла, НавигационнаяСсылкаВерсии", ДанныеФайла, НавигационнаяСсылкаВерсии);
	
	Возврат СтруктураВозврата;
КонецФункции

// Получает массив сертификатов шифрования
// Параметры
//  Ссылка  - СправочникСсылка.Файлы - файл
//
// Возвращаемое значение:
//   Массив - массив структур
Функция ПолучитьМассивСертификатовШифрования(Ссылка) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
				   |	СертификатыШифрования.Представление КАК Представление,
				   |	СертификатыШифрования.Отпечаток КАК Отпечаток,
				   |	СертификатыШифрования.Сертификат КАК Сертификат				   
				   |ИЗ
				   |	Справочник.Файлы.СертификатыШифрования КАК СертификатыШифрования
				   |ГДЕ
				   |	СертификатыШифрования.Ссылка = &ОбъектСсылка";
				   
	Запрос.Параметры.Вставить("ОбъектСсылка", Ссылка);
	ВыборкаЗапроса = Запрос.Выполнить().Выбрать();
	
	МассивСертификатовШифрования = Новый Массив;
	Пока ВыборкаЗапроса.Следующий() Цикл
		ОтпечатокСтруктура = Новый Структура("Отпечаток, Представление, Сертификат",
			ВыборкаЗапроса.Отпечаток, ВыборкаЗапроса.Представление, ВыборкаЗапроса.Сертификат.Получить());
		МассивСертификатовШифрования.Добавить(ОтпечатокСтруктура);
	КонецЦикла;
	
	Возврат МассивСертификатовШифрования;

КонецФункции			

// Возвращает язык распознавания
Функция ПолучитьЯзыкРаспознавания() Экспорт
	УстановитьПривилегированныйРежим(Истина);
	ЯзыкРаспознавания = Константы.ЯзыкРаспознавания.Получить();
	
	Если ЯзыкРаспознавания = "" Тогда
		ЯзыкРаспознавания = "7"; // русско-английский
		Константы.ЯзыкРаспознавания.Установить(ЯзыкРаспознавания);
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Ложь);
	Возврат ЯзыкРаспознавания;
КонецФункции

// Устанавливает язык распознавания
Процедура УстановитьЯзыкРаспознавания(ЯзыкРаспознавания) Экспорт
	УстановитьПривилегированныйРежим(Истина);
	Константы.ЯзыкРаспознавания.Установить(ЯзыкРаспознавания);
	УстановитьПривилегированныйРежим(Ложь);
КонецПроцедуры

// Возвращает пользователя задания распознавания
Функция ПолучитьПользователяЗаданияРаспознавания() Экспорт
	УстановитьПривилегированныйРежим(Истина);
	ПользовательЗаданияРаспознавания = Константы.ПользовательЗаданияРаспознавания.Получить();
	УстановитьПривилегированныйРежим(Ложь);
	Возврат ПользовательЗаданияРаспознавания;
КонецФункции

// Возвращает ПутьКПрограммеКонвертацииPDF
Функция ПолучитьПутьКПрограммеКонвертацииPDF() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	ПутьКПрограммеКонвертацииPDF = Константы.ПутьКПрограммеКонвертацииPDF.Получить();
	
	Если ПустаяСтрока(ПутьКПрограммеКонвертацииPDF) Тогда
		ПутьКПрограммеКонвертацииPDF = "convert.exe"; // ImageMagick
		Константы.ПутьКПрограммеКонвертацииPDF.Установить(ПутьКПрограммеКонвертацииPDF);
	КонецЕсли;	
	
	Возврат ПутьКПрограммеКонвертацииPDF;
	
КонецФункции

// Возвращает ИспользоватьImageMagickДляРаспознаванияPDF
Функция ПолучитьИспользоватьImageMagickДляРаспознаванияPDF() Экспорт
	УстановитьПривилегированныйРежим(Истина);
	Возврат Константы.ИспользоватьImageMagickДляРаспознаванияPDF.Получить();
КонецФункции

// Устанавливает пользователя задания распознавания
Процедура УстановитьПользователяЗаданияРаспознавания(Пользователь) Экспорт
	УстановитьПривилегированныйРежим(Истина);
	Константы.ПользовательЗаданияРаспознавания.Установить(Пользователь);
	УстановитьПривилегированныйРежим(Ложь);
КонецПроцедуры

// Устанавливает язык и пользователя задания распознавания
Процедура УстановитьПараметрыРаспознавания(ЯзыкРаспознавания, Пользователь, 
		ИспользоватьImageMagickДляРаспознаванияPDF, ПутьКПрограммеКонвертацииPDF) Экспорт
		
	УстановитьПривилегированныйРежим(Истина);
	Константы.ПользовательЗаданияРаспознавания.Установить(Пользователь);
	Константы.ЯзыкРаспознавания.Установить(ЯзыкРаспознавания);
	Константы.ИспользоватьImageMagickДляРаспознаванияPDF.Установить(ИспользоватьImageMagickДляРаспознаванияPDF);
	Константы.ПутьКПрограммеКонвертацииPDF.Установить(ПутьКПрограммеКонвертацииPDF);
	
КонецПроцедуры

// Формирует параметры распознавания по умолчанию
Функция ПодготовитьПараметрыРаспознавания() Экспорт
	
	РаспознатьПослеДобавления = Истина;
	
	ЯзыкРаспознавания = ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить("Распознавание", "ЯзыкРаспознавания");
	Если НЕ ЗначениеЗаполнено(ЯзыкРаспознавания) Тогда
		ЯзыкРаспознавания = ПолучитьЯзыкРаспознавания();
	КонецЕсли;
	
	СтратегияРаспознавания = Перечисления.СтратегииРаспознаванияТекста.ПоместитьТолькоВТекстовыйОбраз;
	
	ИспользоватьРаспознавание = ПолучитьИспользоватьРаспознавание();
	Если ИспользоватьРаспознавание = Ложь Тогда
		РаспознатьПослеДобавления = Ложь;
	КонецЕсли;
	
	ПараметрыРаспознавания = Новый Структура("СтратегияРаспознавания, ЯзыкРаспознавания, РаспознатьПослеДобавления", 
		СтратегияРаспознавания, ЯзыкРаспознавания, РаспознатьПослеДобавления);
		
	Возврат ПараметрыРаспознавания;	
КонецФункции	

// Получает ДанныеФайла и сам файл как ДвоичныеДанные
// Параметры
//  ФайлСсылка  - СправочникСсылка.Файлы - файл
//  ВерсияСсылка  - СправочникСсылка.ВерсииФайлов - версия файла
//  АдресПодписи - Строка - навигационная ссылка, содержащая адрес файла подписи во временном хранилище
//
// Возвращаемое значение:
//   Структура - ДанныеФайла и сам файл как ДвоичныеДанные и подпись файла как ДвоичныеДанные
Функция ПолучитьДанныеФайлаИДвоичныеДанные(ФайлСсылка, ВерсияСсылка = Неопределено, 
	АдресПодписи = Неопределено) Экспорт
	
	ДанныеФайла = ПолучитьДанныеФайла(ФайлСсылка, ВерсияСсылка);
	Если ВерсияСсылка = Неопределено Тогда
		ВерсияСсылка = ФайлСсылка.ТекущаяВерсия;
	КонецЕсли;	
	
	ДвоичныеДанные = Неопределено;
	
	ТипХраненияФайла = ВерсияСсылка.ТипХраненияФайла;
	Если ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
		Если НЕ ВерсияСсылка.Том.Пустая() Тогда
			ПолныйПуть = ФайловыеФункции.ПолныйПутьТома(ВерсияСсылка.Том) + ВерсияСсылка.ПутьКФайлу; 
			Попытка
				ДвоичныеДанные = Новый ДвоичныеДанные(ПолныйПуть);
			Исключение
				// запись в журнал регистрации
				СообщениеОбОшибке = СформироватьТекстОшибкиПолученияФайлСТомаДляАдминистратора(ИнформацияОбОшибке(), ВерсияСсылка.Владелец);
				ЗаписьЖурналаРегистрации(НСтр("ru = 'Открытие файла'"), УровеньЖурналаРегистрации.Ошибка, Метаданные.Справочники.Файлы, ВерсияСсылка.Владелец, СообщениеОбОшибке);
				
				ВызватьИсключение ФайловыеФункцииСлужебныйКлиентСервер.ОшибкаФайлНеНайденВХранилищеФайлов(
					ВерсияСсылка.ПолноеНаименование + "." + ВерсияСсылка.Расширение);
					
			КонецПопытки;
		КонецЕсли;
	Иначе
		ХранилищеФайла = ПолучитьХранилищеФайлаИзИнформационнойБазы(ВерсияСсылка);
		ДвоичныеДанные = ХранилищеФайла.Получить();
	КонецЕсли;

	ДвоичныеДанныеПодписи = Неопределено;
	Если АдресПодписи <> Неопределено Тогда
		ДвоичныеДанныеПодписи = ПолучитьИзВременногоХранилища(АдресПодписи);
	КонецЕсли;	
	
	СтруктураВозврата = Новый Структура("ДанныеФайла, ДвоичныеДанные, ДвоичныеДанныеПодписи", 
		ДанныеФайла, ДвоичныеДанные, ДвоичныеДанныеПодписи);
	
	Возврат СтруктураВозврата;
КонецФункции

// Процедура устанавливает специфичные для подсистемы Работа с файлами
// настройки работы с файлами
//
Процедура УстановитьПерсональныеНастройкиРаботыСФайлами(Настройки) Экспорт
	
	Настройки.Вставить("ДействиеПоДвойномуЩелчкуМыши", ДействиеПоДвойномуЩелчкуМыши());
	Настройки.Вставить("СпрашиватьРежимРедактированияПриОткрытииФайла", СпрашиватьРежимРедактированияПриОткрытииФайла());
	Настройки.Вставить("СпособСравненияВерсийФайлов", СпособСравненияВерсийФайлов());
	Настройки.Вставить("ЭтоПолноправныйПользователь", ПользователиСерверПовтИсп.ЭтоПолноправныйПользовательИБ());
	
	ПоказыватьЗанятыеФайлыПриЗавершенииРаботы = ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить("НастройкиПрограммы", "ПоказыватьЗанятыеФайлыПриЗавершенииРаботы");
	Если ПоказыватьЗанятыеФайлыПриЗавершенииРаботы = Неопределено Тогда
		ПоказыватьЗанятыеФайлыПриЗавершенииРаботы = Истина;
		ОбщегоНазначения.ХранилищеОбщихНастроекСохранить("НастройкиПрограммы", "ПоказыватьЗанятыеФайлыПриЗавершенииРаботы", ПоказыватьЗанятыеФайлыПриЗавершенииРаботы);
	КонецЕсли;
	Настройки.Вставить("ПоказыватьЗанятыеФайлыПриЗавершенииРаботы", ПоказыватьЗанятыеФайлыПриЗавершенииРаботы);
	
	ИспользоватьImageMagickДляРаспознаванияPDF = ПолучитьИспользоватьImageMagickДляРаспознаванияPDF();
	Настройки.Вставить("ИспользоватьImageMagickДляРаспознаванияPDF", ИспользоватьImageMagickДляРаспознаванияPDF);
	
	ОчищатьПриЗавершенииРаботы = ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить("ЛокальныйКэшФайлов", "ОчищатьПриЗавершенииРаботы");
	Если ОчищатьПриЗавершенииРаботы = Неопределено Тогда
		ОчищатьПриЗавершенииРаботы = Ложь;
		ОбщегоНазначения.ХранилищеОбщихНастроекСохранить("ЛокальныйКэшФайлов", "ОчищатьПриЗавершенииРаботы", ОчищатьПриЗавершенииРаботы);
	КонецЕсли;
	Настройки.Вставить("ОчищатьПриЗавершенииРаботы", ОчищатьПриЗавершенииРаботы);
	
КонецПроцедуры

// Получает все подписи файла
//
// Параметры
//  ОбъектСсылка  - СправочникСсылка - объект, в табличной части которого содержатся подписи
//  УникальныйИдентификатор - УникальныйИдентификатор - уникальный идентификатор формы
//
// Возвращаемое значение:
//  МассивВозврата - Массив  - массив структур с возвращаемыми значениями
Функция ПолучитьВсеПодписи(ФайлСсылка, УникальныйИдентификатор) Экспорт
	
	ВерсияСсылка = ОбщегоНазначения.ПолучитьЗначениеРеквизита(ФайлСсылка, "ТекущаяВерсия");
	
	Возврат ФайловыеФункции.ПолучитьВсеПодписи(ВерсияСсылка, УникальныйИдентификатор);
	
КонецФункции

// Заносит информацию о массиве ЭП
//
// Параметры
//  МассивДанныхДляЗанесенияВБазу  - Массив Структур - информация для занесения в табличную часть
//                ЭлектронныеЦифровыеПодписи
//  УникальныйИдентификатор - УникальныйИдентификатор - уникальный идентификатор формы
Процедура ЗанестиИнформациюОПодписях(МассивДанныхДляЗанесенияВБазу, УникальныйИдентификатор = Неопределено) Экспорт
	
	Для Каждого Данные Из МассивДанныхДляЗанесенияВБазу Цикл
		ОбъектСсылка = Данные.ОбъектСсылка;
			
		СтруктураРеквизитов = ОбщегоНазначения.ПолучитьЗначенияРеквизитов(ОбъектСсылка, "Редактирует, Зашифрован");
		Редактирует = СтруктураРеквизитов.Редактирует;
		Зашифрован = СтруктураРеквизитов.Зашифрован;

		Если НЕ Редактирует.Пустая() Тогда
			СтрокаИсключения = ФайловыеФункцииКлиентСервер.СтрокаСообщенияОНедопустимостиПодписанияЗанятогоФайла(ОбъектСсылка);
			ВызватьИсключение СтрокаИсключения;
		КонецЕсли;
		
		Если Зашифрован Тогда
			СтрокаИсключения = ФайловыеФункцииКлиентСервер.СтрокаСообщенияОНедопустимостиПодписанияЗашифрованногоФайла(ОбъектСсылка);
			ВызватьИсключение СтрокаИсключения;
		КонецЕсли;
		
	КонецЦикла;

	Для Каждого Данные Из МассивДанныхДляЗанесенияВБазу Цикл
		
		ЗанестиИнформациюОПодписиФайла(Данные.ОбъектСсылка, Данные.НоваяПодписьДвоичныеДанные, 
			Данные.Отпечаток, Данные.ДатаПодписи, Данные.Комментарий, 
			Данные.ИмяФайлаПодписи, Данные.КомуВыданСертификат,
			Данные.ДвоичныеДанныеСертификата,
			УникальныйИдентификатор);
			
		// для варианта с хранением файлов на диске (на сервере) удаляем Файл из временного хранилища после получения
		Если НЕ ПустаяСтрока(Данные.АдресФайла) И ЭтоАдресВременногоХранилища(Данные.АдресФайла) Тогда
			УдалитьИзВременногоХранилища(Данные.АдресФайла);
		КонецЕсли;
			
	КонецЦикла;
	
КонецПроцедуры

// Заносит информацию о одной ЭП
//
// Параметры
//  Данные  - Структура - информация для занесения в табличную часть
//                ЭлектронныеЦифровыеПодписи
//  УникальныйИдентификатор - УникальныйИдентификатор - уникальный идентификатор формы
Процедура ЗанестиИнформациюОднойПодписи(Данные, УникальныйИдентификатор = Неопределено) Экспорт
	
	ОбъектСсылка = Данные.ОбъектСсылка;
	
	СтруктураРеквизитов = ОбщегоНазначения.ПолучитьЗначенияРеквизитов(ОбъектСсылка, "Редактирует, Зашифрован");
	
	Редактирует = СтруктураРеквизитов.Редактирует;
	Если НЕ Редактирует.Пустая() Тогда
		ВызватьИсключение ФайловыеФункцииКлиентСервер.СтрокаСообщенияОНедопустимостиПодписанияЗанятогоФайла(ОбъектСсылка);
	КонецЕсли;
	
	Зашифрован = СтруктураРеквизитов.Зашифрован;
	Если Зашифрован Тогда
		СтрокаИсключения = ФайловыеФункцииКлиентСервер.СтрокаСообщенияОНедопустимостиПодписанияЗашифрованногоФайла(ОбъектСсылка);
		ВызватьИсключение СтрокаИсключения;
	КонецЕсли;

	ЗанестиИнформациюОПодписиФайла(Данные.ОбъектСсылка, Данные.НоваяПодписьДвоичныеДанные, 
		Данные.Отпечаток, Данные.ДатаПодписи, Данные.Комментарий, 
		Данные.ИмяФайлаПодписи, Данные.КомуВыданСертификат, 
		Данные.ДвоичныеДанныеСертификата,
		УникальныйИдентификатор);
		
КонецПроцедуры	

// Заносит информацию о подписи файла (добавляет запись в табл часть ЭП у версииФайла, и ставит реквизит ПодписанЭП версии и Файлу)
//
// Параметры
//  ОбъектСсылка  - любая ссылка - объект, в табличную часть которого будет занесена информация о ЭП
//  НоваяПодписьДвоичныеДанные  - ДвоичныеДанные - двоичные данные подписи
//  Отпечаток  - Строка - Base64 закодированная строка с отпечатком сертификата подписавшего
//  ДатаПодписи  - Дата - дата подписи
//  Комментарий  - Строка - комментарий подписи
//  ИмяФайлаПодписи  - Строка - имя файла подписи (не пусто только в случае если подпись добавлена из файла)
//  КомуВыданСертификат  - Строка - представление поля КомуВыдан сертификата
//  УникальныйИдентификатор - УникальныйИдентификатор - уникальный идентификатор формы
Процедура ЗанестиИнформациюОПодписиФайла(ФайлСсылка, НоваяПодписьДвоичныеДанные, 
	Отпечаток, ДатаПодписи, Комментарий, ИмяФайлаПодписи, 
	КомуВыданСертификат, ДвоичныеДанныеСертификата,
	УникальныйИдентификатор = Неопределено) Экспорт
	
	ВерсияСсылка = ОбщегоНазначения.ПолучитьЗначениеРеквизита(ФайлСсылка, "ТекущаяВерсия");
	
	НачатьТранзакцию();
	Попытка
		
		ЭлектроннаяПодпись.ЗанестиИнформациюОПодписи(ВерсияСсылка, 
			НоваяПодписьДвоичныеДанные, 
			Отпечаток, ДатаПодписи, Комментарий, ИмяФайлаПодписи, 
			КомуВыданСертификат, ДвоичныеДанныеСертификата,
			УникальныйИдентификатор);
			
		ФайлСсылкаПодписан = ОбщегоНазначения.ПолучитьЗначениеРеквизита(ФайлСсылка, "ПодписанЭП");
		Если ФайлСсылкаПодписан = Ложь Тогда
			ФайлОбъект = ФайлСсылка.ПолучитьОбъект(); 
			ЗаблокироватьДанныеДляРедактирования(ФайлСсылка, , УникальныйИдентификатор);
			ФайлОбъект.ПодписанЭП = Истина;
			
			ФайлОбъект.Записать();
			РазблокироватьДанныеДляРедактирования(ФайлСсылка, УникальныйИдентификатор);
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
		
		ПротоколированиеРаботыПользователей.ЗаписатьПодписаниеЭП(ФайлСсылка, КомуВыданСертификат, Комментарий);		
		
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры	

// Удаляет записи из табличной части ЭП
//
// Параметры
//  ВерсияСсылка - СправочникСсылка.ВерсииФайлов - ссылка на версию файла
//  ТаблицаВыделенныеСтроки  - ТаблицаЗначений - таблица, содержащая данные - ссылка на объект и номер строки в его табличной части
//  РеквизитПодписанИзменен - Булево - возвращаемое значение - если удалена последняя подпись, 
//     РеквизитПодписанИзменен примет значение Истина
//  УникальныйИдентификатор - УникальныйИдентификатор - уникальный идентификатор формы
Процедура УдалитьПодписиВерсииФайла(ВерсияСсылка, ТаблицаВыделенныеСтроки, РеквизитПодписанИзменен,
	УникальныйИдентификатор = Неопределено) Экспорт
	
	НачатьТранзакцию();
	Попытка
		
		КоличествоПодписей = 0;
		ЭлектроннаяПодпись.УдалитьПодписи(ВерсияСсылка, ТаблицаВыделенныеСтроки, 
			РеквизитПодписанИзменен, КоличествоПодписей, УникальныйИдентификатор);
		
		ФайлСсылка = ОбщегоНазначения.ПолучитьЗначениеРеквизита(ВерсияСсылка, "Владелец");
		ФайлСсылкаПодписан = ОбщегоНазначения.ПолучитьЗначениеРеквизита(ФайлСсылка, "ПодписанЭП");
		
		ПротоколированиеРаботыПользователей.ЗаписатьУдалениеПодписиЭП(ФайлСсылка);
		
		Если ФайлСсылкаПодписан = Истина И КоличествоПодписей = 0 Тогда
			ФайлОбъект = ФайлСсылка.ПолучитьОбъект(); 
			ЗаблокироватьДанныеДляРедактирования(ФайлСсылка, , УникальныйИдентификатор);
			ФайлОбъект.ПодписанЭП = Ложь;
			ФайлОбъект.Записать();
			РазблокироватьДанныеДляРедактирования(ФайлСсылка, УникальныйИдентификатор);
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Устанавливает имя файла при обмене
Функция УстановитьИмяФайлаПриОтправкеДанныхФайла(ЭлементДанных, ИмяКаталогаФайлов, УникальныйИдентификатор) Экспорт
	
	Если РаботаСФайламиСобытия.ЭтоЭлементРаботаСФайлами(ЭлементДанных) Тогда
		НовыйПутьФайла = ИмяКаталогаФайлов;
		НовыйПутьФайла = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(НовыйПутьФайла, ОбщегоНазначенияПовтИсп.ТипПлатформыСервера());
		НовыйПутьФайла = НовыйПутьФайла + УникальныйИдентификатор; 
		Возврат НовыйПутьФайла;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Удаляет файл при обмене
// Параметры
//  Ссылка - СправочникСсылка.Файлы - файл
//  ПутьСПодкаталогом - Строка - путь с подкаталогом где лежит файл в томе
Процедура УдалитьФайлыПриПолученииДанныхФайла(ЭлементДанных, ПутьСПодкаталогом) Экспорт
	
	Если РаботаСФайламиСобытия.ЭтоЭлементРаботаСФайлами(ЭлементДанных) Тогда
		МассивФайловВКаталоге = НайтиФайлы(ПутьСПодкаталогом, "*.*");
		Если МассивФайловВКаталоге.Количество() = 0 Тогда
			УдалитьФайлы(ПутьСПодкаталогом);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Добавляет файл в том при обмене
Процедура ДобавитьНаДискПриПолученииДанныхФайла(ЭлементДанных, ДвоичныеДанные, ПутьКФайлуНаТоме, СсылкаНаТом, 
		ВремяИзменения, ИмяБезРасширения, Расширение, РазмерФайла, Зашифрован = Ложь) Экспорт
	
	Если РаботаСФайламиСобытия.ЭтоЭлементРаботаСФайлами(ЭлементДанных) Тогда
		
		Если ЭлементДанных.ЭтоНовый() Тогда // добавлен новый элемент
			
			ДвоичныеДанные = ЭлементДанных.ФайлХранилище.Получить();
			ЭлементДанных.ФайлХранилище = Новый ХранилищеЗначения(Неопределено);
			
			ЭлементДанных.ДополнительныеСвойства.Вставить("ДвоичныеДанные", ДвоичныеДанные);
			
		Иначе
		
			ФайловыеФункции.ДобавитьНаДиск(ДвоичныеДанные, ПутьКФайлуНаТоме, СсылкаНаТом, 
				ВремяИзменения, ЭлементДанных.НомерВерсии, ИмяБезРасширения, Расширение, РазмерФайла, 
				Зашифрован, Неопределено, ЭлементДанных.Ссылка);
				
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Добавляет файл в тома при выполнении команды "разместить файлы начального образа"
// Параметры
//  СоответствиеПутейФайлов - Соответствие - соответствие УникальногоИдентификатора файла и пути на диске к файлу
//  ТипХраненияФайла - Перечисления.ТипыХраненияФайлов - тип хранения файлов
Процедура ДобавитьФайлыВТомаПриРазмещении(СоответствиеПутейФайлов, ТипХраненияФайла) Экспорт
	
	Выборка = Справочники.ВерсииФайлов.Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Объект = Выборка.ПолучитьОбъект();
		
		Если Объект.ТипХраненияФайла <> Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
			Продолжить;
		КонецЕсли;
		
		УникальныйИдентификатор = Строка(Объект.Ссылка.УникальныйИдентификатор());
		
		ПолныйПутьФайлаНаДиске = СоответствиеПутейФайлов.Получить(УникальныйИдентификатор);
		ПолныйПутьНовый = "";
		
		Если ПолныйПутьФайлаНаДиске = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ХранилищеФайла = Неопределено;
		
		// в базе-приемнике файлы должны храниться в информационной базе - значит там их и разместим (даже если в исходной базе они были в томах)
		Если ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
			
			Объект.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе;
			Объект.ПутьКФайлу = "";
			Объект.Том = Справочники.ТомаХраненияФайлов.ПустаяСсылка();
			
			ДвоичныеДанные = Новый ДвоичныеДанные(ПолныйПутьФайлаНаДиске);
			ХранилищеФайла = Новый ХранилищеЗначения(ДвоичныеДанные);
			
		Иначе // в базе-приемнике файлы должны храниться в томах на диске - переместим разархивированный файл на том
			
			ФайлИсх = Новый Файл(ПолныйПутьФайлаНаДиске);
			РазмерФайла = ФайлИсх.Размер();
			
			ВремяИзменения = Объект.ДатаМодификацииУниверсальная;
			ИмяБезРасширения = Объект.Наименование;
			Расширение = Объект.Расширение;
			
			ПолныйПутьНовый = ФайлИсх.Путь + ИмяБезРасширения + "." + Объект.Расширение;
			ПереместитьФайл(ПолныйПутьФайлаНаДиске, ПолныйПутьНовый);
			
			ПутьКФайлуНаТоме = "";
			СсылкаНаТом = Неопределено;
			// добавить в один из томов (где есть свободное место)
			
			ФайловыеФункции.ДобавитьНаДиск(ПолныйПутьНовый, ПутьКФайлуНаТоме, СсылкаНаТом, ВремяИзменения, 
				Объект.НомерВерсии, ИмяБезРасширения, Расширение, РазмерФайла, Объект.Зашифрован, Неопределено, Объект.Ссылка);
			
			Объект.ПутьКФайлу = ПутьКФайлуНаТоме;
			Объект.Том = СсылкаНаТом.Ссылка;
			
		КонецЕсли;
		
		Объект.ДополнительныеСвойства.Вставить("РазмещениеФайловВТомах", Истина); // чтобы прошла запись подписанных файлов
		Объект.Записать();
		
		Если ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
			ЗаписатьФайлВИнформационнуюБазу(Объект.Ссылка, ХранилищеФайла);	
		КонецЕсли;	
		
		Если НЕ ПустаяСтрока(ПолныйПутьНовый) Тогда
			УдалитьФайлы(ПолныйПутьНовый);
		КонецЕсли;	
		
	КонецЦикла;
	
КонецПроцедуры

// Удаляет регистрацию изменений - после размещения в томах
// Параметры
//  ПланОбменаСсылка - ПланОбмена.Ссылка - план обмена
Процедура УдалитьРегистрациюИзменений(ПланОбменаСсылка) Экспорт
	
	ПланыОбмена.УдалитьРегистрациюИзменений(ПланОбменаСсылка, Метаданные.Справочники.ВерсииФайлов);
	ПланыОбмена.УдалитьРегистрациюИзменений(ПланОбменаСсылка, Метаданные.Справочники.Файлы);
	ПланыОбмена.УдалитьРегистрациюИзменений(ПланОбменаСсылка, Метаданные.РегистрыСведений.ХранимыеФайлыВерсий);
	
КонецПроцедуры

// Получает текст запроса для извлечения текста
// Параметры
//  ТекстЗапроса - Строка - текст запроса для извлечения текста
Процедура ПолучитьТекстЗапроса(ТекстЗапроса) Экспорт
	
	ТекстЗапроса = 
			"ВЫБРАТЬ ПЕРВЫЕ 100
			|	ВерсииФайлов.Ссылка					КАК Ссылка,
			|	ВерсииФайлов.СтатусИзвлеченияТекста КАК СтатусИзвлеченияТекста,
			|	ВерсииФайлов.ТипХраненияФайла		КАК ТипХраненияФайла,
			|	ВерсииФайлов.Расширение				КАК Расширение

			|ИЗ
			|	Справочник.ВерсииФайлов КАК ВерсииФайлов
			|ГДЕ
			|	(ВерсииФайлов.СтатусИзвлеченияТекста = ЗНАЧЕНИЕ(Перечисление.СтатусыИзвлеченияТекстаФайлов.НеИзвлечен)
			|			ИЛИ ВерсииФайлов.СтатусИзвлеченияТекста = ЗНАЧЕНИЕ(Перечисление.СтатусыИзвлеченияТекстаФайлов.ПустаяСсылка))
			|	И НЕ ВерсииФайлов.Зашифрован";
	
КонецПроцедуры

// Получает полный путь к файлу на диске
// Параметры
//  ВерсияСсылка  - СправочникСсылка.Файлы - файл
//
// Возвращаемое значение:
//   Строка - полный путь к файлу на диске
Функция ПолучитьИмяФайлаСПутемКДвоичнымДанным(ВерсияСсылка) Экспорт
	
	ИмяФайлаСПутем = "";
	
	Если ВерсияСсылка.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда
		
		ХранилищеФайла = ПолучитьХранилищеФайлаИзИнформационнойБазы(ВерсияСсылка);
		ДвоичныеДанныеФайла = ХранилищеФайла.Получить();
		
		ИмяФайлаСПутем = ПолучитьИмяВременногоФайла(ВерсияСсылка.Расширение);
		ДвоичныеДанныеФайла.Записать(ИмяФайлаСПутем);
		
	Иначе
		Если НЕ ВерсияСсылка.Том.Пустая() Тогда
			ИмяФайлаСПутем = ФайловыеФункции.ПолныйПутьТома(ВерсияСсылка.Том) + ВерсияСсылка.ПутьКФайлу;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ИмяФайлаСПутем;
	
КонецФункции

// Записывает извлеченный текст
// Параметры
//  ТекущаяВерсия  - СправочникСсылка.ВерсииФайлов - версия файла
Процедура ЗаписатьИзвлеченныйТекст(ТекущаяВерсия) Экспорт
	
	ФайлЗаблокирован = Ложь;
	
	Файл = ТекущаяВерсия.Владелец;
	Если Файл.ТекущаяВерсия = ТекущаяВерсия.Ссылка Тогда
		Попытка
			ЗаблокироватьДанныеДляРедактирования(Файл);
			ФайлЗаблокирован = Истина;
		Исключение
			Возврат;
		КонецПопытки;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	НачатьТранзакцию();
	Попытка
		ТекущаяВерсия.Записать();
		
		Если Файл.ТекущаяВерсия = ТекущаяВерсия.Ссылка Тогда
			ФайлОбъект = Файл.ПолучитьОбъект();
			ФайлОбъект.ТекстХранилище = ТекущаяВерсия.ТекстХранилище;
			ФайлОбъект.Записать();
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
		УстановитьПривилегированныйРежим(Ложь);
		
		Если ФайлЗаблокирован Тогда
			РазблокироватьДанныеДляРедактирования(Файл);
		КонецЕсли;
		
	Исключение
		ОтменитьТранзакцию();
		УстановитьПривилегированныйРежим(Ложь);
		
		Если ФайлЗаблокирован Тогда
			РазблокироватьДанныеДляРедактирования(Файл);
		КонецЕсли;
		
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

// Возвращает количество файлов в томах
// Возвращаемое значение:
//   Число - число файлов в томах
Функция ПодсчитатьКоличествоФайловВТомах() Экспорт
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = "ВЫБРАТЬ
					|	ЕСТЬNULL(КОЛИЧЕСТВО(Версии.Ссылка), 0) КАК КоличествоФайлов
					|ИЗ
					|	Справочник.ВерсииФайлов КАК Версии
					|ГДЕ
					|	Версии.ТипХраненияФайла = ЗНАЧЕНИЕ(Перечисление.ТипыХраненияФайлов.ВТомахНаДиске)";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		Возврат Число(Выборка.КоличествоФайлов);
	КонецЕсли;
	
	Возврат 0;
	
КонецФункции

// Возвращает ИспользоватьЭлектронноЦифровыеПодписи
Функция ПолучитьИспользоватьЭлектронныеПодписи() Экспорт
	УстановитьПривилегированныйРежим(Истина);
	ИспользоватьЭлектронныеПодписи = Константы.ИспользоватьЭлектронныеПодписи.Получить();
	Возврат ИспользоватьЭлектронныеПодписи;
КонецФункции

// При переименовании пользователя переносит его настройки - РабочийКаталог, ДействиеПоДвойномуЩелчкуМыши и пр
//
Процедура ПеренестиНастройкиПриСменеИмениПользователя(знач ИмяТекущее, знач ИмяУстанавливаемое) Экспорт
	
	ФайловыеФункции.ПеренестиНастройку("НастройкиПрограммы", "ПоказыватьКолонкуРазмер", ИмяТекущее, ИмяУстанавливаемое);
	ФайловыеФункции.ПеренестиНастройку("НастройкиПрограммы", "ПоказыватьЗанятыеФайлыПриЗавершенииРаботы", ИмяТекущее, ИмяУстанавливаемое);
	ФайловыеФункции.ПеренестиНастройку("НастройкиПрограммы", "ПапкаДляСохранитьКак", ИмяТекущее, ИмяУстанавливаемое);
	ФайловыеФункции.ПеренестиНастройку("НастройкиПрограммы", "ПапкаДляОбновитьИзФайла", ИмяТекущее, ИмяУстанавливаемое);
	
	ФайловыеФункции.ПеренестиНастройку("НастройкиСравненияФайлов", "СпособСравненияВерсийФайлов", ИмяТекущее, ИмяУстанавливаемое);
	ФайловыеФункции.ПеренестиНастройку("ИмяПапкиВыгрузки", "ИмяПапкиВыгрузки", ИмяТекущее, ИмяУстанавливаемое);
	
	ФайловыеФункции.ПеренестиНастройку("НастройкиОткрытияФайлов", "ДействиеПоДвойномуЩелчкуМыши", ИмяТекущее, ИмяУстанавливаемое);
	ФайловыеФункции.ПеренестиНастройку("НастройкиОткрытияФайлов", "СпрашиватьРежимРедактированияПриОткрытииФайла", ИмяТекущее, ИмяУстанавливаемое);
	
КонецПроцедуры

// Заносит номер в регистр сведений НомераОтсканированныхФайлов
Процедура ЗанестиМаксимальныйНомерДляСканирования(Владелец, НовыйНомер) Экспорт
	
	// Подготовить структуру отбора по измерениям      
	СтруктураОтбора = Новый Структура;
	СтруктураОтбора.Вставить("Владелец", Владелец);
	
	НачатьТранзакцию();
	Попытка
		Блокировка = Новый БлокировкаДанных;
		ЭлементБлокировки = Блокировка.Добавить("РегистрСведений.НомераОтсканированныхФайлов");
		ЭлементБлокировки.Режим = РежимБлокировкиДанных.Исключительный;
		ЭлементБлокировки.УстановитьЗначение("Владелец", Владелец);
		Блокировка.Заблокировать();   		
		
		// Получить структуру с данными ресурсов записи
		СтруктураРесурсов = РегистрыСведений.НомераОтсканированныхФайлов.Получить(СтруктураОтбора);
		
		// Получить максимальный номер из регистра
		Номер = СтруктураРесурсов.Номер;
		Если НовыйНомер <= Номер Тогда // кто-то другой уже записал бОльший номер
			ОтменитьТранзакцию();
			Возврат;
		КонецЕсли;    
		
		Номер = НовыйНомер;
		
		// запишем новый номер в регистр
		НаборЗаписей = РегистрыСведений.НомераОтсканированныхФайлов.СоздатьНаборЗаписей();
		
		НаборЗаписей.Отбор.Владелец.Установить(Владелец);
		
		НоваяЗапись = НаборЗаписей.Добавить();
		НоваяЗапись.Владелец = Владелец;
		НоваяЗапись.Номер = Номер;
		
		НаборЗаписей.Записать();
		
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	
КонецПроцедуры

// Возвращает представление настроек сканирования - без распознавания
Функция ПолучитьПредставлениеНастроекСканирования(ИспользоватьImageMagickДляПреобразованияВPDF,
	ФорматКартинки,
	ФорматХраненияОдностраничный, ФорматХраненияМногостраничный, ФорматСканированногоИзображения,
	КачествоJPG, СжатиеTIFF, Разрешение, ЦветностьПеречисление,
	ПоворотПеречисление, РазмерБумагиПеречисление, ДвустороннееСканирование) Экспорт
	
	Представление = "";
	// информационная надпись вида:
	// "Формат хранения: PDF. Формат сканирования: JPG. Качество: 75. Формат хранения многостраничный: PDF. Разрешение: 200. Цветное";
	
	Если ИспользоватьImageMagickДляПреобразованияВPDF Тогда
		Если ФорматХраненияОдностраничный = Перечисления.ФорматыХраненияОдностраничныхФайлов.PDF Тогда
			Представление = Представление + НСтр("ru = 'Формат хранения: '");
			Представление = Представление + "PDF";
			Представление = Представление + ". ";
			Представление = Представление + НСтр("ru = 'Формат сканирования: '");
			Представление = Представление + ФорматКартинки;
			Представление = Представление + ". ";
		Иначе	
			Представление = Представление + НСтр("ru = 'Формат хранения: '");
			Представление = Представление + ФорматКартинки;
			Представление = Представление + ". ";
		КонецЕсли;
	Иначе	
		Представление = Представление + НСтр("ru = 'Формат хранения: '");
		Представление = Представление + ФорматКартинки;
		Представление = Представление + ". ";
	КонецЕсли;

	Если ВРег(ФорматКартинки) = "JPG" Тогда
		Представление = Представление +  НСтр("ru = 'Качество: '") + Строка(КачествоJPG) + ". ";
	КонецЕсли;	
	
	Если ВРег(ФорматКартинки) = "TIF" Тогда
		Представление = Представление +  НСтр("ru = 'Сжатие: '") + Строка(СжатиеTIFF) + ". ";
	КонецЕсли;
	
	Представление = Представление + НСтр("ru = 'Формат хранения многостраничный: '");
	Представление = Представление + Строка(ФорматХраненияМногостраничный);
	Представление = Представление + ". ";
	
	Если Разрешение <> -1 Тогда
		Представление = Представление + НСтр("ru = 'Разрешение: '") + Строка(Разрешение) + НСтр("ru = ' dpi. '") + Строка(ЦветностьПеречисление) + ". ";
	КонецЕсли;
	
	Если НЕ ПоворотПеречисление.Пустая() Тогда
		Представление = Представление +  НСтр("ru = 'Поворот: '") + Строка(ПоворотПеречисление) + ". ";
	КонецЕсли;	
	
	Если НЕ РазмерБумагиПеречисление.Пустая() Тогда
		Представление = Представление +  НСтр("ru = 'Размер бумаги: '") + Строка(РазмерБумагиПеречисление) + ". ";
	КонецЕсли;	
	
	Если ДвустороннееСканирование = Истина Тогда
		Представление = Представление +  НСтр("ru = 'Двустороннее сканирование'") + ". ";
	КонецЕсли;	
	
	Возврат Представление;
	
КонецФункции

// Возвращает представление настроек сканирования - без распознавания
Функция ПолучитьПредставлениеНастроекСканированияКраткое(
	ИспользоватьImageMagickДляПреобразованияВPDF,
	ФорматКартинки,
	ФорматХраненияОдностраничный, 
	ФорматХраненияМногостраничный) Экспорт
	
	Представление = "";
	// информационная надпись вида:
	// "Формат хранения: PDF. Формат хранения многостраничный: PDF.";
	
	Если ИспользоватьImageMagickДляПреобразованияВPDF Тогда
		Если ФорматХраненияОдностраничный = Перечисления.ФорматыХраненияОдностраничныхФайлов.PDF Тогда
			Представление = Представление + НСтр("ru = 'Формат хранения: '");
			Представление = Представление + "PDF";
			Представление = Представление + ". ";
		Иначе	
			Представление = Представление + НСтр("ru = 'Формат хранения: '");
			Представление = Представление + ФорматКартинки;
			Представление = Представление + ". ";
		КонецЕсли;
	Иначе	
		Представление = Представление + НСтр("ru = 'Формат хранения: '");
		Представление = Представление + ФорматКартинки;
		Представление = Представление + ". ";
	КонецЕсли;

	Представление = Представление + НСтр("ru = 'Формат хранения многостраничный: '");
	Представление = Представление + Строка(ФорматХраненияМногостраничный);
	Представление = Представление + ". ";
	
	Возврат Представление;
	
КонецФункции

// Преобразует параметры сканера в виде перечислений  - в числа
Процедура ПреобразоватьПеречисленияВПараметрыСканера(
	Разрешение, Цветность, Поворот, РазмерБумаги, СжатиеTIFFЧисло,
	РазрешениеПеречисление, ЦветностьПеречисление, ПоворотПеречисление, РазмерБумагиПеречисление, СжатиеTIFF) Экспорт
	
	
	Разрешение = -1;
	Если РазрешениеПеречисление = Перечисления.РазрешенияСканированногоИзображения.dpi200 Тогда
		Разрешение = 200; 
	ИначеЕсли РазрешениеПеречисление = Перечисления.РазрешенияСканированногоИзображения.dpi300 Тогда
		Разрешение = 300;
	ИначеЕсли РазрешениеПеречисление = Перечисления.РазрешенияСканированногоИзображения.dpi600 Тогда
		Разрешение = 600;
	ИначеЕсли РазрешениеПеречисление = Перечисления.РазрешенияСканированногоИзображения.dpi1200 Тогда
		Разрешение = 1200;
	КонецЕсли;
	
	Цветность = -1;
	Если ЦветностьПеречисление = Перечисления.ЦветностиИзображения.Монохромное Тогда
		Цветность = 0;
	ИначеЕсли ЦветностьПеречисление = Перечисления.ЦветностиИзображения.ГрадацииСерого Тогда
		Цветность = 1;
	ИначеЕсли ЦветностьПеречисление = Перечисления.ЦветностиИзображения.Цветное Тогда
		Цветность = 2;
	КонецЕсли;
	
	Поворот = 0;
	Если ПоворотПеречисление = Перечисления.СпособыПоворотаИзображения.НетПоворота Тогда
		Поворот = 0;
	ИначеЕсли ПоворотПеречисление = Перечисления.СпособыПоворотаИзображения.ВправоНа90 Тогда
		Поворот = 90;
	ИначеЕсли ПоворотПеречисление = Перечисления.СпособыПоворотаИзображения.ВправоНа180 Тогда
		Поворот = 180;
	ИначеЕсли ПоворотПеречисление = Перечисления.СпособыПоворотаИзображения.ВлевоНа90 Тогда
		Поворот = 270;
	КонецЕсли;
	
	РазмерБумаги = 0;
	Если РазмерБумагиПеречисление = Перечисления.РазмерыБумаги.НеЗадано Тогда
		РазмерБумаги = 0;
	ИначеЕсли РазмерБумагиПеречисление = Перечисления.РазмерыБумаги.A3 Тогда
		РазмерБумаги = 11;
	ИначеЕсли РазмерБумагиПеречисление = Перечисления.РазмерыБумаги.A4 Тогда
		РазмерБумаги = 1;
	ИначеЕсли РазмерБумагиПеречисление = Перечисления.РазмерыБумаги.A5 Тогда
		РазмерБумаги = 5;
	ИначеЕсли РазмерБумагиПеречисление = Перечисления.РазмерыБумаги.B4 Тогда
		РазмерБумаги = 6;
	ИначеЕсли РазмерБумагиПеречисление = Перечисления.РазмерыБумаги.B5 Тогда
		РазмерБумаги = 2;
	ИначеЕсли РазмерБумагиПеречисление = Перечисления.РазмерыБумаги.B6 Тогда
		РазмерБумаги = 7;
	ИначеЕсли РазмерБумагиПеречисление = Перечисления.РазмерыБумаги.C4 Тогда
		РазмерБумаги = 14;
	ИначеЕсли РазмерБумагиПеречисление = Перечисления.РазмерыБумаги.C5 Тогда
		РазмерБумаги = 15;
	ИначеЕсли РазмерБумагиПеречисление = Перечисления.РазмерыБумаги.C6 Тогда
		РазмерБумаги = 16;
	ИначеЕсли РазмерБумагиПеречисление = Перечисления.РазмерыБумаги.USLetter Тогда
		РазмерБумаги = 3;
	ИначеЕсли РазмерБумагиПеречисление = Перечисления.РазмерыБумаги.USLegal Тогда
		РазмерБумаги = 4;
	ИначеЕсли РазмерБумагиПеречисление = Перечисления.РазмерыБумаги.USExecutive Тогда
		РазмерБумаги = 10;
	КонецЕсли;
	
	СжатиеTIFFЧисло = 6; // БезСжатия
	Если СжатиеTIFF = Перечисления.ВариантыСжатияTIFF.LZW Тогда
		СжатиеTIFFЧисло = 2;
	ИначеЕсли СжатиеTIFF = Перечисления.ВариантыСжатияTIFF.RLE Тогда
		СжатиеTIFFЧисло = 5;
	ИначеЕсли СжатиеTIFF = Перечисления.ВариантыСжатияTIFF.БезСжатия Тогда
		СжатиеTIFFЧисло = 6;
	ИначеЕсли СжатиеTIFF = Перечисления.ВариантыСжатияTIFF.CCITT3 Тогда
		СжатиеTIFFЧисло = 3;
	ИначеЕсли СжатиеTIFF = Перечисления.ВариантыСжатияTIFF.CCITT4 Тогда
		СжатиеTIFFЧисло = 4;
	КонецЕсли;    
	
КонецПроцедуры

// Вернет Истина, если есть зашифрованные или занятые файлы у этого Владельца
Функция ЕстьЗашифрованныеИлиЗанятыеФайлы(Документ) Экспорт
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
		|	Файлы.Ссылка
		|ИЗ
		|	Справочник.Файлы КАК Файлы
		|ГДЕ
		|	Файлы.ВладелецФайла = &Документ
		|	И (Файлы.Редактирует <> &Редактирует
		|			ИЛИ Файлы.Зашифрован = &Зашифрован)";
	
	Запрос.УстановитьПараметр("Документ", Документ);
	Запрос.УстановитьПараметр("Редактирует", Справочники.Пользователи.ПустаяСсылка());
	Запрос.УстановитьПараметр("Зашифрован", Истина);
	
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		Возврат Ложь;
	КонецЕсли;	
	
	Возврат Истина;
	
КонецФункции	

// Обновляет размер файла и текущей версии. Нужно при загрузке шифрованного файла в почте
Процедура ОбновитьРазмерФайлаИВерсии(ДанныеФайла, РазмерФайла, УникальныйИдентификатор) Экспорт
	
	НачатьТранзакцию();
	Попытка
	
		ВерсияОбъект = ДанныеФайла.Версия.ПолучитьОбъект();
		ВерсияОбъект.Заблокировать();
		ВерсияОбъект.Размер = РазмерФайла;
		ВерсияОбъект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина); // чтобы прошла запись ранее подписанного объекта
		ВерсияОбъект.Записать();
		ВерсияОбъект.Разблокировать();
		
		ФайлОбъект = ДанныеФайла.Ссылка.ПолучитьОбъект();
		ЗаблокироватьДанныеДляРедактирования(ФайлОбъект.Ссылка, , УникальныйИдентификатор);
		ФайлОбъект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина); // чтобы прошла запись ранее подписанного объекта
		ФайлОбъект.Записать();
		РазблокироватьДанныеДляРедактирования(ФайлОбъект.Ссылка, УникальныйИдентификатор);
	
		ЗафиксироватьТранзакцию();
	Исключение
	     ОтменитьТранзакцию();
	     ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры	

// Помещает информацию о сертификатах шифрования в табличную часть файла
Процедура ЗанестиИнформациюОСертификатахШифрования(ФайлСсылка, МассивОтпечатков, УникальныйИдентификатор) Экспорт
	
	НачатьТранзакцию();
	Попытка
		
		ФайлОбъект = ФайлСсылка.ПолучитьОбъект();
		ЗаблокироватьДанныеДляРедактирования(ФайлСсылка, , УникальныйИдентификатор);
		
		Для Каждого ОтпечатокСтруктура Из МассивОтпечатков Цикл
			НоваяСтрока = ФайлОбъект.СертификатыШифрования.Добавить();
			НоваяСтрока.Отпечаток = ОтпечатокСтруктура.Отпечаток;
			НоваяСтрока.Представление = ОтпечатокСтруктура.Представление;
			НоваяСтрока.Сертификат = Новый ХранилищеЗначения(ОтпечатокСтруктура.Сертификат);
		КонецЦикла;
		
		ФайлОбъект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина); // чтобы прошла запись ранее подписанного объекта
		ФайлОбъект.Записать();
		РазблокироватьДанныеДляРедактирования(ФайлСсылка, УникальныйИдентификатор);
		
		ЗафиксироватьТранзакцию();
	Исключение
	     ОтменитьТранзакцию();
	     ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры	

// Ставит файлу признак Зашифрован
Процедура УстановитьПризнакЗашифрован(ФайлСсылка, Зашифрован, УникальныйИдентификатор = Неопределено) Экспорт
	
	ФайлОбъект = ФайлСсылка.ПолучитьОбъект();
	ЗаблокироватьДанныеДляРедактирования(ФайлСсылка, , УникальныйИдентификатор);
	
	ФайлОбъект.Зашифрован = Зашифрован;
	ФайлОбъект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина); // чтобы прошла запись ранее подписанного объекта
	ФайлОбъект.Записать();
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	               |	ВерсииФайлов.Ссылка
	               |ИЗ
	               |	Справочник.ВерсииФайлов КАК ВерсииФайлов
	               |ГДЕ
	               |	ВерсииФайлов.Владелец = &Владелец";
	Запрос.УстановитьПараметр("Владелец", ФайлСсылка);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		
		Объект = Выборка.Ссылка.ПолучитьОбъект();
		ЗаблокироватьДанныеДляРедактирования(Выборка.Ссылка, , УникальныйИдентификатор);
		
		Объект.Зашифрован = Зашифрован;
		Объект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина); // чтобы прошла запись ранее подписанного объекта
		Объект.Записать();
		РазблокироватьДанныеДляРедактирования(Выборка.Ссылка, УникальныйИдентификатор);
		
	КонецЦикла;
	
	РазблокироватьДанныеДляРедактирования(ФайлСсылка, УникальныйИдентификатор);
	
КонецПроцедуры	

// В справочнике ВерсииФайлов заполняет ДатаМодификацииФайла - из даты создания
Процедура ЗаполнитьДатуМодификацииФайла() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ВерсииФайлов.Ссылка
		|ИЗ
		|	Справочник.ВерсииФайлов КАК ВерсииФайлов";

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		
		Объект = Выборка.Ссылка.ПолучитьОбъект();
		
		Если Объект.ДатаМодификацииФайла = Дата("00010101000000") Тогда
			Объект.ДатаМодификацииФайла = Объект.ДатаСоздания;
			Объект.Записать();
		КонецЕсли;
		
	КонецЦикла;
	
	ПерезаписатьВсеФайлы(); // чтобы перенеслись значения реквизита ДатаМодификацииФайла из версии в файл
	
КонецПроцедуры	

// Делает ПолучитьДанныеФайла + ПоместитьВоВременноеХранилище (если файл хранится на диске)
// Функция возвращает структуру, содержащую различные сведения о Файле и версии
// Параметры
//  ФайлСсылка  - СправочникСсылка.Файлы - файл
//  ВерсияСсылка  - СправочникСсылка.ВерсииФайлов - версия файла
//  ИдентификаторФормы - уникальный идентификатор формы
//  РабочийКаталогВладельца - Строка - в ней возвращается рабочий каталог владельца файла
//
// Возвращаемое значение:
//   Структура - структура с данными файла
Функция ПолучитьДанныеФайлаДляОткрытияИПроверитьВозможноЗанятьФайл(ФайлСсылка, ВерсияСсылка = Неопределено, 
	ИдентификаторФормы = Неопределено, РабочийКаталогВладельца = Неопределено, 
	ВозможноЗанятьФайл = Неопределено, СтрокаОшибки = "") Экспорт
	
	ДанныеФайла = ПолучитьДанныеФайлаДляОткрытия(ФайлСсылка, ВерсияСсылка, 
		ИдентификаторФормы, РабочийКаталогВладельца);
	ВозможноЗанятьФайл = РаботаСФайламиПереопределяемый.ВозможноЗанятьФайл(ДанныеФайла, СтрокаОшибки);	
	
	Возврат ДанныеФайла;
	
КонецФункции

// Возвращает массив ссылок на файлы
// Параметры
//  Объект - ЛюбаяСсылка - владелец файла
//
// Возвращаемое значение:
//   Массив - массив файлов
Процедура ПолучитьПрикрепленныеФайлыКОбъекту(Объект, МассивФайлов) Экспорт
	
	Если ТипЗнч(Объект) = Тип("СправочникСсылка.Файлы") Тогда
		МассивФайлов.Добавить(Объект);
		Возврат;
	КонецЕсли;	
	
	ТипыПараметраКоманды = Метаданные.ОбщиеКоманды.ПрисоединенныеФайлы.ТипПараметраКоманды.Типы();
	ТипыВладельцев = Метаданные.Справочники.Файлы.Реквизиты.ВладелецФайла.Тип.Типы();
	
	Если ТипыВладельцев.Найти(ТипЗнч(Объект)) <> Неопределено
		И ТипыПараметраКоманды.Найти(ТипЗнч(Объект)) <> Неопределено Тогда
		
		МассивФайловЛокальный = ПолучитьВсеПодчиненныеФайлы(Объект);
		Для Каждого Строка Из МассивФайловЛокальный Цикл
			МассивФайлов.Добавить(Строка);
		КонецЦикла;	
		
		Возврат;
		
	КонецЕсли;
	
КонецПроцедуры

// Создает новый файл по аналогии с указанным и возвращает ссылку на него
// Параметры
//  ИсходныйФайл  - СправочникСсылка.Файлы - существующий файл
//  ВладелецНовогоФайла - ЛюбаяСсылка - владелец файла
//  ХранитьВерсии - если не равно Неопределено, ставится у скопированного файла (вместо значения оригинала)
//
// Возвращаемое значение:
//   СправочникСсылка.Файлы - новый файл
Функция СкопироватьФайл(ИсходныйФайл, ВладелецНовогоФайла, Ид = Неопределено, ХранитьВерсии = Неопределено) Экспорт
	
	Если ИсходныйФайл = Неопределено Или ИсходныйФайл.Пустая() Или ИсходныйФайл.ТекущаяВерсия.Пустая()Тогда
		Возврат Неопределено;
	КонецЕсли;    
	
	ХранитьВерсииНовыйФайл = ИсходныйФайл.ХранитьВерсии;
	
	Если ХранитьВерсии <> Неопределено Тогда
		ХранитьВерсииНовыйФайл = ХранитьВерсии;
	КонецЕсли;	
		
	НовыйФайл = СоздатьФайл(
		ВладелецНовогоФайла,
		ИсходныйФайл.Описание,
		ИсходныйФайл.ПолноеНаименование,
		ХранитьВерсииНовыйФайл,
		"",, Ид);
		
	ХранилищеФайла = Неопределено;
	Если ИсходныйФайл.ТекущаяВерсия.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе Тогда 
		ХранилищеФайла = ПолучитьХранилищеФайлаИзИнформационнойБазы(ИсходныйФайл.ТекущаяВерсия);
	КонецЕсли;	
		
	Версия = СоздатьВерсию(
		ТекущаяДата(),
		РаботаСФайламиКлиентСервер.ПолучитьУниверсальноеВремя(ТекущаяДата()),
		НовыйФайл,
		НовыйФайл.ПолноеНаименование,
		ИсходныйФайл.ТекущаяВерсия.Размер,
		ИсходныйФайл.ТекущаяВерсия.Расширение,
		ХранилищеФайла,
		ИсходныйФайл.ТекущаяВерсия.ТекстХранилище,
		Истина,
		ИсходныйФайл.ТекущаяВерсия);
	
	ОбновитьВерсиюВФайле(НовыйФайл, Версия, ИсходныйФайл.ТекущаяВерсия.ТекстХранилище);
	
	ВерсияОбъект = НовыйФайл.ТекущаяВерсия.ПолучитьОбъект();
	
	ИсходныйФайлСТЧЭП = ИсходныйФайл.ТекущаяВерсия.Метаданные().ТабличныеЧасти.Найти("ЭлектронныеЦифровыеПодписи") <> Неопределено;
	Если ИсходныйФайлСТЧЭП Тогда
		ЧислоПодписей = 0;
		Для Каждого Строка Из ИсходныйФайл.ТекущаяВерсия.ЭлектронныеЦифровыеПодписи Цикл
			НоваяСтрока = ВерсияОбъект.ЭлектронныеЦифровыеПодписи.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
			ЧислоПодписей = ЧислоПодписей + 1;
		КонецЦикла;
	Иначе
		ЧислоПодписей = РаботаСЭП.СкопироватьВсеПодписи(ИсходныйФайл.ТекущаяВерсия, НовыйФайл.ТекущаяВерсия);
	КонецЕсли;
	
	Если ЧислоПодписей <>  0 Тогда
		ФайлОбъект = НовыйФайл.ПолучитьОбъект();
		ФайлОбъект.ПодписанЭП = Истина;
		ФайлОбъект.Записать();
		
		ВерсияОбъект.ПодписанЭП = Истина;
		ВерсияОбъект.Записать();
	КонецЕсли;    
	
	Если ИсходныйФайл.Зашифрован Тогда
		
		ФайлОбъект = НовыйФайл.ПолучитьОбъект();
		ФайлОбъект.Зашифрован = Истина;
		
		Для Каждого Строка Из ИсходныйФайл.СертификатыШифрования Цикл
			НоваяСтрока = ФайлОбъект.СертификатыШифрования.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
		КонецЦикла;
		
		ФайлОбъект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина); // чтобы прошла запись ранее подписанного объекта
		ФайлОбъект.Записать();
		
		ВерсияОбъект = НовыйФайл.ТекущаяВерсия.ПолучитьОбъект();
		ВерсияОбъект.Зашифрован = Истина;
		ВерсияОбъект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина); // чтобы прошла запись ранее подписанного объекта
		ВерсияОбъект.Записать();
		
	КонецЕсли;    
	
	РаботаСФайламиВызовСервераПереопределяемый.ЗаполнитьРеквизитыФайлаИзИсходногоФайла(НовыйФайл, ИсходныйФайл);
	
	Возврат НовыйФайл;
	
КонецФункции

// Создает новые файлы по аналогии с указанными
// Параметры
//  МассивФайлов  - Массив - массив объектов СправочникСсылка.Файлы - существующие файлы
//  ВладелецНовогоФайла - ЛюбаяСсылка - владелец файла
//  ХранитьВерсии - если не равно Неопределено, ставится у скопированного файла (вместо значения оригинала)
Процедура СкопироватьФайлы(МассивФайлов, ВладелецНовогоФайла, ХранитьВерсии = Неопределено) Экспорт
	
	Для	каждого Файл Из МассивФайлов Цикл
		НовыйФайл = СкопироватьФайл(Файл, ВладелецНовогоФайла, , ХранитьВерсии);
	КонецЦикла;
	
КонецПроцедуры

// Получает количество версий с неизвлеченным текстом
Функция ПолучитьКоличествоВерсийСНеизвлеченнымТекстом() Экспорт
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = 
			"ВЫБРАТЬ
			|	КОЛИЧЕСТВО(*) КАК ЧислоВерсий
			|ИЗ
			|	Справочник.ВерсииФайлов КАК ВерсииФайлов
			|ГДЕ
			|	(ВерсииФайлов.СтатусИзвлеченияТекста = ЗНАЧЕНИЕ(Перечисление.СтатусыИзвлеченияТекстаФайлов.НеИзвлечен)
			|			ИЛИ ВерсииФайлов.СтатусИзвлеченияТекста = ЗНАЧЕНИЕ(Перечисление.СтатусыИзвлеченияТекстаФайлов.ПустаяСсылка))
			|	И (НЕ ВерсииФайлов.Зашифрован)
			|	И (НЕ ВерсииФайлов.ФайлУдален)";
			
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Результат = Выборка.ЧислоВерсий;
	
	Возврат Результат;
			
КонецФункции

// Получает текст запроса для извлечения текста
Процедура ПолучитьТекстЗапросаИзвлеченияТекста(ТекстЗапроса, КоличествоФайловВПорции) Экспорт
	
	ТекстЗапроса = 
			"ВЫБРАТЬ {КоличествоФайловВПорции}
			|	ВерсииФайлов.Ссылка КАК Ссылка,
			|	ВерсииФайлов.СтатусИзвлеченияТекста КАК СтатусИзвлеченияТекста,
			|	ВерсииФайлов.ТипХраненияФайла КАК ТипХраненияФайла,
			|	ВерсииФайлов.Расширение КАК Расширение,
			|	ВерсииФайлов.Владелец.Наименование КАК Наименование
			|ИЗ
			|	Справочник.ВерсииФайлов КАК ВерсииФайлов
			|ГДЕ
			|	(ВерсииФайлов.СтатусИзвлеченияТекста = ЗНАЧЕНИЕ(Перечисление.СтатусыИзвлеченияТекстаФайлов.НеИзвлечен)
			|			ИЛИ ВерсииФайлов.СтатусИзвлеченияТекста = ЗНАЧЕНИЕ(Перечисление.СтатусыИзвлеченияТекстаФайлов.ПустаяСсылка))
			|	И (НЕ ВерсииФайлов.Зашифрован)
			|	И (НЕ ВерсииФайлов.ФайлУдален)";
			
	Если КоличествоФайловВПорции <> 0 Тогда			
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "{КоличествоФайловВПорции}", "ПЕРВЫЕ " + Формат(КоличествоФайловВПорции, "ЧГ=; ЧН="));
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "{КоличествоФайловВПорции}", "");
	КонецЕсли;	
	
КонецПроцедуры

// получает количество версий файлов, которые нуждаются в распознавании
Функция ПолучитьКоличествоНераспознанныхВерсий() Экспорт
	
	МассивВерсий = Новый Массив;
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = 			
	 "ВЫБРАТЬ
	 |	КОЛИЧЕСТВО(*) КАК ЧислоВерсий
	 |ИЗ
	 |	Справочник.ВерсииФайлов КАК ВерсииФайлов
	 |ГДЕ
	 |	ВерсииФайлов.СтатусРаспознаванияТекста = &Статус
	 |	И ВерсииФайлов.Зашифрован = ЛОЖЬ
	 |	И ВерсииФайлов.ФайлУдален = ЛОЖЬ";
	
	Запрос.УстановитьПараметр("Статус", Перечисления.СтатусыРаспознаванияТекста.НужноРаспознать);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	
	Результат = Выборка.ЧислоВерсий;
	Возврат Результат;
	
КонецФункции

// проверяет редактирование файла текущим пользователем с учетом прав доступа
Функция ФайлРедактируетТекущийПользователь(ФайлСсылка) Экспорт 
	
	Если Не ПравоДоступа("Чтение", Метаданные.Справочники.Файлы) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ИСТИНА 
	|ИЗ
	|	Справочник.Файлы КАК Файлы
	|ГДЕ
	|	Файлы.Ссылка = &ФайлСсылка
	|	И Файлы.Редактирует = &Редактирует";
	
	Запрос.УстановитьПараметр("ФайлСсылка", ФайлСсылка);
	Запрос.УстановитьПараметр("Редактирует", Пользователи.ТекущийПользователь());
	
	Результат = Запрос.Выполнить();
	Если Не Результат.Пустой() Тогда 
		Возврат Истина;
	КонецЕсли;	
	
	Возврат Ложь;
	
КонецФункции

// Получает занятые файлы у владельца
Функция ПолучитьПриложенныеФайлы(ВладелецФайла, ТекущийПользователь) Экспорт 
	
	МассивФайлов = Новый Массив;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Файлы.Ссылка КАК Ссылка,
	|	Файлы.Редактирует КАК Редактирует
	|ИЗ
	|	Справочник.Файлы КАК Файлы
	|ГДЕ
	|	Файлы.ВладелецФайла = &ВладелецФайла
	|	И Файлы.Редактирует = &Редактирует";
	
	Запрос.УстановитьПараметр("ВладелецФайла", ВладелецФайла);
	Запрос.УстановитьПараметр("Редактирует", ТекущийПользователь);
	
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	Пока Выборка.Следующий() Цикл
		МассивФайлов.Добавить(Выборка.Ссылка);
	КонецЦикла;
	
	Возврат МассивФайлов;
	
КонецФункции

// Обработчик регламентного задания ОбработкаПравилРазмещенияФайловВТомах
Процедура ОбработкаПравилРазмещенияФайловВТомах() Экспорт
	
	Перем СсылкаНаТом;
	
	Пока Истина Цикл
	
		Запрос = Новый Запрос;
		Запрос.Текст = 
			"ВЫБРАТЬ ПЕРВЫЕ 100
			|	ОчередьВерсийФайловДляРазмещенийВТомах.Версия.Ссылка КАК Ссылка
			|ИЗ
			|	РегистрСведений.ОчередьВерсийФайловДляРазмещенийВТомах КАК ОчередьВерсийФайловДляРазмещенийВТомах";
					   
		ТаблицаВерсий = Запрос.Выполнить().Выгрузить();
		
		Если ТаблицаВерсий.Количество() = 0 Тогда
			Возврат;
		КонецЕсли;	
		
		Для Каждого Строка Из ТаблицаВерсий Цикл
			
			ВерсияСсылка = Строка.Ссылка;
			
			ГруппаТомов = ФайловыеФункции.ВыбратьГруппуТомовДляРазмещенияВерсии(ВерсияСсылка);
			ТаблицаТомов = ФайловыеФункции.ПолучитьСписокТомовВГруппе(ГруппаТомов);
			
			// Если версия уже в нужной группе томов - перенос не нужно делать. Если версии в группе томов нет - делаем перенос.
			Если ТаблицаТомов.Найти(ВерсияСсылка.Том, "Ссылка") = Неопределено Тогда 
				
				Версия = ВерсияСсылка.ПолучитьОбъект();
				ПутьКФайлу = "";
				
				Если НЕ Версия.Том.Пустая() Тогда
					
					НачатьТранзакцию();
					Попытка
						
						ПрежнийТом = Версия.Том;
						
						// Выполняем перенос
						ПрежнийПолныйПутьФайла = ФайловыеФункции.ПолныйПутьТома(ВерсияСсылка.Том) + ВерсияСсылка.ПутьКФайлу; 
						ПутьКФайлу = "";
						
						// Добавить в один из томов (где есть свободное место)
						ФайловыеФункции.ДобавитьНаДиск(ПрежнийПолныйПутьФайла, ПутьКФайлу, СсылкаНаТом, Версия.ДатаМодификацииУниверсальная, 
							Версия.НомерВерсии, Версия.Наименование, Версия.Расширение, Версия.Размер, Версия.Зашифрован, 
							Неопределено, Версия.Ссылка);
						
						Версия.ПутьКФайлу = ПутьКФайлу;
						Версия.Том = СсылкаНаТом.Ссылка;
						Версия.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина); // чтобы прошла запись ранее подписанного объекта
						Версия.Записать();
						
						УдалитьИзРегистраОчередьВерсийФайловДляРазмещенийВТомах(ВерсияСсылка);
						
						// Удаляем файл в прежнем месте (томе)
						ФайлНаДиске = Новый Файл(ПрежнийПолныйПутьФайла);
						ФайлНаДиске.УстановитьТолькоЧтение(Ложь);
						УдалитьФайлы(ПрежнийПолныйПутьФайла);
						
						// Удаляем пустые подкаталоги типа А, B, А1,..
						ПутьСПодкаталогом = ФайлНаДиске.Путь;
						МассивФайловВКаталоге = НайтиФайлы(ПутьСПодкаталогом, "*.*");
						Если МассивФайловВКаталоге.Количество() = 0 Тогда
							УдалитьФайлы(ПутьСПодкаталогом);
						КонецЕсли;
						
						ЗафиксироватьТранзакцию();
						
						// Записать в журнал регистрации про перенос
						СообщениеОбУспехе = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
							НСтр("ru = 'Версия файла ""%1.%2"" (%3) перенесена из тома хранения файлов ""%4"" в том ""%5"".'"),
							Строка(ВерсияСсылка.Владелец), Версия.Расширение, 
							ПолучитьНавигационнуюСсылку(ВерсияСсылка),
							Строка(ПрежнийТом), Строка(СсылкаНаТом));
						ЗаписьЖурналаРегистрации(НСтр("ru='Перенос версии файла в том'"), УровеньЖурналаРегистрации.Информация, 
							Метаданные.Справочники.Файлы, ВерсияСсылка.Владелец, СообщениеОбУспехе);
						
					Исключение
							
						ОтменитьТранзакцию();
						
						ФайлНаДиске = Новый Файл(ПутьКФайлу);
						ФайлНаДиске.УстановитьТолькоЧтение(Ложь);
						УдалитьФайлы(ПутьКФайлу);
						
						// Записать ошибку в журнал регистрации и продолжить работу
						СообщениеОбОшибке = СформироватьТекстОшибкиПолученияФайлСТомаДляАдминистратора(ИнформацияОбОшибке(), ВерсияСсылка.Владелец);
						ЗаписьЖурналаРегистрации(НСтр("ru='Ошибка переноса версии файла в том'"), УровеньЖурналаРегистрации.Ошибка, 
							Метаданные.Справочники.Файлы, ВерсияСсылка.Владелец, СообщениеОбОшибке);
						
					КонецПопытки;
					
				Иначе
					// Версия без тома - возможно обработкой перенесли в базу
					УдалитьИзРегистраОчередьВерсийФайловДляРазмещенийВТомах(ВерсияСсылка);
				КонецЕсли;	
				
			Иначе
				// Версия уже в нужном томе - удалим ее из очереди
				УдалитьИзРегистраОчередьВерсийФайловДляРазмещенийВТомах(ВерсияСсылка);
			КонецЕсли;	
		
		КонецЦикла;
		
	КонецЦикла;
		
КонецПроцедуры

Процедура УдалитьИзРегистраОчередьВерсийФайловДляРазмещенийВТомах(Версия)
	
	УстановитьПривилегированныйРежим(Истина);
	
	НаборЗаписей = РегистрыСведений.ОчередьВерсийФайловДляРазмещенийВТомах.СоздатьНаборЗаписей();
	
	НаборЗаписей.Отбор.Версия.Установить(Версия);
	
	// не добавляем записи в набор - чтобы все стереть
	НаборЗаписей.Записать();
	
КонецПроцедуры	

// Формирует очередь при изменении правил размещения файлов в томах. Возвращает число файлов, добавленных в очередь
Функция ПрименитьПравилаДляФормированияОчереди() Экспорт
	
	Если Не ИспользоватьРазмещениеВТомахПоУсловиям() Тогда
		Возврат 0;
	КонецЕсли;	
	
	ЧислоВерсийПоставленныхВОчередь = 0;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ПравилаРазмещенияФайловВТомах.Ссылка,
		|	ПравилаРазмещенияФайловВТомах.ГруппаТомов,
		|	ПравилаРазмещенияФайловВТомах.ПометкаУдаления,
		|	ПравилаРазмещенияФайловВТомах.Порядок КАК Порядок,
		|	ПравилаРазмещенияФайловВТомах.Условие
		|ИЗ
		|	Справочник.ПравилаРазмещенияФайловВТомах КАК ПравилаРазмещенияФайловВТомах
		|ГДЕ
		|	ПравилаРазмещенияФайловВТомах.ПометкаУдаления = ЛОЖЬ
		|
		|УПОРЯДОЧИТЬ ПО
		|	Порядок";

	ТаблицаПравил = Запрос.Выполнить().Выгрузить();
	
	СхемаКомпоновкиДанных = Справочники.ПравилаРазмещенияФайловВТомах.ПолучитьМакет("Версии");
	АдресСхемы = ПоместитьВоВременноеХранилище(СхемаКомпоновкиДанных, Новый УникальныйИдентификатор());
	
	Для НомерПравила = 0 По ТаблицаПравил.Количество() - 1 Цикл 
		
		КомпоновщикДляОчереди = Новый КомпоновщикНастроекКомпоновкиДанных;
		ИсточникНастроек = Новый ИсточникДоступныхНастроекКомпоновкиДанных(АдресСхемы);
		КомпоновщикДляОчереди.Инициализировать(ИсточникНастроек);
		КомпоновщикДляОчереди.ЗагрузитьНастройки(СхемаКомпоновкиДанных.НастройкиПоУмолчанию);
		
		КомпоновщикТекущегоПравила = Новый КомпоновщикНастроекКомпоновкиДанных;
		ИсточникНастроек = Новый ИсточникДоступныхНастроекКомпоновкиДанных(АдресСхемы);
		КомпоновщикТекущегоПравила.Инициализировать(ИсточникНастроек);
		КомпоновщикТекущегоПравила.ЗагрузитьНастройки(ТаблицаПравил[НомерПравила].Условие.Получить());
		
		ЭлементыОтбора = КомпоновщикДляОчереди.Настройки.Отбор.Элементы;
		
		// Текущее правило размещаем в группе И - создаем группу И
		НоваяГруппаЭлементовОтбора = ЭлементыОтбора.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
		НоваяГруппаЭлементовОтбора.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ;
		
		// Последнее правило не используем - там нет условия
		Если НомерПравила <> ТаблицаПравил.Количество() - 1 Тогда
			СкопироватьОтбор(НоваяГруппаЭлементовОтбора, КомпоновщикТекущегоПравила.Настройки.Отбор);
		КонецЕсли;
		
		Если НомерПравила > 0 Тогда // Если есть предыдущие правила
			
			// Все предыдущие правила - в группе НЕ, а внутри еще группа ИЛИ
			НоваяГруппаЭлементовОтбораНе = ЭлементыОтбора.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
			НоваяГруппаЭлементовОтбораНе.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе;
			
			НоваяГруппаЭлементовОтбораИли = НоваяГруппаЭлементовОтбораНе.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
			НоваяГруппаЭлементовОтбораИли.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли;
			
			Для НомерПредыдущегоПравила = 0 По НомерПравила-1 Цикл
				
				КомпоновщикПредыдущегоПравила = Новый КомпоновщикНастроекКомпоновкиДанных;
				ИсточникНастроек = Новый ИсточникДоступныхНастроекКомпоновкиДанных(АдресСхемы);
				КомпоновщикПредыдущегоПравила.Инициализировать(ИсточникНастроек);
				КомпоновщикПредыдущегоПравила.ЗагрузитьНастройки(ТаблицаПравил[НомерПредыдущегоПравила].Условие.Получить());
				
				СкопироватьОтбор(НоваяГруппаЭлементовОтбораИли, КомпоновщикПредыдущегоПравила.Настройки.Отбор);
				
			КонецЦикла;
			
		КонецЕсли;
		
		// Все тома из группы текущего условия - в группе НЕ, а внутри еще группа ИЛИ
		ТаблицаТомов = ПолучитьТаблицуТомов(ТаблицаПравил[НомерПравила].ГруппаТомов);
		
		НоваяГруппаЭлементовОтбораНе = ЭлементыОтбора.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
		НоваяГруппаЭлементовОтбораНе.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе;
		
		НоваяГруппаЭлементовОтбораИли = НоваяГруппаЭлементовОтбораНе.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
		НоваяГруппаЭлементовОтбораИли.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли;
		
		Для Каждого СтрокаТома Из ТаблицаТомов Цикл
			
			СсылкаНаТом = СтрокаТома.Ссылка;
			
			НовыйЭлементОтбора = НоваяГруппаЭлементовОтбораИли.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
			НовыйЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("Том");
			НовыйЭлементОтбора.Использование = Истина;
			НовыйЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
			НовыйЭлементОтбора.ПравоеЗначение = СсылкаНаТом;
			
		КонецЦикла;	
		
		// Версия должна быть не в информационной базе, а в томах на диске
		НовыйЭлементОтбора = НоваяГруппаЭлементовОтбора.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		НовыйЭлементОтбора.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("ТипХраненияФайла");
		НовыйЭлементОтбора.Использование = Истина;
		НовыйЭлементОтбора.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
		НовыйЭлементОтбора.ПравоеЗначение = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске;
		
		КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
		
		МакетКомпоновки = КомпоновщикМакета.Выполнить(СхемаКомпоновкиДанных, 
			КомпоновщикДляОчереди.ПолучитьНастройки()
			,
			,
			, Тип("ГенераторМакетаКомпоновкиДанныхДляКоллекцииЗначений"));
	    ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных;
		ПроцессорКомпоновки.Инициализировать(МакетКомпоновки);
	    ТаблицаРезультата = Новый ТаблицаЗначений;
	    ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВКоллекциюЗначений;
	    ПроцессорВывода.УстановитьОбъект(ТаблицаРезультата);
		ПроцессорВывода.Вывести(ПроцессорКомпоновки);
		
		// Запишем в очередь
		Для Каждого Результат Из ТаблицаРезультата Цикл
			
			МенеджерЗаписи = РегистрыСведений.ОчередьВерсийФайловДляРазмещенийВТомах.СоздатьМенеджерЗаписи();
			МенеджерЗаписи.Версия = Результат.Ссылка;
			МенеджерЗаписи.Записать(Истина);
			ЧислоВерсийПоставленныхВОчередь = ЧислоВерсийПоставленныхВОчередь + 1;
			
		КонецЦикла;	
		
	КонецЦикла;
	
	Возврат ЧислоВерсийПоставленныхВОчередь;
	
КонецФункции

// Получает все тома из группы
Функция ПолучитьТаблицуТомов(ГруппаТомов) Экспорт

	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ТомаХраненияФайлов.Ссылка
		|ИЗ
		|	Справочник.ТомаХраненияФайлов КАК ТомаХраненияФайлов
		|ГДЕ
		|	ТомаХраненияФайлов.ПометкаУдаления = ЛОЖЬ
		|	И ТомаХраненияФайлов.Родитель = &Родитель
		|
		|УПОРЯДОЧИТЬ ПО
		|	ТомаХраненияФайлов.ПорядокЗаполнения";

	Запрос.УстановитьПараметр("Родитель", ГруппаТомов);
	ТаблицаТомов = Запрос.Выполнить().Выгрузить();
	
	Возврат ТаблицаТомов;
	
КонецФункции

// Копирует отбор СКД
Процедура СкопироватьОтбор(Приемник, Источник, УдалятьПредставлениеГруппы = Ложь, УдалятьНеиспользуемые = Истина) Экспорт
	
	Для каждого ЭлементОтбораИсточник Из Источник.Элементы Цикл
		
		Если УдалятьНеиспользуемые И (Не ЭлементОтбораИсточник.Использование) Тогда
			Продолжить;
		КонецЕсли;
		
		Если ТипЗнч(ЭлементОтбораИсточник) = Тип("ЭлементОтбораКомпоновкиДанных") И 
			ЭлементОтбораИсточник.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("Поиск") Тогда
			Продолжить;
		КонецЕсли;
		
		ЭлементОтбора = Приемник.Элементы.Добавить(ТипЗнч(ЭлементОтбораИсточник));
		ЗаполнитьЗначенияСвойств(ЭлементОтбора,ЭлементОтбораИсточник);
		Если ТипЗнч(ЭлементОтбораИсточник) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			Если УдалятьПредставлениеГруппы Тогда
				ЭлементОтбора.Представление = "";
			КонецЕсли;
			СкопироватьОтбор(ЭлементОтбора, ЭлементОтбораИсточник);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Найти все правила размещения для тома
Функция НайтиПравилаРазмещенияДляТома(ГруппаТомов) Экспорт
	
	ПравилаОтобранные = Новый СписокЗначений;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ПравилаРазмещенияФайловВТомах.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.ПравилаРазмещенияФайловВТомах КАК ПравилаРазмещенияФайловВТомах
		|ГДЕ
		|	ПравилаРазмещенияФайловВТомах.ПометкаУдаления = ЛОЖЬ
		|	И ПравилаРазмещенияФайловВТомах.ГруппаТомов = &ГруппаТомов
		|
		|УПОРЯДОЧИТЬ ПО
		|	ПравилаРазмещенияФайловВТомах.Порядок";
		
	Запрос.УстановитьПараметр("ГруппаТомов", ГруппаТомов);

	ТаблицаПравилВыгруженная = Запрос.Выполнить().Выгрузить();
	Возврат ТаблицаПравилВыгруженная;
	
КонецФункции

// Найти все правила размещения для тома  - с подробным выводом колонок с информацией
Функция НайтиПравилаРазмещенияДляТомаПодробно(ГруппаТомов) Экспорт
	
	ПравилаОтобранные = Новый СписокЗначений;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ПравилаРазмещенияФайловВТомах.Ссылка КАК Ссылка,
		|	ПравилаРазмещенияФайловВТомах.Комментарий,
		|	ПравилаРазмещенияФайловВТомах.Ответственный,
		|	ПравилаРазмещенияФайловВТомах.ПредставлениеУсловия
		|ИЗ
		|	Справочник.ПравилаРазмещенияФайловВТомах КАК ПравилаРазмещенияФайловВТомах
		|ГДЕ
		|	ПравилаРазмещенияФайловВТомах.ПометкаУдаления = ЛОЖЬ
		|	И ПравилаРазмещенияФайловВТомах.ГруппаТомов = &ГруппаТомов
		|
		|УПОРЯДОЧИТЬ ПО
		|	ПравилаРазмещенияФайловВТомах.Порядок";
		
	Запрос.УстановитьПараметр("ГруппаТомов", ГруппаТомов);

	ТаблицаПравилВыгруженная = Запрос.Выполнить().Выгрузить();
	Возврат ТаблицаПравилВыгруженная;
	
КонецФункции

// Непосредственно удаление версии
Процедура ВыполнитьУдалениеНеактивнойВерсииФайла(ВерсияСсылка, Параметры, ИмяКаталогаСохранения,
	МассивРезультатов, ВладелецВерсии, ЧислоФайлов, ЧислоВерсий, РазмерВерсий) Экспорт
	
	ВерсияОбъект = ВерсияСсылка.ПолучитьОбъект();
	ПрежнееИмяФайлаСПутем = "";
	ПолноеИмяФайла = "";
	
	ОчищатьДанныеДляПолнотекстовогоПоиска = ПолучитьОчищатьДанныеДляПолнотекстовогоПоиска();
	
	Попытка
		
		ЗаблокироватьДанныеДляРедактирования(ВерсияСсылка);
		
		НачатьТранзакцию();
		
		ПолноеИмяФайла = ИмяКаталогаСохранения + Лев(ВерсияОбъект.ПолноеНаименование, 50) + "_" +
			Строка(ВерсияСсылка.УникальныйИдентификатор()) + "." + ВерсияОбъект.Расширение;
			
		Если ВерсияОбъект.ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
			ПрежнееИмяФайлаСПутем = ФайловыеФункции.ПолныйПутьТома(ВерсияОбъект.Том) + ВерсияОбъект.ПутьКФайлу;
			
			Файл = Новый Файл(ПрежнееИмяФайлаСПутем);
			Файл.УстановитьТолькоЧтение(Ложь);
			ПереместитьФайл(ПрежнееИмяФайлаСПутем, ПолноеИмяФайла);
			ВерсияОбъект.Том = Справочники.ТомаХраненияФайлов.ПустаяСсылка();
			ВерсияОбъект.ПутьКФайлу = "";
		Иначе
			ХранимыйФайл = ПолучитьХранилищеФайлаИзИнформационнойБазы(ВерсияСсылка);
			ДвоичныеДанныеФайла = ХранимыйФайл.Получить();
			ДвоичныеДанныеФайла.Записать(ПолноеИмяФайла);
			УдалитьЗаписьИзРегистраХранимыеФайлыВерсий(ВерсияСсылка);
		КонецЕсли;	
		
		Если ВладелецВерсии <> Параметры.ВладелецВерсии Тогда
			
			ВладелецВерсии = Параметры.ВладелецВерсии;
			ЧислоФайлов = ЧислоФайлов + 1;
			
		КонецЕсли;	
		
		ЧислоВерсий = ЧислоВерсий + 1;
		РазмерВерсий = РазмерВерсий + ВерсияОбъект.Размер;
		
		ПредставлениеВладельца = НСтр("ru='Файл: '") + Строка(ВладелецВерсии) + "." + ВерсияОбъект.Расширение;
		
		ОписаниеВерсии = Новый Структура("ВладелецВерсии, ПредставлениеВладельца, Автор, НомерВерсии, Комментарий, 
		|ДатаСоздания, Размер", 
			ВладелецВерсии, ПредставлениеВладельца, ВерсияОбъект.Автор, ВерсияОбъект.НомерВерсии, 
			ВерсияОбъект.Комментарий, 
			ВерсияОбъект.ДатаСоздания, ВерсияОбъект.Размер);
		МассивРезультатов.Добавить(ОписаниеВерсии);
		
		Если ОчищатьДанныеДляПолнотекстовогоПоиска Тогда
			ВерсияОбъект.ТекстХранилище = Новый ХранилищеЗначения(""); // очистим извлеченный текст
		КонецЕсли;	
		
		ВерсияОбъект.ФайлУдален = Истина;
		// чтобы прошла запись ранее подписанного объекта
		ВерсияОбъект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина); 
		ВерсияОбъект.Записать();
		
		УдалитьИзРегистраОбращенияКВерсиямФайлов(ВерсияСсылка);
		ЗаписатьВРегистрСведенияОСохраненииКопийУстаревшихВерсий(ВерсияСсылка, ПолноеИмяФайла);
		
		ЗафиксироватьТранзакцию();
		
		РазблокироватьДанныеДляРедактирования(ВерсияСсылка);
		
		// Записать текст в журнал регистрации и продолжить работу
		СообщениеОбУспехе = СформироватьТекстОшибкиУдаленияВерсии(ИнформацияОбОшибке(), ВерсияСсылка);
		ЗаписьЖурналаРегистрации(НСтр("ru='Выполнена очистка неактивной версии файла'"), 
			УровеньЖурналаРегистрации.Информация, 
			Метаданные.Справочники.ВерсииФайлов, ВерсияСсылка, СообщениеОбУспехе);
		
	Исключение
		
		ОтменитьТранзакцию();
		
		// Записать ошибку в журнал регистрации и продолжить работу
		СообщениеОбОшибке = СформироватьТекстОшибкиУдаленияВерсии(ИнформацияОбОшибке(), ВерсияСсылка);
		ЗаписьЖурналаРегистрации(НСтр("ru='Ошибка очистки неактивной версии файла'"), 
			УровеньЖурналаРегистрации.Ошибка, 
			Метаданные.Справочники.ВерсииФайлов, ВерсияСсылка, СообщениеОбОшибке);
			
		// Если было хранение в томах - вернем файл на прежнее место
		Если ЗначениеЗаполнено(ПрежнееИмяФайлаСПутем) Тогда
			ПереместитьФайл(ПолноеИмяФайла, ПрежнееИмяФайлаСПутем);
		КонецЕсли;
			
	КонецПопытки;
	
КонецПроцедуры

// Обработчик регламентного задания УдалениеНеактивныхВерсийФайлов
Процедура УдалениеНеактивныхВерсийФайлов() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если Не ПолучитьФункциональнуюОпцию("УдалятьНеактивныеВерсии") Тогда 
		Возврат;
	КонецЕсли;
	
	СрокХраненияНеактивныхВерсий = ПолучитьСрокХраненияНеактивныхВерсий(); // срок хранения в днях
	
	ПутьСохраненияУдаляемыхВерсий = ПолучитьПутьСохраненияУдаляемыхВерсий();
	Если Не ЗначениеЗаполнено(ПутьСохраненияУдаляемыхВерсий) Тогда
		
		ЗаписьЖурналаРегистрации(НСтр("ru='Очистка неактивных версий файлов'"), 
		УровеньЖурналаРегистрации.Ошибка, 
		, , НСтр("ru = 'Не указан путь сохранения очищаемых версий'"));
		
		Возврат;
		
	КонецЕсли;	
	
	ДатаОтсечения = ТекущаяДатаСеанса() - СрокХраненияНеактивныхВерсий * 86400; //  86400 - секунд в сутках
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ВерсииФайлов.Ссылка,
		|	ЕСТЬNULL(ОбращенияКВерсиямФайлов.ДатаПоследнегоОбращения, ВерсииФайлов.ДатаСоздания) КАК ДатаПоследнегоОбращения,
		|	ВерсииФайлов.Владелец КАК ВладелецВерсии
		|ИЗ
		|	Справочник.ВерсииФайлов КАК ВерсииФайлов
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ОбращенияКВерсиямФайлов КАК ОбращенияКВерсиямФайлов
		|		ПО (ОбращенияКВерсиямФайлов.Версия = ВерсииФайлов.Ссылка)
		|ГДЕ
		|	ЕСТЬNULL(ОбращенияКВерсиямФайлов.ДатаПоследнегоОбращения, ВерсииФайлов.ДатаСоздания) < &ДатаОтсечения
		|	И ВерсииФайлов.Ссылка <> ВерсииФайлов.Владелец.ТекущаяВерсия
		|	И ВерсииФайлов.Владелец.НеУдалятьСтарыеВерсии = ЛОЖЬ
		|	И ВерсииФайлов.ФайлУдален = ЛОЖЬ
		|
		|УПОРЯДОЧИТЬ ПО
		|	ВерсииФайлов.Владелец.Ссылка";
				   
	Запрос.УстановитьПараметр("ДатаОтсечения", ДатаОтсечения);
	РезультатЗапроса = Запрос.Выполнить();
	
	Если РезультатЗапроса.Пустой() Тогда
		Возврат;
	КонецЕсли;	
	
	ИмяКаталогаСохранения = ПолучитьИмяКаталогаСохранения();
	
	ВладелецВерсии = Неопределено;
	ЧислоФайлов = 0;
	ЧислоВерсий = 0;
	РазмерВерсий = 0;
	
	МассивРезультатов = Новый Массив;
	
	Попытка
		
		СоздатьКаталог(ИмяКаталогаСохранения);
		
		ВерсияСсылка = Неопределено;
		
		Выборка = РезультатЗапроса.Выбрать();
		Пока Выборка.Следующий() Цикл
			
			ВерсияСсылка = Выборка.Ссылка;
			ВыполнитьУдалениеНеактивнойВерсииФайла(ВерсияСсылка, Выборка, ИмяКаталогаСохранения, 
				МассивРезультатов, ВладелецВерсии, ЧислоФайлов, ЧислоВерсий, РазмерВерсий);
			
		КонецЦикла;
		
	Исключение
		
		// Записать ошибку в журнал регистрации
		СообщениеОбОшибке = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ЗаписьЖурналаРегистрации(НСтр("ru='Ошибка очистки неактивных версий файлов'"), 
		УровеньЖурналаРегистрации.Ошибка, 
		, , СообщениеОбОшибке);
		
	КонецПопытки;
	
	Если МассивРезультатов.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Описание = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Всего очищено: %1 версий из %2 файлов. Объем: %3 Мб. 
			|Версии сохранены в каталог ""%4"".
			|Список очищенных версий в приложенном файле ""Отчет.html"".'"),
		ЧислоВерсий,
		ЧислоФайлов,
		ФайловыеФункцииКлиентСервер.ПолучитьСтрокуСРазмеромФайла(РазмерВерсий / (1024 * 1024)),
		ИмяКаталогаСохранения);
	
	// Записать текст в журнал регистрации
	ЗаписьЖурналаРегистрации(НСтр("ru='Выполнена очистка устаревших версий файлов'"), 
		УровеньЖурналаРегистрации.Информация, 
		, , Описание);
		
	ИмяФайлаЗаписиОтчета = ЗаписатьОтчетОбУдаленииВерсий(МассивРезультатов);
	
	ТипОповещения = ПолучитьТипОповещенияОтветственногоЗаУдалениеНеактивныхВерсий();
	Ответственный = ПолучитьОтветственногоЗаУдалениеНеактивныхВерсий();
	
	АдресФайла = ПоместитьВоВременноеХранилище(Новый ДвоичныеДанные(ИмяФайлаЗаписиОтчета));
	
	// Оповещение по электронной почте
	Если ТипОповещения = Перечисления.ТипыОповещения.ЭлектроннаяПочта Тогда
		
		Уведомление = Новый Структура("Заголовок, Содержание", 
		НСтр("ru='Отчет об автоматической очистке устаревших версий файлов'"), Описание);
		ОтправитьУведомление(Уведомление, Ответственный, АдресФайла);
		
	Иначе // Оповещение с помощью задачи - бизнес-процесс Ознакомление
		
		ПапкаДляХраненияОтчетовОбУдалении = ПолучитьПапкуДляХраненияОтчетовОбУдалении();
		
		Файл = Новый Файл(ИмяФайлаЗаписиОтчета);
		
		ФайлССылка = СоздатьФайлСВерсией(
			ПапкаДляХраненияОтчетовОбУдалении,
			НСтр("ru = 'Отчет'"),
			"html",
			Файл.ПолучитьВремяИзменения(),
			Файл.ПолучитьУниверсальноеВремяИзменения(),
			Файл.Размер(),
			АдресФайла,
			"",
			Ложь);
		
		БизнесПроцесс = БизнесПроцессы.Ознакомление.СоздатьБизнесПроцесс();
		БизнесПроцесс.Автор = Ответственный;
		Строка = БизнесПроцесс.Исполнители.Добавить();
		Строка.Исполнитель = Ответственный;
		БизнесПроцесс.Наименование 
			= НСтр("ru='Ознакомиться с результатами автоматической очистки устаревших версий файлов'");
		БизнесПроцесс.Описание = Описание;
		БизнесПроцесс.Дата = ТекущаяДатаСеанса();
		
		Мультипредметность.ПередатьПредметыПроцессу(БизнесПроцесс, ФайлССылка);
		
		БизнесПроцесс.Записать();
		БизнесПроцесс.Старт();
		
	КонецЕсли;
	
КонецПроцедуры

// Получить имя каталога для сохранения очищаемых версий
Функция ПолучитьИмяКаталогаСохранения() Экспорт
	
	ПутьСохраненияУдаляемыхВерсий = ПолучитьПутьСохраненияУдаляемыхВерсий();
	ИмяКаталогаСохранения = ПутьСохраненияУдаляемыхВерсий;
	ИмяКаталогаСохранения = ОбщегоНазначенияКлиентСервер.ДобавитьКонечныйРазделительПути(ИмяКаталогаСохранения, ОбщегоНазначенияПовтИсп.ТипПлатформыСервера());
	Дата = ТекущаяДатаСеанса();
	ИмяКаталогаСохранения = ИмяКаталогаСохранения + Формат(Дата, "ДФ=ггггММдд")
		+ ОбщегоНазначенияКлиентСервер.РазделительПути();
	
	Возврат ИмяКаталогаСохранения;
	
КонецФункции	

Функция ЗаписатьОтчетОбУдаленииВерсий(МассивРезультатов)
	
	ТабДок = Новый ТабличныйДокумент;
	ТабМакет = Обработки.ОчисткаУстаревшихВерсийФайлов.ПолучитьМакет("МакетОтчета");
	ОбластьСтрока = ТабМакет.ПолучитьОбласть("Строка");
		
	ВладелецВерсии = Неопределено;
	Для Каждого ОписаниеВерсии Из МассивРезультатов Цикл
		
		Если ВладелецВерсии <> ОписаниеВерсии.ВладелецВерсии Тогда
			
			ВладелецВерсии = ОписаниеВерсии.ВладелецВерсии;
			
			ОбластьЗаголовок = ТабМакет.ПолучитьОбласть("Заголовок");
			ОбластьЗаголовок.Параметры.Описание = ОписаниеВерсии.ПредставлениеВладельца;
			ТабДок.Вывести(ОбластьЗаголовок);
			
			ОбластьШапка = ТабМакет.ПолучитьОбласть("Шапка");
			ТабДок.Вывести(ОбластьШапка);
			
			
		КонецЕсли;	
		
		ОбластьСтрока.Параметры.Автор = ОписаниеВерсии.Автор;
		ОбластьСтрока.Параметры.НомерВерсии = ОписаниеВерсии.НомерВерсии;
		ОбластьСтрока.Параметры.Комментарий = ОписаниеВерсии.Комментарий;
		ОбластьСтрока.Параметры.ДатаСоздания = ОписаниеВерсии.ДатаСоздания;
		ОбластьСтрока.Параметры.Размер = ОписаниеВерсии.Размер;
		
		ТабДок.Вывести(ОбластьСтрока);
		
	КонецЦикла;

	Отчет = Новый ТабличныйДокумент;
	Отчет.Вывести(ТабДок);
	
	ИмяФайлаЗаписиОтчета = ПолучитьИмяВременногоФайла("html");
	Отчет.Записать(ИмяФайлаЗаписиОтчета, ТипФайлаТабличногоДокумента.HTML);
	
	Возврат ИмяФайлаЗаписиОтчета;
	
КонецФункции	

Функция ОтправитьУведомление(Уведомление, Получатель, АдресФайла)
	
	Вложение = Новый Структура;
	Вложение.Вставить("Адрес", АдресФайла);
	Вложение.Вставить("ИмяФайла", НСтр("ru = 'Отчет.html'"));
	
	ПараметрыПисьма = Новый Структура;
	ПараметрыПисьма.Вставить("Кому", ПолучитьАдресДляОтправкиУведомленияПользователю(Получатель));
	ПараметрыПисьма.Вставить("Тема", Уведомление.Заголовок);
	ПараметрыПисьма.Вставить("Текст", Уведомление.Содержание);
	ПараметрыПисьма.Вставить("Вложения", Новый Массив);
	ПараметрыПисьма.Вложения.Добавить(Вложение);
	
	Попытка
		Результат = ЛегкаяПочтаСервер.ОтправитьИнтернетПочта(ПараметрыПисьма);
	Исключение
		ВызватьИсключение;
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

Функция ПолучитьАдресДляОтправкиУведомленияПользователю(Получатель) Экспорт
	
	Если ТипЗнч(Получатель) = Тип("СправочникСсылка.Пользователи") Тогда
		ТекстЗапроса =
			"ВЫБРАТЬ
			|	КонтактнаяИнформация.АдресЭП КАК ПочтовыйАдрес,
			|	ПРЕДСТАВЛЕНИЕ(КонтактнаяИнформация.Ссылка) КАК Представление
			|ИЗ
			|	Справочник.Пользователи.КонтактнаяИнформация КАК КонтактнаяИнформация
			|ГДЕ
			|	КонтактнаяИнформация.Ссылка = &Ссылка
			|	И КонтактнаяИнформация.Тип = ЗНАЧЕНИЕ(Перечисление.ТипыКонтактнойИнформации.АдресЭлектроннойПочты)
			|	И КонтактнаяИнформация.Вид = ЗНАЧЕНИЕ(Справочник.ВидыКонтактнойИнформации.EmailПользователя)";
		
	Иначе
		ВызватьИсключение НСтр("ru = 'В функцию ПолучитьАдресДляОтправкиУведомленияПользователю передан некорректный параметр'");
	КонецЕсли;
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("Ссылка", Получатель);
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат "";
	КонецЕсли;
	
	СтрокаРезультата = РезультатЗапроса.Выгрузить()[0];
	Результат = РаботаСоСтроками.ПолучитьПредставлениеАдресаЭлектроннойПочты(
		Строка(СтрокаРезультата.Представление),
		СокрЛП(СтрокаРезультата.ПочтовыйАдрес));
	
	Возврат Результат;
	
КонецФункции

Процедура УдалитьИзРегистраОбращенияКВерсиямФайлов(ВерсияСсылка)
	
	УстановитьПривилегированныйРежим(Истина);
	
	НаборЗаписей = РегистрыСведений.ОбращенияКВерсиямФайлов.СоздатьНаборЗаписей();
	
	НаборЗаписей.Отбор.Версия.Установить(ВерсияСсылка);
	
	// не добавляем записи в набор - чтобы все стереть
	НаборЗаписей.Записать();
	
КонецПроцедуры	

// Формирует текст ошибки для помещения в журнал регистрации
// Параметры
//  ИнформацияОбОшибкеФункции  - ИнформацияОбОшибке
//  ВерсияСсылка  - СправочникСсылка.ВерсииФайлов - версия
//
// Возвращаемое значение:
//   Строка - описание ошибки
Функция СформироватьТекстОшибкиУдаленияВерсии(ИнформацияОбОшибкеФункции, ВерсияСсылка) Экспорт
	
	СообщениеОбОшибке = ПодробноеПредставлениеОшибки(ИнформацияОбОшибкеФункции);
	СообщениеОбОшибке = СообщениеОбОшибке + Символы.ПС + Нстр("ru = 'Ссылка на версию: ""'");
	Если ВерсияСсылка <> Неопределено Тогда
		СообщениеОбОшибке = СообщениеОбОшибке + ПолучитьНавигационнуюСсылку(ВерсияСсылка) + """ ";
		СообщениеОбОшибке = СообщениеОбОшибке + Символы.ПС;
		СообщениеОбОшибке = СообщениеОбОшибке + НСтр("ru='Файл: '") + Строка(ВерсияСсылка.Владелец);
	КонецЕсли;
	
	Возврат СообщениеОбОшибке;
	
КонецФункции // СформироватьТекстОшибкиУдаленияВерсии

// Возвращает константу СрокХраненияНеактивныхВерсий
Функция ПолучитьСрокХраненияНеактивныхВерсий() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	СрокХраненияНеактивныхВерсий = Константы.СрокХраненияНеактивныхВерсий.Получить();
	
	Если СрокХраненияНеактивныхВерсий = 0 Тогда
		СрокХраненияНеактивныхВерсий = 180;
		Константы.СрокХраненияНеактивныхВерсий.Установить(СрокХраненияНеактивныхВерсий);
	КонецЕсли;    
	
	Возврат СрокХраненияНеактивныхВерсий;
	
КонецФункции

// Возвращает константу ОчищатьДанныеДляПолнотекстовогоПоиска
Функция ПолучитьОчищатьДанныеДляПолнотекстовогоПоиска() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	ОчищатьДанныеДляПолнотекстовогоПоиска = Константы.ОчищатьДанныеДляПолнотекстовогоПоиска.Получить();
	Возврат ОчищатьДанныеДляПолнотекстовогоПоиска;
	
КонецФункции

// Возвращает константу ПутьСохраненияУдаляемыхВерсий
Функция ПолучитьПутьСохраненияУдаляемыхВерсий() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ТипПлатформыСервера = ОбщегоНазначенияПовтИсп.ТипПлатформыСервера();
	
	Если ТипПлатформыСервера = ТипПлатформы.Windows_x86 Или ТипПлатформыСервера = ТипПлатформы.Windows_x86_64 Тогда
		Возврат Константы.ПутьСохраненияУдаляемыхВерсийWindows.Получить();
	Иначе	
		Возврат Константы.ПутьСохраненияУдаляемыхВерсийLinux.Получить();
	КонецЕсли;	
	
КонецФункции

// Возвращает константу ОтветственныйЗаУдалениеНеактивныхВерсий
Функция ПолучитьОтветственногоЗаУдалениеНеактивныхВерсий() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	ОтветственныйЗаУдалениеНеактивныхВерсий = Константы.ОтветственныйЗаУдалениеНеактивныхВерсий.Получить();
	Возврат ОтветственныйЗаУдалениеНеактивныхВерсий;
	
КонецФункции

// Возвращает константу ПапкаДляХраненияОтчетовОбУдалении
Функция ПолучитьПапкуДляХраненияОтчетовОбУдалении() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	ПапкаДляХраненияОтчетовОбУдалении = Константы.ПапкаДляХраненияОтчетовОбУдалении.Получить();
	Возврат ПапкаДляХраненияОтчетовОбУдалении;
	
КонецФункции

// Возвращает константу ТипОповещенияОтветственногоЗаУдалениеНеактивныхВерсий
Функция ПолучитьТипОповещенияОтветственногоЗаУдалениеНеактивныхВерсий() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	ТипОповещения = Константы.ТипОповещенияОтветственногоЗаУдалениеНеактивныхВерсий.Получить();
	
	Если ТипОповещения.Пустая() Тогда
		ТипОповещения = Перечисления.ТипыОповещения.ЭлектроннаяПочта;
		Константы.ТипОповещенияОтветственногоЗаУдалениеНеактивныхВерсий.Установить(ТипОповещения);
	КонецЕсли;    
	
	Возврат ТипОповещения;
	
КонецФункции

// Записывает в регистр ОбращенияКВерсиямФайлов - при изменении или получении версии
Процедура ЗаписатьОбращениеКВерсииФайла(ВерсияСсылка) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	// запишем в регистр
	МенеджерЗаписи = РегистрыСведений.ОбращенияКВерсиямФайлов.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.Версия = ВерсияСсылка;
	МенеджерЗаписи.ДатаПоследнегоОбращения = ТекущаяДатаСеанса();
	МенеджерЗаписи.Записать(Истина);

КонецПроцедуры

// Записывает в регистр СведенияОСохраненииКопийУстаревшихВерсий
Процедура ЗаписатьВРегистрСведенияОСохраненииКопийУстаревшихВерсий(ВерсияСсылка, Имя)
	
	// запишем в регистр
	МенеджерЗаписи = РегистрыСведений.СведенияОСохраненииКопийУстаревшихВерсий.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.Версия = ВерсияСсылка;
	МенеджерЗаписи.ПолноеИмя = Имя;
	МенеджерЗаписи.Записать(Истина);

КонецПроцедуры

// Читает полное имя (с путем) из регистра СведенияОСохраненииКопийУстаревшихВерсий
Функция ПолучитьИмяСохраненияВерсии(ВерсияСсылка) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	// Подготовить структуру отбора по измерениям 
	СтруктураОтбора = Новый Структура;
	СтруктураОтбора.Вставить("Версия", ВерсияСсылка);
	
	// Получить структуру с данными ресурсов записи
	СтруктураРесурсов = РегистрыСведений.СведенияОСохраненииКопийУстаревшихВерсий.Получить(СтруктураОтбора);
	
	// Получить путь из регистра
	Возврат СтруктураРесурсов.ПолноеИмя;

КонецФункции

// Записывает ХранилищеФайла в информационную базу
//
// Параметры
// ВерсияСсылка - ссылка на версию файла
// ХранилищеФайла - ХранилищеЗначения, с двоичными данными файла, которые требуется записать
//
Процедура ЗаписатьФайлВИнформационнуюБазу(ВерсияСсылка, ХранилищеФайла) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	МенеджерЗаписи = РегистрыСведений.ХранимыеФайлыВерсий.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.ВерсияФайла = ВерсияСсылка;
	МенеджерЗаписи.ХранимыйФайл = ХранилищеФайла;
	МенеджерЗаписи.Записать(Истина);
	
КонецПроцедуры

// Удаляет запись в регистре ХранимыеФайлыВерсий
//
// Параметры
// ВерсияСсылка - ссылка на версию файла
//
Процедура УдалитьЗаписьИзРегистраХранимыеФайлыВерсий(ВерсияСсылка) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	НаборЗаписей = РегистрыСведений.ХранимыеФайлыВерсий.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.ВерсияФайла.Установить(ВерсияСсылка);
	НаборЗаписей.Записать();
	
КонецПроцедуры

// Читает ХранилищеФайла из информационной базы
//
// Параметры
// ВерсияСсылка - ссылка на версию файла
//
// Возвращаемое значение:
//   ХранилищеЗначения, с двоичными данными файла
Функция ПолучитьХранилищеФайлаИзИнформационнойБазы(ВерсияСсылка) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	МенеджерЗаписи = РегистрыСведений.ХранимыеФайлыВерсий.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.ВерсияФайла = ВерсияСсылка;
	МенеджерЗаписи.Прочитать();
	
	Возврат МенеджерЗаписи.ХранимыйФайл;
	
КонецФункции

// Инициализирует константу ХранитьФайлыВТомахНаДиске из УдалитьТипХраненияФайлов 
Процедура ИнициализироватьКонстантуХранитьФайлыВТомахНаДиске() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ТипХраненияФайлов = Константы.УдалитьТипХраненияФайлов.Получить();
	
	Если ТипХраненияФайлов = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
		Константы.ХранитьФайлыВТомахНаДиске.Установить(Истина);
	КонецЕсли;	
	
КонецПроцедуры	

// переносит бинарный файл из ФайлХранилище справочника ВерсииФайлов в регистр сведений ХранимыеФайлыВерсий
Процедура ПереместитьФайлыИзИнформационнойБазыВРегистрСведений() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ВерсииФайлов.Ссылка
		|ИЗ
		|	Справочник.ВерсииФайлов КАК ВерсииФайлов
		|ГДЕ
		|	ВерсииФайлов.ТипХраненияФайла = &ТипХраненияФайла";
		
	Запрос.УстановитьПараметр("ТипХраненияФайла", Перечисления.ТипыХраненияФайлов.ВИнформационнойБазе);	

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		
		Объект = Выборка.Ссылка.ПолучитьОбъект();
		
		ДанныеВХранилище = Объект.ФайлХранилище.Получить();
		Если ТипЗнч(ДанныеВХранилище) = Тип("ДвоичныеДанные") Тогда
			ЗаписатьФайлВИнформационнуюБазу(Выборка.Ссылка, Объект.ФайлХранилище);
			Объект.ФайлХранилище = Новый ХранилищеЗначения(""); // очищаем значение
			Объект.Записать();
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры	

// заполняет поле ДатаЗаема текущей датой
Процедура ЗаполнитьДатуЗаема() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ДатаЗаема = ТекущаяДатаСеанса();

	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	Файлы.Ссылка
		|ИЗ
		|	Справочник.Файлы КАК Файлы";

	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Если НЕ Выборка.Ссылка.Редактирует.Пустая() Тогда
			Объект = Выборка.Ссылка.ПолучитьОбъект();
			Объект.ДополнительныеСвойства.Вставить("ЗаписьПодписанногоОбъекта", Истина); // чтобы прошла запись ранее подписанного объекта
			Объект.ДатаЗаема = ДатаЗаема;
			Объект.Записать();
		КонецЕсли;
	КонецЦикла;	
	
КонецПроцедуры	

// Проинициализирует ХранитьФайлыВТомахНаДиске из ТипХраненияФайлов
Процедура ПроинициализироватьХранитьФайлыВТомахНаДиске() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ТипХраненияФайлов = Константы.УдалитьТипХраненияФайлов.Получить();
	ХранитьФайлыВТомахНаДиске = (ТипХраненияФайлов = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске);
	Константы.ХранитьФайлыВТомахНаДиске.Установить(ХранитьФайлыВТомахНаДиске);
	
КонецПроцедуры	

// Возвращает Истина в параметре ЕстьХранимыеФайлы, если есть хранимые файлы к объекту ВнешнийОбъект.
//
Процедура ОпределитьНаличиеХранимыхФайлов(ВнешнийОбъект, ЕстьХранимыеФайлы) Экспорт
	
	Если ЕстьХранимыеФайлы = Истина Тогда
		Возврат;
    КонецЕсли;
	ТипыВладельцев = Метаданные.ОбщиеКоманды.ПрисоединенныеФайлы.ТипПараметраКоманды.Типы();
	Если ТипыВладельцев.Найти(ТипЗнч(ВнешнийОбъект)) <> Неопределено Тогда
		МассивФайлов = ПолучитьВсеПодчиненныеФайлы(ВнешнийОбъект);
		ЕстьХранимыеФайлы = МассивФайлов.Количество() <> 0;
	КонецЕсли;
	
КонецПроцедуры

// Читает кодировку версии файла
//
// Параметры
// ВерсияСсылка - ссылка на версию файла
//
// Возвращаемое значение:
//   Строка кодировки
Функция ПолучитьКодировкуВерсииФайла(ВерсияСсылка) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	МенеджерЗаписи = РегистрыСведений.КодировкиВерсийФайлов.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.ВерсияФайла = ВерсияСсылка;
	МенеджерЗаписи.Прочитать();
	
	Возврат МенеджерЗаписи.Кодировка;
	
КонецФункции

// Записывает кодировку версии файла
//
// Параметры
// ВерсияСсылка - ссылка на версию файла
// Кодировка - Строка кодировки
//
Процедура ЗаписатьКодировкуВерсииФайла(ВерсияСсылка, Кодировка) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	МенеджерЗаписи = РегистрыСведений.КодировкиВерсийФайлов.СоздатьМенеджерЗаписи();
	МенеджерЗаписи.ВерсияФайла = ВерсияСсылка;
	МенеджерЗаписи.Кодировка = Кодировка;
	МенеджерЗаписи.Записать(Истина);
	
КонецПроцедуры

// Записывает кодировку версии файла
//
// Параметры
// ВерсияСсылка - ссылка на версию файла
// Кодировка - Строка кодировки
// ИзвлеченныйТекст - текст, извлеченный из файла
//
Процедура ЗаписатьКодировкуВерсииФайлаИИзвлеченныйТекст(ВерсияСсылка, Кодировка, ИзвлеченныйТекст) Экспорт
	
	ЗаписатьКодировкуВерсииФайла(ВерсияСсылка, Кодировка);
	ЗаписатьРезультатИзвлеченияТекста(ВерсияСсылка, Перечисления.СтатусыИзвлеченияТекстаФайлов.Извлечен, 
		ИзвлеченныйТекст);
	
КонецПроцедуры

// Получает ДвоичныеДанные файла
// Параметры
//  ФайлСсылка  - СправочникСсылка.Файлы - файл
//
// Возвращаемое значение:
//  ДвоичныеДанные
Функция ПолучитьДвоичныеДанныеФайла(ФайлСсылка) Экспорт
	
	ДвоичныеДанные = Неопределено;
	
	ВерсияСсылка = ОбщегоНазначения.ПолучитьЗначениеРеквизита(ФайлСсылка, "ТекущаяВерсия");
	
	ТипХраненияФайла = ВерсияСсылка.ТипХраненияФайла;
	Если ТипХраненияФайла = Перечисления.ТипыХраненияФайлов.ВТомахНаДиске Тогда
		Если НЕ ВерсияСсылка.Том.Пустая() Тогда
			ПолныйПуть = ФайловыеФункции.ПолныйПутьТома(ВерсияСсылка.Том) + ВерсияСсылка.ПутьКФайлу; 
			Попытка
				ДвоичныеДанные = Новый ДвоичныеДанные(ПолныйПуть);
			Исключение
				// запись в журнал регистрации
				СообщениеОбОшибке = СформироватьТекстОшибкиПолученияФайлСТомаДляАдминистратора(ИнформацияОбОшибке(), ВерсияСсылка.Владелец);
				ЗаписьЖурналаРегистрации(НСтр("ru = 'Открытие файла'"), 
					УровеньЖурналаРегистрации.Ошибка, Метаданные.Справочники.Файлы, ВерсияСсылка.Владелец, СообщениеОбОшибке);
				
				ВызватьИсключение ФайловыеФункцииСлужебныйКлиентСервер.ОшибкаФайлНеНайденВХранилищеФайлов(
					ВерсияСсылка.ПолноеНаименование + "." + ВерсияСсылка.Расширение);
					
			КонецПопытки;
		КонецЕсли;
	Иначе
		ХранилищеФайла = ПолучитьХранилищеФайлаИзИнформационнойБазы(ВерсияСсылка);
		ДвоичныеДанные = ХранилищеФайла.Получить();
	КонецЕсли;
	
	ЗаписатьОбращениеКВерсииФайла(ВерсияСсылка);
	
	Возврат ДвоичныеДанные;
	
КонецФункции

// Обработчик подписи ФайлПриЗаписи
Процедура ПриЗаписиФайлаСервер(Источник) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если Источник.ПометкаУдаления Тогда
		
		ЕстьФайлы = ОбъектИмеетФайлы(Источник.ВладелецФайла);
		РегистрыСведений.КешИнформацииОбОбъектах.УстановитьПризнак(Источник.ВладелецФайла, "ЕстьФайлы", ЕстьФайлы);
		
	Иначе
		
		РегистрыСведений.КешИнформацииОбОбъектах.УстановитьПризнак(
				Источник.ВладелецФайла, "ЕстьФайлы", Истина);
		
	КонецЕсли;
	
	Если Делопроизводство.ФайлЯвляетсяОригиналом(Источник.Ссылка) Тогда 
		Делопроизводство.ОбновитьСведенияОНаличииОригинала(Источник.ВладелецФайла);
	КонецЕсли;	
	
КонецПроцедуры

// Проверяет, что к объекту с файлами присоединен по крайней мере один файл
//
Функция ОбъектИмеетФайлы(ВладелецФайла) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ТекстЗапроса = 
		"ВЫБРАТЬ
		|	Файлы.Ссылка
		|ИЗ
		|	Справочник.Файлы КАК Файлы
		|ГДЕ
		|	Файлы.ВладелецФайла = &ВладелецФайла
		|	И Файлы.ПометкаУдаления = ЛОЖЬ";
		
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.Параметры.Вставить("ВладелецФайла", ВладелецФайла);
	
	Если Запрос.Выполнить().Пустой() Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли;
	
КонецФункции

// Заполняет регистр КешИнформацииОбОбъектах при обновлении базы
Процедура ЗаполнитьРегистрКешИнформацииОбОбъектах() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	Файлы.ВладелецФайла КАК ВладелецФайла
		|ИЗ
		|	Справочник.Файлы КАК Файлы
		|ГДЕ
		|	Файлы.ПометкаУдаления = ЛОЖЬ";
		
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		РегистрыСведений.КешИнформацииОбОбъектах.УстановитьПризнак(
			Выборка.ВладелецФайла, "ЕстьФайлы", Истина);	
		
	КонецЦикла;
	
КонецПроцедуры

Функция ПолучитьИзвлекатьТекстыФайловНаСервере() Экспорт 
	
	УстановитьПривилегированныйРежим(Истина);
	ИзвлекатьТекстыФайловНаСервере = Константы.ИзвлекатьТекстыФайловНаСервере.Получить();
	Возврат ИзвлекатьТекстыФайловНаСервере;
	
КонецФункции	

Процедура ОсвободитьФайлыВладельца(Владелец) Экспорт
	
	Запрос = Новый Запрос(
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	Файлы.Ссылка КАК Ссылка,
		|	Файлы.Редактирует КАК Редактирует
		|ИЗ
		|	Справочник.Файлы КАК Файлы
		|ГДЕ
		|	Файлы.ВладелецФайла = &ВладелецФайла");
	Запрос.УстановитьПараметр("ВладелецФайла", Владелец);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		
		ФайлОбъект = Выборка.Ссылка.ПолучитьОбъект();
		ФайлОбъект.Заблокировать();
		
		ФайлОбъект.Редактирует = Справочники.Пользователи.ПустаяСсылка();
		ФайлОбъект.ДатаЗаема = Дата("00010101000000");
		ФайлОбъект.Записать();
		
		БизнесСобытияВызовСервера.ЗарегистрироватьСобытие(Выборка.Ссылка, Справочники.ВидыБизнесСобытий.ОсвобождениеФайла);
		
	КонецЦикла;
	
КонецПроцедуры    

Функция ПолучитьДокументИзВременногоХранилища(АдресВременногоХранилища, Расширение) Экспорт
	
	Попытка
		Если Расширение = "mxl" Тогда
			Документ = Новый ТабличныйДокумент;
		ИначеЕсли Расширение = "geo" Тогда
			Документ = Новый ГеографическаяСхема;
		КонецЕсли;
		
		ДвоичныеДанные = ПолучитьИзВременногоХранилища(АдресВременногоХранилища);
		ИмяВременногоФайла 	= ПолучитьИмяВременногоФайла(Расширение);
		ДвоичныеДанные.Записать(ИмяВременногоФайла);
		Документ.Прочитать(ИмяВременногоФайла);
		
		УдалитьИзВременногоХранилища(АдресВременногоХранилища);
		
		Возврат Документ;
		
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
КонецФункции	

// Параметры
//  ДанныеФайла  - структура с данными файла
//  УникальныйИдентификатор - уникальный идентификатор формы
Процедура ОсвободитьФайлПоСсылке(Ссылка, УникальныйИдентификатор = Неопределено) Экспорт
	
	ФайлОбъект = Ссылка.ПолучитьОбъект();
	
	ЗаблокироватьДанныеДляРедактирования(ФайлОбъект.Ссылка, , УникальныйИдентификатор);
	ФайлОбъект.Редактирует = Справочники.Пользователи.ПустаяСсылка();
	ФайлОбъект.ДатаЗаема = Дата("00010101000000");
	ФайлОбъект.Записать();
	РазблокироватьДанныеДляРедактирования(ФайлОбъект.Ссылка, УникальныйИдентификатор);
	
	БизнесСобытияВызовСервера.ЗарегистрироватьСобытие(Ссылка, Справочники.ВидыБизнесСобытий.ОсвобождениеФайла);
	
КонецПроцедуры    

// После успешного завершения удаляет временные файлы и каталог, если он пуст
Процедура ЗафиксироватьТранзакциюДляФайловВТоме(ДанныеДляВосстановленияФайловВТоме) Экспорт
	 
 	Для Каждого ДанныеВосстановления Из ДанныеДляВосстановленияФайловВТоме Цикл
		
		СтарыйПуть = ДанныеВосстановления.СтарыйПуть;
		ВременныйПуть = ДанныеВосстановления.ВременныйПуть;
		
		Попытка
			
			// удаляем временный файл
			
			ФайлНаДискеВременный = Новый Файл(ВременныйПуть);
			ФайлНаДискеВременный.УстановитьТолькоЧтение(Ложь);
			
			УдалитьФайлы(ВременныйПуть);
			
			// удаляем каталог основного файла, если он пуст
			ФайлНаДиске = Новый Файл(СтарыйПуть);
			
			ПутьСПодкаталогом = ФайлНаДиске.Путь;
			МассивФайловВКаталоге = НайтиФайлы(ПутьСПодкаталогом, "*.*");
			Если МассивФайловВКаталоге.Количество() = 0 Тогда
				УдалитьФайлы(ПутьСПодкаталогом);
			КонецЕсли;
			
		Исключение
			// не обрабатываем исключение, даже если с файлами была ошибка.
		КонецПопытки;
		
	КонецЦикла;	
		
КонецПроцедуры

// При неудаче восстанавливает файлы в томе
Процедура ОтменитьТранзакциюДляФайловВТоме(ДанныеДляВосстановленияФайловВТоме) Экспорт
	
	Для Каждого ДанныеВосстановления Из ДанныеДляВосстановленияФайловВТоме Цикл
		
		СтарыйПуть = ДанныеВосстановления.СтарыйПуть;
		ВременныйПуть = ДанныеВосстановления.ВременныйПуть;
		
		Попытка
			
			// возвращаем из временного файла в прежнее место
			ПереместитьФайл(ВременныйПуть, СтарыйПуть);
			
		Исключение
			// не обрабатываем исключение, даже если с файлами была ошибка.
		КонецПопытки;
		
	КонецЦикла;	
	
КонецПроцедуры

//Мисофт+
Функция ПолучитьВсеПодчиненныеДополнительныеМатериалы(ВладелецФайла, 
	ПолучатьПомеченныеНаУдаление = Истина,
	ПривилегированныйРежим = Ложь) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	Файлы.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.Файлы КАК Файлы
		|ГДЕ
		|	Файлы.ВладелецФайла = &ВладелецФайла
		|	И Файлы.ЯвляетсяДопМатериалом = ИСТИНА";
	
	Если НЕ ПолучатьПомеченныеНаУдаление Тогда
		Запрос.Текст = Запрос.Текст + " И Файлы.ПометкаУдаления = &ПометкаУдаления";
	КонецЕсли;
	
	Запрос.Текст = Запрос.Текст + 	
		" УПОРЯДОЧИТЬ ПО
		|	Файлы.Наименование";
	
	Если НЕ ПолучатьПомеченныеНаУдаление Тогда
		Запрос.УстановитьПараметр("ПометкаУдаления", Ложь);
	КонецЕсли;
	
	Если ПривилегированныйРежим Тогда 
		УстановитьПривилегированныйРежим(Истина);
	КонецЕсли;
	
	Запрос.УстановитьПараметр("ВладелецФайла", ВладелецФайла);
	Таблица = Запрос.Выполнить().Выгрузить();
	МассивВозврата = Таблица.ВыгрузитьКолонку("Ссылка");
	
	Возврат МассивВозврата;
	
КонецФункции

Функция ПолучитьВсеПодчиненныеФайлы21(ВладелецФайла, 
	ПолучатьПомеченныеНаУдаление = Истина,
	ПривилегированныйРежим = Ложь) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	Файлы.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.Файлы КАК Файлы
		|ГДЕ
		|	Файлы.ВладелецФайла = &ВладелецФайла
		|	И Файлы.ЯвляетсяДопМатериалом = ЛОЖЬ";
	
	Если НЕ ПолучатьПомеченныеНаУдаление Тогда
		Запрос.Текст = Запрос.Текст + " И Файлы.ПометкаУдаления = &ПометкаУдаления";
	КонецЕсли;
	
	Запрос.Текст = Запрос.Текст + 	
		" УПОРЯДОЧИТЬ ПО
		|	Файлы.Наименование";
	
	Если НЕ ПолучатьПомеченныеНаУдаление Тогда
		Запрос.УстановитьПараметр("ПометкаУдаления", Ложь);
	КонецЕсли;
	
	Если ПривилегированныйРежим Тогда 
		УстановитьПривилегированныйРежим(Истина);
	КонецЕсли;
	
	Запрос.УстановитьПараметр("ВладелецФайла", ВладелецФайла);
	Таблица = Запрос.Выполнить().Выгрузить();
	МассивВозврата = Таблица.ВыгрузитьКолонку("Ссылка");
	
	Возврат МассивВозврата;
	
КонецФункции

